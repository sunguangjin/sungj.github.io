<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="hooks," />










<meta name="description" content="React Hooks 起源 React 一直都提倡使用函数式组件。更轻便，更优雅，性能更佳。函数式组件又称无状态组件(FSC)。 以前，需要使用 state ，生命周期等React 特性，必须重构为 class 组件。 Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 现在，你可以直接在现有的函数式组件中使">
<meta property="og:type" content="article">
<meta property="og:title" content="拥抱 React Hooks （一）基础">
<meta property="og:url" content="http://www.mala520.life/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/index.html">
<meta property="og:site_name" content="Live and learn">
<meta property="og:description" content="React Hooks 起源 React 一直都提倡使用函数式组件。更轻便，更优雅，性能更佳。函数式组件又称无状态组件(FSC)。 以前，需要使用 state ，生命周期等React 特性，必须重构为 class 组件。 Hooks 是 React 16.8 新增的特性，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。 现在，你可以直接在现有的函数式组件中使">
<meta property="og:image" content="http://www.mala520.life/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/hooks-1.jpg">
<meta property="article:published_time" content="2020-03-18T06:16:43.000Z">
<meta property="article:modified_time" content="2021-10-25T01:58:57.975Z">
<meta property="article:author" content="祁连">
<meta property="article:tag" content="hooks">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.mala520.life/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/hooks-1.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mala520.life/2020/03/18/拥抱React-Hooks/"/>





<link rel="stylesheet" href="/js/prism/prism.css">

  <title>拥抱 React Hooks （一）基础 | Live and learn</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Live and learn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">拥抱 React Hooks （一）基础</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T14:16:43+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="React-Hooks-起源"><a href="#React-Hooks-起源" class="headerlink" title="React Hooks 起源"></a>React Hooks 起源</h1><ul>
<li>React 一直都提倡使用函数式组件。更轻便，更优雅，性能更佳。函数式组件又称<strong>无状态组件(FSC)</strong>。</li>
<li>以前，需要使用 <code>state</code> ，生命周期等React 特性，必须重构为 class 组件。</li>
<li><code>Hooks</code> 是 React 16.8 新增的特性，它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 React 特性。</li>
<li>现在，你可以直接在现有的函数式组件中使用 <code>Hooks</code>，而无须重构为 class 组件。</li>
<li>全新的思维方式。no magic, just javascript and some rules。</li>
</ul>
<img src="/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/hooks-1.jpg" class="" title="hooks起源">

<h1 id="类组件被诟病"><a href="#类组件被诟病" class="headerlink" title="类组件被诟病"></a>类组件被诟病</h1><ul>
<li>类(累)：自js开天辟地，就是面向函数式编程(FP), 面向对象编程(OOP)为何物。烦人的构造函数。super是什么？……</li>
<li>this绑定：类方法不会自动绑定 this 到实例上。现有四种<code>bind</code>方式。不优雅，易出错，<code>bind</code>还影响性能（使用箭头函数后有所改善）。</li>
<li>setState(): 异步更新机制，<code>state</code>浅合并机制。不理解这些概念，很容易踩坑。</li>
<li>生命周期耦合：每个生命周期方法通常包含一堆不相关的逻辑；不同生命周期中的逻辑又有关联。</li>
</ul>
<p>下面组件来自实际项目，经过简化和微调（方便演示和直观感受），基本上暴露出了上面所有问题。业务逻辑严谨性不用推敲：</p>
<pre><code class="language-jsx">class NumberInput extends React.Component {
  constructor(props) {
    // 为什么必须super，不传props会怎样
    super(props)
    this.state = {
      focus: false
    }
    this.tradingpwd = &#39;&#39;
    // 第一种bind，官方推荐
    ;[&#39;onBlur&#39;].forEach(method =&gt; {
      this[method] = this[method].bind(this)
    })
  }
  // 下面两个生命周期得相互配合，实现某些功能
  componentDidMount() {
    this.tradingPwdHideInput.focus()
    // 处理某类兼容问题
    let bodyTop = document.body.getBoundingClientRect().top
    const styleText = &#39;position: fixed; width: 100%; top: &#39; + bodyTop + &#39;px&#39;
    document.body.style.cssText = styleText
  }

  componentWillUnmount() {
    this.tradingPwdHideInput.blur()
    document.body.style.position = &#39;static&#39;
  }

  tradingPwdChange(e) {
    // ...
    this.tradingpwd = e.target.value
    this.props.inputChangeCallback(e.target.value)
    // ...
  }
  // 第二种bind
  onFocus = () =&gt; {
    this.setState({
      focus: true
    })
  }
  onBlur() {
    this.setState({
      focus: false
    })
  }

  render() {
    return (
      &lt;div className={classNames(&#39;NumberInput&#39;)}&gt;
        &lt;input
          type=&#39;tel&#39;
          ref={ref =&gt; {
            this.tradingPwdHideInput = ref
          }}
          id=&#39;tradingPwdHideInput&#39;
          /* 第三种bind */
          onClick={() =&gt; {
            this.tradingPwdHideInput.focus()
          }}
          onBlur={ this.onBlur }
          onFocus={ this.onFocus }
          /* 第四种bind，不推荐，在每次 render() 方法执行时绑定类方法，消耗性能*/
          onChange={ this.tradingPwdChange.bind(this) }
        /&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<blockquote>
<p><a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">proposal-class-fields</a> 新提案会改善上述情况，目前处于第三阶段。</p>
</blockquote>
<p>随着类组件趋于复杂，还有其他诟病：</p>
<ul>
<li>难拆分，本地state逻辑到处都是，当组件越来越复杂，想拆分比较难。</li>
<li>状态逻辑难复用：需要引入高阶特性进行代码重构，需要调整组件结构，成本高。</li>
<li>抽象地狱：大型React往往使用render props ，HOC，Context 等高阶特性，形成大量包装组件（wrapping components）。层级冗余，逻辑难追踪。</li>
</ul>
<p>深度包装的组件长这样：</p>
<pre><code class="language-jsx">import { compose } from &#39;recompose&#39;;
import { withRouter } from &#39;react-router-dom&#39;;
function App({ history, state, dispatch }) {
  return (
    &lt;ThemeContext.Consumer&gt;
      {theme =&gt;
        &lt;Content theme={theme}&gt;
          ... 
        &lt;/Content&gt;
      }
    &lt;/ThemeContext.Consumer&gt;
  );
}
export default compose(
  withRouter,
  withReducer(reducer, initialState)
)(App);</code></pre>
<p>确实很抽象。这是 React 中典型的<strong>抽象地狱（Abstraction hell）</strong>问题，也叫<strong>包装地狱（The wrapper hell）</strong>。</p>
<h1 id="Hooks-优越性"><a href="#Hooks-优越性" class="headerlink" title="Hooks 优越性"></a>Hooks 优越性</h1><p><code>Hooks</code> 引入的一个重要的原因，就是类组件存在着种种诟病。那他必然存在一些优越性。</p>
<p>在说明这些优越性之前，先了解一个概念：</p>
<blockquote>
<p><strong>副作用</strong>：React 中主要指那些没有发生在数据向视图（M-V）转换过程中的逻辑，如 <code>Ajax</code> 请求、访问原生 <code>DOM</code> 元素、本地持久化缓存、绑定/解绑事件、添加/取消订阅、设置定时器、记录日志等。</p>
</blockquote>
<p>Hooks 的优越性：</p>
<ul>
<li>函数式编程：No <code>class</code>, No <code>super</code>, No <code>this</code>。对于不了解 <code>OOP</code> 的 React 初学者更友好。</li>
<li>有状态逻辑易复用：可以通过 <code>Custom Hook</code>（后面讲解）重构，而不用修改组件结构。</li>
<li>易拆分：状态管理和副作用管理松耦合，原子性强。很容易将一些相关联的逻辑拆分成更小的函数。</li>
<li>可逐步引入：<code>Hooks</code> 向后兼容，与现有代码可并行工作，因此我们可以逐步采用它们。</li>
<li>副作用分组：很多副作用逻辑分散在类组件生命周期函数中。而 <code>Hooks</code> 可以将每个副作用的设置和清理封装在一个函数中。</li>
<li>副作用分离：副作用操作都在页面渲染之后。</li>
</ul>
<h1 id="抛弃类组件？"><a href="#抛弃类组件？" class="headerlink" title="抛弃类组件？"></a>抛弃类组件？</h1><p>既然 <code>Hooks</code> 存在这么多优越性。那是不是就到了抛弃 class 组件的时候了。</p>
<p>对此，官方说：</p>
<ul>
<li>新版本依然支持 <code>class</code> 相关API，在相当一段时期内，class 组件 和 Hooks 组件并存。</li>
<li>向后兼容，是加法。注意，是函数组件的加法，即 <code>Hooks</code> 只能用在函数组件中。</li>
<li>推荐使用 函数组件 + <code>Hooks</code>。</li>
</ul>
<p>个人觉得：</p>
<ul>
<li><strong>当下</strong>：不抛弃，不放弃。class 组件将我们带到了 OOP 的世界，OOP在编程界举足轻重，其思想是值得学习的。即便 class 组件已然成为一种历史产物，但他的存量巨大，依然需要去维护，去慢慢消化。</li>
<li><strong>未来</strong>：有可能弃用 class 组件及其生命周期。一方面，前端的世界本来变化就快。另一方面，class 组件确实存在一些弊端。随着 <code>Hooks</code>的不断成熟（或新的技术诞生）， 使得开发效率，代码可读性，维护性，性能等综合优势比较明显的时候，弃用是必然。</li>
</ul>
<p>所以：</p>
<ul>
<li>对于 React 老司机：拥抱Hooks，是拥抱变化。这个变化，是加法，是学习新的API，新的技能，新的思想。</li>
<li>对于 React 新手：拥抱Hooks，降低了学习门槛，可以更快入门。但是类组件也非常有必要去了解，理解。知己知彼，重构不殆。</li>
</ul>
<p>说了这么多，来，我们先来和这些 React Hooks 的 API 见个面：</p>
<p>基础 Hook</p>
<ul>
<li>useState</li>
<li>useEffect</li>
</ul>
<p>其他 Hook</p>
<ul>
<li>useContext</li>
<li>useReducer</li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
<li>… 还会增加</li>
</ul>
<p>是不是有点多，其实<code>useState</code> <code>useEffect</code> 这两个已经能应付多数场景了。Let‘s go👇</p>
<h1 id="useState-hook"><a href="#useState-hook" class="headerlink" title="useState hook"></a>useState hook</h1><ul>
<li>功能：在函数组件中用来进行状态管理，创建<strong>一些</strong>本地 state。</li>
<li>API：<code>const [currentState, setFunction] = useState(initialState);</code>。传一个参数，返回一个数组（包含两个值）- 三要素。</li>
<li><code>initialState</code>：参数，state 初始值。可以是任何类型： String，Object，Array，Bool，Number等。</li>
<li><code>currentState</code>：返回值，state 当前最新值。可自主命名。</li>
<li><code>setFunction</code>：返回值，state 更新函数。可自主命名。你可以在任意位置调用，来改变 state 的值。每次调用，会触发组件重新渲染（这也是返回值用 <code>const</code> 非 <code>let</code> 的原因）。</li>
<li>特点：可使用多个<code>useState</code>，彼此独立。而类组件，只有一个 state，每次<code>setState</code> 要进行浅合并（内部实现）。 </li>
</ul>
<p>这个API很简单，请看下面示例(24行代码)：</p>
<pre><code class="language-jsx">import React, { useState } from &#39;react&#39;;
function Form() {
  // ES6 解构
  const [name, setName] = useState(&#39;Mary&#39;);              // State 变量 1
  const [surname, setSurname] = useState(&#39;Poppins&#39;);     // State 变量 2
  const [width, setWidth] = useState(window.innerWidth); // State 变量 3

  function handleNameChange(e) {
    setName(e.target.value);
  }

  function handleSurnameChange(e) {
    setSurname(e.target.value);
  }

  return (
    &lt;&gt;
      &lt;input value={name} onChange={handleNameChange} /&gt;
      &lt;input value={surname} onChange={handleSurnameChange} /&gt;
      &lt;p&gt;Hello, {name} {surname}&lt;/p&gt;
      &lt;p&gt;Window width: {width}&lt;/p&gt;
    &lt;/&gt;
  );
}
export default Form;</code></pre>
<blockquote>
<p><code>&lt;&gt;&lt;/&gt;</code> 是 <code>React.Fragment</code> 的简写语法。</p>
</blockquote>
<p>用class类实现的话（31行代码），上述代码相当于：</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
class Form extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: &#39;Mary&#39;,
      surname:&#39;Poppins&#39;,
      width: window.innerWidth
    };
  }
  handleNameChange = (e) =&gt; {
    this.setState({ name: e.target.value });
  }

  handleSurnameChange = (e) =&gt; {
    this.setState({ surname: e.target.value });
  }

  render() {
    const { name, surname, width } = this.state
    return (
      &lt;&gt;
        &lt;input value={name} onChange={ this.handleNameChange } /&gt;
        &lt;input value={surname} onChange={ this.handleSurnameChange } /&gt;
        &lt;p&gt;Hello, {name} {surname}&lt;/p&gt;
        &lt;p&gt;Window width: {width}&lt;/p&gt;
      &lt;/&gt;
    );
  }
}
export default Form;</code></pre>
<h2 id="useState「粒度」问题"><a href="#useState「粒度」问题" class="headerlink" title="useState「粒度」问题"></a>useState「粒度」问题</h2><p>看到这里，对于写过class组件的我们，很容易产生一个疑问。 实际工作中，一个类组件的 <code>this.state</code> 中往往有十几项，用 <code>Hooks</code> 改写的话难道要写十几个 <code>useState</code> 么？</p>
<blockquote>
<p>对于这个常见问题，官方文档有<a href="http://react.html.cn/docs/hooks-faq.html#should-i-use-one-or-many-state-variables" target="_blank" rel="noopener">解答</a>。</p>
</blockquote>
<p>根据官方文档，总结下来，有几点：</p>
<ul>
<li>建议将 <code>state</code> 分割为多个 <code>useState</code>。粒度更细，更易于管理，更好复用。</li>
<li>可能一起改变的 <code>state</code> 可合并成一个<code>useState</code>（ 比如<code>Dom</code>元素的 <code>top</code> <code>left</code>）。</li>
<li>当 <code>state</code> 逻辑趋于复杂，建议使用 <code>reducer</code> 或 <code>Custom Hook</code> 管理（<strong>后面介绍</strong>）。</li>
</ul>
<p>当组件的 <code>state</code> 很多的时候，为了提高代码的可读性，也可以把逻辑相关的一些 <code>state</code> 合并为一个 <code>useState</code>（ 比如分页参数 ）。但这些 <code>state</code> 并不是一起改变的，所以当其中一个 <code>state</code> 改变，调用对应的 <code>setFunction</code> 的时候。你需要做<strong>对象合并</strong>(不合并就丢了)：</p>
<pre><code class="language-jsx">const [ pageData, setPageDate ] = useState({ pageSize: 20, current: 1, total:0, })

const onPageChange = current =&gt; {
  // 常规操作
  setPageDate( Object.assign( {}, pageData, { current } ) ）
  // 官方建议
  setPageDate(currentPageData =&gt; ({ ...currentPageData, current}));
}
</code></pre>
<blockquote>
<p>知识点：调用 useState 的更新函数时，可以传一个箭头函数，这个函数的参数是当前最新的 state， 返回值是要设置的 state 。</p>
</blockquote>
<h1 id="useEffect-hook"><a href="#useEffect-hook" class="headerlink" title="useEffect hook"></a>useEffect hook</h1><p>API 可抽象为: <code>useEffect(arrowFunction, [depsArr])</code> </p>
<ul>
<li><code>arrowFunction</code>: 必须。执行函数，执行副作用操作。它决定了做什么。</li>
<li><code>depsArr</code>: 非必须。一个依赖项数组。它决定了什么时候做（下面示例中介绍）。</li>
</ul>
<p>根据实际情况，可细分为三种：</p>
<pre><code class="language-jsx">// 第一种
// 最基础的，只有箭头函数。没有依赖项，所以组件每次渲染都会执行。
// 相当于  componentDidMount + componentDidUpdate
useEffect(() =&gt; { 
  //side-effect 
})
// 第二种
// 有依赖项，是一个空数组，因为它永远不会变，所以只会首次执行。
// 相当于 componentDidMount
useEffect(() =&gt; { 
  //side-effect 
}, [])
// 第三种
// 有第二个参数，且非空数组。首次渲染会执行。重新渲染时，只有当依赖项的值改变了才会执行。
useEffect(() =&gt; { 
  //side-effect 
}, [...state])</code></pre>
<blockquote>
<p>相当是 <code>==</code> 而非  <code>===</code>。</p>
</blockquote>
<p>总结下来：</p>
<ul>
<li>功能：管理 React 函数组件的副作用，赋予生命周期能力。</li>
<li>怎么管：组件每次渲染到屏幕之后，根据依赖项的情况判断是否调用执行函数。</li>
<li>二要素：执行函数，依赖项。</li>
<li>清理机制：你可以在执行函数中返回另一个函数-<strong>清理函数</strong>，清理函数会在组件卸载的时候，会在组件重新渲染，且useEffect的依赖项值改变的时候调用。起到了 class 组件中<code>componentWillUnmount</code>的作用, 后续会在场景实例中介绍。</li>
<li>使用上：和 <code>useState</code> 一样，可使用多个。建议一个副作用对应一个 <code>useEffect</code>。</li>
</ul>
<p>根据副作用是否需要清理，<code>useEffect</code> 可分为 <strong>不需要清理的</strong> <code>useEffect</code>，和 <strong>需要清理的</strong> <code>useEffect</code>。下面，我们分别通过一些示例来直观的感受一下。</p>
<h2 id="不需要清理的场景"><a href="#不需要清理的场景" class="headerlink" title="不需要清理的场景"></a>不需要清理的场景</h2><p>有时，我们希望在 React 渲染页面之后运行一些额外的代码。 网络请求、手动修改DOM 和日志记录都是不需要清理 副作用 的常见例子。可以这么说，我们运行它们，然后可以马上忘记它们。</p>
<p>就拿官网的例子来说，一个计数器组件，计数发生改变以后，更新 <code>Dom</code> 标题。类组件是这样实现的：</p>
<pre><code class="language-jsx">
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`; 
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>用 <code>useEffect</code> 实现如下：</p>
<pre><code class="language-jsx">import { useState, useEffect } from &#39;react&#39;;

function Example() {
  const [count, setCount] = useState(0);
  // 第一种useEffect
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<blockquote>
<p>规则：每一次渲染后都去运行所有的 effects 可能并不高效。（并且在某些场景下，它可能会导致无限循环。）– Dan Abramov</p>
</blockquote>
<p>这条规则告诉我们，在写无依赖的 <code>useEffect</code> 的时候，多一点思考。上面代码现在看没有问题，后续增加了其他 state 和功能以后，这个 <code>useEffect</code> 就不高效了，可改写为：</p>
<pre><code class="language-jsx">import { useState, useEffect } from &#39;react&#39;;

function Example() {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  },[count]);// 看这里
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h2 id="需要清理的场景"><a href="#需要清理的场景" class="headerlink" title="需要清理的场景"></a>需要清理的场景</h2><p>有一些场景，我们需要做副作用的清理，保证引起不必要内存泄漏。比如，手动绑定事件，订阅，定时器等。</p>
<p>以定时器为例，让我们来实现一个秒表组件。这是一个学习和理解 <code>useEffect</code> 非常有意思的例子。</p>
<p>这里，我们直接用 <code>Hooks</code> 来实现：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;

function App() {
  // 秒表开关
  const [isOn, setIsOn] = useState(false);
  // 计数
  const [timer, setTimer] = useState(0);

  useEffect(() =&gt; {
    let interval;
    //开关打开的时候才执行
    if (isOn) {
      // 通过定时器增加计数
      interval = setInterval(
        () =&gt; setTimer(timer + 1),
        1000,
      );
    }
    // 需要清除定时器
    // 不清理会如何？codesandbox中尝试，页面直接卡死
    return () =&gt; clearInterval(interval);
  }); 

  return (
    &lt;&gt;
      &lt;p&gt;{timer}&lt;/p&gt;

      {!isOn &amp;&amp; (
        &lt;button type=&quot;button&quot; onClick={() =&gt; setIsOn(true)}&gt;
          Start
        &lt;/button&gt;
      )}

      {isOn &amp;&amp; (
        &lt;button type=&quot;button&quot; onClick={() =&gt; setIsOn(false)}&gt;
          Stop
        &lt;/button&gt;
      )}
    &lt;/&gt;
  );
}

export default App;
</code></pre>
<p>运行代码，你会发现，秒表效果实现了。但是，同样的错误，故意犯了2次：既然用了定时器，为什么还要 effect 每次执行。让我们来分析下上面代码的执行流程：</p>
<ul>
<li>首次加载：effect执行。因为<code>isOn</code>是<code>false</code>，所以 定时器 没有创建。</li>
<li>点击 <code>start</code> 打开开关(<code>setIsOn(true)</code>)。<code>isOn</code> 这个 state 改变，组件重新渲染。effect再次执行，此时创建定时器。</li>
<li>定时器生效，1秒后执行 <code>setTimer(timer + 1)</code>，<code>timer</code> 这个 state 改变，触发组件重新渲染（定时器也会清除）。effect再次执行，重新创建定时器。</li>
<li>一直重复上面步骤。</li>
</ul>
<p>有没有发现问题，定时器在循环创建，清除。用什么定时器，用延时器（<code>setTimeout</code>）好了。最糟糕的是，如果你忘了清除定时器，不光计数会错乱，页面也会奔溃。</p>
<p>怎么优化呢？同样的解决方案。很显然，我们的 effect 依赖 <code>isOn</code> 这个 state，所以我们可以把它作为 <code>useEffect</code> 的依赖项：</p>
<pre><code class="language-jsx">//...
useEffect(() =&gt; {
  let interval;
  if (isOn) {
    interval = setInterval(
      () =&gt; setTimer(timer + 1),
      1000,
    );
  }
  return () =&gt; clearInterval(interval);
  },[isOn]); // 看这里！！！！！！！！！
// ...</code></pre>
<p>这样是不是就ok了？拷贝代码到 codeSandBox 验证一下。what？点击 <code>start</code> ，计数器增加到 <code>1</code> 以后不动了！。<br>页面卡死了么？我们再分析一下流程：</p>
<ul>
<li>首次加载：effect 执行。因为 <code>isOn</code> 是 <code>false</code>，所以定时器没有创建。</li>
<li>点击 <code>start</code> 打开开关。<code>isOn</code> 改变，组件重新渲染。effect 的依赖项 <code>isOn</code> 也改变了，effect 再次执行。此时，<code>isOn</code> 是 <code>true</code>，定时器创建。</li>
<li>定时器生效，1秒后执行 <code>setTimer(timer + 1)</code>，<code>timer</code> 改变，触发组件重新渲染。注意了，此时 effect 的依赖项<code>isOn</code> 并没有改变，所以定时器在重新渲染后不会清除，effect 也不会再次执行。看上去这就是我们想要的，定时器还在工作。那为什么一直是 <code>1</code> 。</li>
</ul>
<blockquote>
<p>规则：React 约定 Effect 拿到的总是定义它的那次渲染中的 <code>props</code> 和 <code>state</code>。– Dan Abramov<br>我也注意到，上面的代码在 codeSandBox 中执行会看到一条告警信息：<code>React Hook useEffect has a missing dependency: &#39;timer&#39;. Either include it or remove the dependency array. You can also do a functional update &#39;setTimer(t =&gt; ...)&#39; if you only need &#39;timer&#39; in the &#39;setTimer&#39; call. (react-hooks/exhaustive-deps) -- eslint</code></p>
</blockquote>
<p>疑惑解开。这其实就是js常见的<strong>闭包</strong>，你也可以理解为这是 <code>useEffect</code> 的约定。这个非常非常重要，划重点。<br>上面的告警信息，已经明确的告诉了我们如何解决这个问题。</p>
<p>办法一： 增加依赖项 <code>timer</code> ，这样<code>timer</code> 改变也会触发重新渲染，然后 effect 都、会再次执行，定时器会拿到新的 <code>timer</code>。</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
  let interval;
  if (isOn) {
    interval = setInterval(
      () =&gt; setTimer(timer + 1),
      1000,
    );
  }
  return () =&gt; clearInterval(interval);
  },[isOn,timer]); // 看这里！！！！！！！！！</code></pre>
<blockquote>
<p>规则： 我鼓励你诚实地告知 effect 依赖作为一条硬性规则，并且要列出所有依赖。– Dan Abramov</p>
</blockquote>
<p>办法二：采用 <strong>更新函数</strong> 来改变 state。前面提到过，<code>useState</code> 的 <code>setFunction</code>中 ，可以传一个箭头函数（更新函数），这个函数的参数是当前最新的 <code>state</code>， 返回值是要设置的 <code>state</code>。</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
  let interval;
  if (isOn) {
    interval = setInterval(
      () =&gt; setTimer(val =&gt; val + 1),// 看这里！！！！
      1000,
    );
  }
  return () =&gt; clearInterval(interval);
  },[isOn]); // 看这里</code></pre>
<p>发现没有，使用更新函数后，我们相当于去除了对 <code>timer</code> 的依赖。</p>
<blockquote>
<p>规则： 当我们不想增加更多依赖，可以尝试修改 effect 使得依赖更少。– Dan Abramov</p>
</blockquote>
<p>所以 方法二 优于 方法一。</p>
<p>我们来看一个实际项目中常见的副作用 - Ajax请求。在class 组件中，我们经常会用生命周期 <code>componentDidMount</code>来处理一些初始化的 Ajax 数据请求，现在我们用 useEffect 来实现。</p>
<p>比如用 <code>axios</code> 请求一个列表：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
import axios from &#39;axios&#39;;
function App() {
  const [data, setData] = useState([]);
  useEffect(() =&gt; {
    // 更优雅的方式
    const fetchData = async () =&gt; {
      const result = await axios(
        &#39;https://hn.algolia.com/api/v1/search?query=redux&#39;,
      );
      setData(result.data);
    };
    fetchData();
  }, []);
  return (
    &lt;ul&gt;
      {data.hits.map(item =&gt; (
        &lt;li key={item.objectID}&gt;
          &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
export default App;</code></pre>
<blockquote>
<p>规则：useEffect 不能接收 async 作为执行函数。useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise。<br>useEffect 调用的函数如果依赖 state 或者 props。最好在执行函数中定义。这样依赖容易追踪。</p>
</blockquote>
<p>useEffect 的使用，看起来很简单。但是要做到不滥用，正确使用也不是那么容易。主要在使用之前要多一些思考。</p>
<h1 id="Custom-Hooks"><a href="#Custom-Hooks" class="headerlink" title="Custom Hooks"></a>Custom Hooks</h1><p>终于讲到它了， 前面已经提到过。它并不是 <code>React hooks</code> 的 API，而是<strong>自定义 hook</strong>。顾名思义，React允许你构建自己的 <code>hooks</code>。在学习完前面两个最受欢迎的 <code>hooks</code> 以后，你完全具备了实现自定义 hooks 的能力。</p>
<blockquote>
<p>官网定义： 自定义 Hook 是一个 JavaScript 函数，其名称以 ”use” 开头，可以调用其他 Hook。</p>
</blockquote>
<p>为什么需要Custom Hooks？</p>
<ul>
<li><code>useState</code> 解决了函数组件无状态的问题。</li>
<li><code>useEffect</code> 实现了副作用管理，生命周期的功能。</li>
<li><code>Custom Hooks</code> 将解决有状态（stateful）逻辑共享的问题（相当于类组件中Hoc的功能）。👇</li>
</ul>
<p>我们来到一个实际场景。如今 <code>HTML5</code> 移动应用或 <code>Web app</code> 中越来越普遍的使用了离线浏览技术，所以用 JS 检测浏览器在线/离线状态非常常见。首先，我们用 <code>React Hooks</code> 来实现这个功能：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
function App() {
  const [isOffline, setIsOffline] = useState(window.navigator.onLine);
  // 离线事件处理方法
  function onOffline() {
    setIsOffline(true);
  }
  // 在线事件处理方法
  function onOnline() {
    setIsOffline(false);
  }
  useEffect(() =&gt; {
    // 事件监听
    window.addEventListener(&#39;offline&#39;, onOffline);
    window.addEventListener(&#39;online&#39;, onOnline);
    // 清理函数
    return () =&gt; {
      window.removeEventListener(&#39;offline&#39;, onOffline);
      window.removeEventListener(&#39;online&#39;, onOnline);
    };
  }, []); // 只需要首次执行
  return (
    &lt;&gt;
       { 
         isOffline
         ? &lt;div&gt;网断已断开 ...&lt;/div&gt;
         : &lt;div&gt;网络已连接 ...&lt;/div&gt;
       }
    &lt;/&gt;
  )
}
export default App;</code></pre>
<blockquote>
<p>无论浏览器是否在线，<code>navigator.onLine</code> 属性都会提供一个布尔值。 如果浏览器在线，则设置为 <code>true</code> ，否则设置为 <code>false</code> 。</p>
</blockquote>
<p>OK，我们实现了一个很不错的功能。很明显，这个功能是可复用的，应该共享的。<br>我们把功能逻辑提取出来，把它封装成一个 <code>Custom hook</code> 就可以了：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
// 自定义 hook
function useOffline() {
  const [isOffline, setIsOffline] = useState(window.navigator.onLine);
  function onOffline() {
    setIsOffline(true);
  }
  function onOnline() {
    setIsOffline(false);
  }
  useEffect(() =&gt; {
    window.addEventListener(&#39;offline&#39;, onOffline);
    window.addEventListener(&#39;online&#39;, onOnline);
    return () =&gt; {
      window.removeEventListener(&#39;offline&#39;, onOffline);
      window.removeEventListener(&#39;online&#39;, onOnline);
    };
  }, []);
  return isOffline; // 只暴露一个 state
}

// 函数组件
function App() {
  const isOffline = useOffline();
  return (
    &lt;&gt;
       { 
         isOffline
         ? &lt;div&gt;网断已断开 ...&lt;/div&gt;
         : &lt;div&gt;网络已连接 ...&lt;/div&gt;
       }
    &lt;/&gt;
  )
}
export default App;</code></pre>
<p>现在，你应该对 <code>custom hooks</code> 有了一个直观的认识：</p>
<ul>
<li>一个函数。</li>
<li>一个use开头的函数。</li>
<li>一个使用 React hooks 封装的，处理副作用的函数。</li>
<li>一个在函数组件中引入简单，不需要调整组件结构的函数。</li>
</ul>
<p>从重构层面来说，就是把组件中的一些 <code>hooks</code> 抽离到一个函数中，再使用这个函数。这个函数就是 <code>React custom hooks</code>。</p>
<p>既然是函数，那肯定可以传参。我们来看一个常见场景：很多时候，为了用户体验，页面会本地存储用户数据，然后在页面返回的时候自动填充。现在，我们用一个传参的 <code>custom hooks</code> 来实现该场景：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
// 自定义 hook,接收一个 localStorageKey 参数
const useStateWithLocalStorage = localStorageKey =&gt; {
  const [value, setValue] = useState(
    localStorage.getItem(localStorageKey) || &#39;&#39;,
  );
  useEffect(() =&gt; {
    localStorage.setItem(localStorageKey, value);
  }, [value]);
  return [value, setValue];
};
const App = () =&gt; {
  // 使用带参数的 自定义 hooks
  const [value, setValue] = useStateWithLocalStorage(
    &#39;myValueInLocalStorage&#39;,
  );
  const onChange = event =&gt; setValue(event.target.value);
  return (
    &lt;div&gt;
      &lt;input value={value} type=&quot;text&quot; onChange={onChange} /&gt;
      &lt;p&gt;{value}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
<p>书写 custom hooks 需要注意些什么呢？看官网怎么说：</p>
<ul>
<li>自定义 Hooks 是一种惯例，它自然地遵循 Hooks 设计的约定。即遵循所有你用到的 <code>Hooks</code>  的规则。</li>
<li>请使用 use 开头。这个习惯非常重要。如果没有它，我们就不能自动检查该 Hook 是否违反了 Hooks 的规则，因为我们无法判断某个函数是否包含对其内部 Hooks 的调用。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>顺序调用：每个组件都有一个 “内存单元” 的内部列表。它们只是 <code>JavaScript</code> 对象，你可以想象它是一个数组（实际上是一个单向链表），我们可以在其中放置一些数据。当调用 <code>useState()</code> 这样的 <code>Hook</code> 时，它读取当前单元格(或在第一次呈现时初始化它)，然后将指针移动到下一个单元格。这就是多个 <code>useState()</code> 调用各自获取独立本地状态的方式。</p>
<ul>
<li><code>Hooks</code> 的状态值都被挂载在组件实例对象 <code>FiberNode</code> 的属性中。</li>
<li><code>Hooks</code> 是用链表来保存状态的，属性保存的实际上是这个链表的头指针。</li>
<li><code>useState / useReducer</code> 的信息保存在 <code>FiberNode.memoizedState</code>属性.</li>
<li><code>useEffect</code> 也是以链表的形式挂载在 <code>FiberNode.updateQueue</code> 属性中。</li>
</ul>
<pre><code class="language-js">// react-reconciler/src/ReactFiberHooks.js
export type Hook = {
  memoizedState: any, // 最新的状态值
  baseState: any, // 初始状态值，如`useState(0)`，则初始值为0
  baseUpdate: Update&lt;any, any&gt; | null,
  queue: UpdateQueue&lt;any, any&gt; | null, // 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针
  next: Hook | null,  // 指向下一个链表节点
};

 const effect: Effect = {
    tag, // 用来标识依赖项有没有变动
    create, // 用户使用useEffect传入的函数体
    destroy, // 上述函数体执行后生成的用来清除副作用的函数
    deps, // 依赖项列表
    next: (null: any),
};</code></pre>
<p>想更详细的理解，请点击：<br><a href="https://juejin.im/post/5bebd1bbe51d4561ce39a23b" target="_blank" rel="noopener">React Hooks 揭秘</a><br><a href="https://segmentfault.com/a/1190000023041842" target="_blank" rel="noopener">React Hooks 原理剖析</a></p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>需要开发者遵从许多规则。理解并合理运用这些规则，能写出优雅的，可读性高的，性能好的代码。反之，很容易出现死循环，数据重复请求等问题。最让人担心的是性能，很多时候业务功能实现了，但是其实存在很多不必要的开销。</p>
<hr>
<p><strong>参考资料</strong><br><a href="http://react.html.cn/docs/hooks-intro.html" target="_blank" rel="noopener">官网-Hooks</a><br><a href="https://www.robinwieruch.de/react-hooks" target="_blank" rel="noopener">What Are React Hooks</a><br><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d#heading-17" target="_blank" rel="noopener">React Hooks 详解 + 项目实战</a></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/hooks/" rel="tag"># hooks</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/03/11/%E5%85%B3%E4%BA%8Efetch/" rel="next" title="关于fetch">
                <i class="fa fa-chevron-left"></i> 关于fetch
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/03/30/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%BA%8C%EF%BC%89-Refs/" rel="prev" title="拥抱React-Hooks（二）- useRef">
                拥抱React-Hooks（二）- useRef <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sgj.jpeg"
                alt="祁连" />
            
              <p class="site-author-name" itemprop="name">祁连</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                大牛👇
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://overreacted.io/zh-hans/" title="Dan Abramov" target="_blank">Dan Abramov</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qianduan.group/" title="寸志" target="_blank">寸志</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.robinwieruch.de/blog" title="Robin Wieruch" target="_blank">Robin Wieruch</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#React-Hooks-起源"><span class="nav-number">1.</span> <span class="nav-text">React Hooks 起源</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#类组件被诟病"><span class="nav-number">2.</span> <span class="nav-text">类组件被诟病</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Hooks-优越性"><span class="nav-number">3.</span> <span class="nav-text">Hooks 优越性</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#抛弃类组件？"><span class="nav-number">4.</span> <span class="nav-text">抛弃类组件？</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#useState-hook"><span class="nav-number">5.</span> <span class="nav-text">useState hook</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#useState「粒度」问题"><span class="nav-number">5.1.</span> <span class="nav-text">useState「粒度」问题</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#useEffect-hook"><span class="nav-number">6.</span> <span class="nav-text">useEffect hook</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#不需要清理的场景"><span class="nav-number">6.1.</span> <span class="nav-text">不需要清理的场景</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#需要清理的场景"><span class="nav-number">6.2.</span> <span class="nav-text">需要清理的场景</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Custom-Hooks"><span class="nav-number">7.</span> <span class="nav-text">Custom Hooks</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#原理"><span class="nav-number">8.</span> <span class="nav-text">原理</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#缺点"><span class="nav-number">9.</span> <span class="nav-text">缺点</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">祁连</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<script src="/js/prism/prism.js" async></script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
