<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Live and learn">
<meta property="og:url" content="http://www.mala520.life/page/2/index.html">
<meta property="og:site_name" content="Live and learn">
<meta property="article:author" content="祁连">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mala520.life/page/2/"/>





<link rel="stylesheet" href="/js/prism/prism.css">

  <title>Live and learn</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Live and learn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%89%8D%E7%AB%AF%E6%A8%A1%E5%9D%97%E5%8C%96/" itemprop="url">前端模块化之路</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:12:28+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<ul>
<li>随着<code>CPU</code>，内存，以及浏览器内核性能不断提升，前端在软件开发中扮演越来越重要的角色。</li>
<li>前端框架层出不穷，逻辑日益复杂，代码量日益庞大。</li>
<li>前端也需要一种有效组织和管理大型应用系统代码的方式。</li>
<li>前端开始探索自己的模块化开发之路。</li>
</ul>
<h1 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h1><hr>
<ul>
<li>模块化是指解决一个复杂问题时自顶向下逐层把系统<strong>分解</strong>为更好的<strong>可管理模块</strong>的方式。</li>
<li>每个模块完成一个特定的子功能，<strong>封装细节</strong>，提供使用<strong>接口</strong>，彼此之间可<strong>相互依赖，但互不影响</strong>。</li>
<li>所有的模块可以按某种方法<strong>组装</strong>起来，成为一个整体，完成整个系统所要求的功能。</li>
<li>模块化使代码耦合度降低，最大化的设计重用，以最少的模块，更快速的满足更多的个性化需要。</li>
</ul>
<p>科学的模块化肯定要具备以下几点：</p>
<ul>
<li>分解成模块，每个模块实现特定子功能。</li>
<li>模块封装具体细节，提供使用接口。</li>
<li>模块间互不影响。</li>
<li>模块间依赖明确，可连接。</li>
</ul>
<h1 id="模块化的好处"><a href="#模块化的好处" class="headerlink" title="模块化的好处"></a>模块化的好处</h1><ul>
<li>避免变量名冲突（全局变量污染）</li>
<li>更好的分离代码，可按需加载，提升性能</li>
<li>可维护性更高</li>
<li>可复用性更高</li>
<li>…</li>
</ul>
<h1 id="前端模块化探索"><a href="#前端模块化探索" class="headerlink" title="前端模块化探索"></a>前端模块化探索</h1><hr>
<ul>
<li>在<code>ES6</code>出现之前，<code>JS</code>先天是不具备模块化能力的。</li>
<li>我们需要基于<code>JS</code>的原生土壤（<code>Object</code>，<code>Function</code>，<code>Cursor</code>…）去抽象和封装。</li>
<li>JS是面向函数编程的。若无任何封装，基本遍地的全局函数。最突出的问题便是全局命名空间污染，命名冲突。</li>
</ul>
<p>那么，加一个命名空间好了。</p>
<h2 id="命名空间模式-对象封装"><a href="#命名空间模式-对象封装" class="headerlink" title="命名空间模式-对象封装"></a>命名空间模式-对象封装</h2><p>我们把模块封装成一个对象，这个对象（保证命名唯一性）就相当于一个命名空间。</p>
<p>比如，我们用 <code>Object</code> 来封装一个我们常用的日期处理函数库：</p>
<pre><code class="language-js">/**************定义模块**********/
var MyDateUtils = {
  defaultFmt:&#39;yyyy-MM-dd&#39;,
  // 格式化日期格式
  dateFormat: function(date, _fmt) {
    var fmt = _fmt || this.defaultFmt;
    var o = {
      &#39;M+&#39;: date.getMonth() + 1, // 月份
      &#39;d+&#39;: date.getDate(), // 日
      &#39;h+&#39;: date.getHours(), // 小时
      &#39;m+&#39;: date.getMinutes(), // 分
      &#39;s+&#39;: date.getSeconds(), // 秒
      &#39;q+&#39;: Math.floor((date.getMonth() + 3) / 3), // 季度
      S: date.getMilliseconds(), // 毫秒
    };
    if (/(y+)/.test(fmt)) { fmt = fmt.replace(RegExp.$1, (`${date.getFullYear()}`).substr(4 - RegExp.$1.length)); }
    for (var k in o) {
      if (new RegExp(`(${k})`).test(fmt)) { fmt = fmt.replace(RegExp.$1, (RegExp.$1.length === 1) ? (o[k]) : ((`00${o[k]}`).substr((`${o[k]}`).length))); }
    }
    return fmt;
  },
  // 获取当前日期
  getDateNow(fmt) {
    return this.dateFormat(new Date(), fmt);
  },
  //其他API略...
}</code></pre>
<ul>
<li>优点：模块增加了命名空间，大大降低了命名冲突的情况。</li>
<li>缺点：外部可以随意修改对象内部成员。这种不可控的状态非常要命，属于很大的安全漏洞。</li>
</ul>
<pre><code class="language-js">// A同学正常使用
MyDateUtils.getDateNow(); 
// B同学修改内部成员为自己场景常用的格式，就会影响使用默认格式的A同学
MyDateUtils.defaultFmt = &#39;MM-dd&#39;; </code></pre>
<p>模块化满足情况：</p>
<ul>
<li>分解成模块，每个模块实现特定子功能。 ✅ 对象即模块</li>
<li>模块封装具体细节，提供使用接口。 ❌ 全暴露，可读可写</li>
<li>模块间互不影响。 ❌ 可随意篡改其他模块</li>
<li>模块间依赖明确，可连接。 ❌ how?</li>
</ul>
<h2 id="函数封装"><a href="#函数封装" class="headerlink" title="函数封装"></a>函数封装</h2><p>对象封装明显不靠谱，还是得靠JS的一等公民：<code>Function</code>。我们知道，<code>JS</code>函数有自己独立的作用域。</p>
<p>还是上面的日期函数库，我们尝试使用<code>Function</code>来封装，最大程度符合模块化特性可能是这样:</p>
<pre><code class="language-js">/**************定义模块**********/
var MyDateUtils = function (defaultFmt){
  this.defaultFmt = defaultFmt || &#39;yyyy-MM-dd&#39;;
};
MyDateUtils.prototype.dateFormat = function(date, fmt) {
  // 略...(同上)
};
MyDateUtils.prototype.getDateNow = function(fmt) {
  return this.dateFormat(new Date(), fmt);
}

/**************使用模块**********/
var newDateUtils = new MyDateUtils();
var today = newDateUtils.getDateNow();</code></pre>
<p>也可以使用<code>ES6</code>-<code>class</code>语法糖，这么定义：</p>
<pre><code class="language-js">/**************定义模块**********/
class MyDateUtils = {
  constructor(defaultFmt){
    this.defaultFmt = defaultFmt || &#39;yyyy-MM-dd&#39;;
  };

  dateFormat(date, fmt) {
    // 略...(同上)
  };

  getDateNow (fmt) {
    return this.dateFormat(new Date(), fmt);
  }
}

/**************使用模块**********/
var newDateUtils = new MyDateUtils();
var today = newDateUtils.getDateNow();</code></pre>
<p>再来看看模块化满足情况：</p>
<ul>
<li>分解成模块，每个模块实现特定子功能。 ✅ 函数对象即模块</li>
<li>模块封装具体细节，提供使用接口。 ❌ 所有方法可访问，其实模块中往往存在很多子方法是不需要外部访问的，也毫无意义</li>
<li>模块间互不影响。 ✅ 所有方法定义在 prototype 属性上才能防止其他模块复写。</li>
<li>模块间依赖明确，可连接。 ❌ no way!</li>
</ul>
<p>如何才能只暴露部分接口，还能和外界取得联系？</p>
<p><strong>闭包</strong></p>
<ul>
<li>闭包 就是能够读取其他函数内部变量的函数。</li>
<li>由于在<code>Javascript</code>语言中，只有函数内部的子函数才能读取局部变量，因此可以把闭包简单理解成”定义在一个函数内部的函数”。</li>
<li>所以在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</li>
</ul>
<h2 id="使用闭包-IIFE（立即执行函数）"><a href="#使用闭包-IIFE（立即执行函数）" class="headerlink" title="使用闭包-IIFE（立即执行函数）"></a>使用闭包-IIFE（立即执行函数）</h2><p>我们使用<code>IIFE</code>来封装前面的模块：</p>
<pre><code class="language-js">/**************定义模块**********/
var MyDateUtils = (function (){
  let defaultFmt = &#39;yyyy-MM-dd&#39;;

  function dateFormat(date, _fmt) {
    // 略...(同上)
  }
  // 获取当前日期
  function getDateNow(fmt) {
    return this.dateFormat(new Date(), fmt);
  }

  return { 
    getDateNow: getDateNow;
  }
})();</code></pre>
<p>或者（流行方式）：</p>
<pre><code class="language-js">/**************定义模块**********/
;(function (){
  let defaultFmt = &#39;yyyy-MM-dd&#39;;

  function dateFormat(date, _fmt) {
    // 略...(同上)
  }
  // 获取当前日期
  function getDateNow(fmt) {
    return this.dateFormat(new Date(), fmt);
  }

  window.MyDateUtils = { 
    getDateNow: getDateNow;
  }
})();</code></pre>
<pre><code class="language-js">/**************使用模块**********/
MyDateUtils.getDateNow(); // 可以访问
MyDateUtils.dateFormat(); // 不可以访问</code></pre>
<p>再来看看模块化满足情况：</p>
<ul>
<li>分解成模块，每个模块实现特定子功能。 ✅ </li>
<li>模块封装具体细节，提供使用接口。 ✅</li>
<li>模块间互不影响。 ✅ </li>
<li>模块间依赖明确，可连接。 ❌ </li>
</ul>
<p>问题：那么一个模块依赖另一个模块怎么办?</p>
<p>办法：把依赖的模块作为立即执行函数的参数即可。</p>
<pre><code class="language-js">/**************定义模块**********/
;(function (_A,_B){

  // 略...(同上) 这里便可以使用 ModuleA 和 ModuleB 暴露的方法

  window.MyDateUtils = { 
    getDateNow: getDateNow;
  }
})(ModuleA,ModuleB);</code></pre>
<p>上面模块化方案也是后来一系列模块化框架和规范的基石。</p>
<h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><hr>
<p>前面都是原生的模块化探索。在此基础上，衍生了一系列模块化的库和规范：</p>
<ul>
<li><code>commonJS</code>：服务端<code>nodeJS</code>引入，同步加载。</li>
<li><code>requireJS</code>：遵循 <code>AMD</code> 规范</li>
<li><code>seaJS</code>： 遵循 <code>CMD</code> 规范</li>
<li><code>ES6</code> 模块化</li>
</ul>
<h2 id="CommonJs"><a href="#CommonJs" class="headerlink" title="CommonJs"></a>CommonJs</h2><p>1）介绍</p>
<ul>
<li>由服务端 <code>nodeJS</code> 引入并发扬光大。</li>
<li>同步加载，适用于服务端。</li>
<li>客户端（浏览器端）<code>JS</code>一般是异步加载，不适用。</li>
<li>模块加载的顺序，按照其在代码中出现的顺序。</li>
<li>服务器端<code>Node</code>，模块的加载是运行时同步加载的；浏览器端<code>Node</code>，模块需要提前编译打包处理。</li>
</ul>
<p>2）语法</p>
<ul>
<li>定义模块：一个文件就是一个模块，拥有自己独立的作用域。</li>
<li>暴露模块：<code>module.exports = value</code>或<code>exports.xxx = value</code>。</li>
<li>引入模块：<code>require(xxx)</code>,如果是第三方模块，<code>xxx</code>为模块名；如果是自定义模块，<code>xxx</code>为模块文件路径。<code>require</code> 返回该模块的 <code>exports</code>对象。</li>
</ul>
<pre><code class="language-js">const webpack = require(&#39;webpack&#39;)
const path = require(&#39;path&#39;)

module.exports = env =&gt; {
  let config = { };
  //...
  return config;
}</code></pre>
<h2 id="RequireJS-AMD"><a href="#RequireJS-AMD" class="headerlink" title="RequireJS(AMD)"></a>RequireJS(AMD)</h2><p>1) 介绍</p>
<ul>
<li><code>AMD</code> 即<code>Asynchronous Module Definition</code>，异步模块定义的意思。它是一个在浏览器端模块化开发的规范。</li>
<li>浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用<code>AMD</code>规范。</li>
<li><code>JS</code>原生不支持<code>AMD</code>规范，需要对应的工具库来做这件事。<code>requireJS</code>诞生，用于客户端的模块管理。</li>
</ul>
<p><code>requireJS</code> 主要解决两个问题：</p>
<ul>
<li>多个<code>js</code>文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器</li>
<li><code>js</code>加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长</li>
</ul>
<p>2）语法</p>
<ul>
<li>定义模块：<code>define(id?, [dependencies]?, factory)</code>;<ul>
<li><code>id</code>: 可选，用来定义模块的标识，一般使用默认的脚本文件名（去掉拓展名）;</li>
<li><code>dependencies</code>: 可选，如果有依赖，列出依赖的模块数组; </li>
<li><code>factory</code>：工厂方法 如果是对象 则表示模块的返回。</li>
</ul>
</li>
<li>暴露模块：通过在上面的 <code>factory</code> 工厂方法中 <code>return value</code>。</li>
<li>引入模块：<code>require([dependencies], function(){})</code>;</li>
</ul>
<pre><code class="language-js">//定义没有依赖的模块
define(function(){

   return { ...模块对象/方法 }
})

define({ ...模块对象/方法 }) //模块是对象，直接暴露整个模块对象写法。</code></pre>
<pre><code class="language-js">//定义有依赖的模块
define([&#39;module1&#39;, &#39;module2&#39;], function(m1, m2){
   return { ...模块对象/方法 }
})</code></pre>
<pre><code class="language-js">//引入模块
require([&#39;module1&#39;, &#39;module2&#39;], function(m1, m2){
   // 使用m1/m2
})</code></pre>
<blockquote>
<p><code>require()</code>函数在加载依赖的函数的时候是异步加载的，这样浏览器不会失去响应，它指定的回调函数，只有前面的模块都加载成功后，才会运行，解决了依赖性的问题。</p>
</blockquote>
<h2 id="SeaJs-CMD"><a href="#SeaJs-CMD" class="headerlink" title="SeaJs(CMD)"></a>SeaJs(CMD)</h2><p>1) 介绍 </p>
<ul>
<li><code>CMD</code> 即<code>Common Module Definition</code>，通用模块定义的意思。它是一个在国内发展起来的模块化开发规范。</li>
<li><code>seaJS</code>是 <code>CMD</code> 规范在浏览器端的实现。 </li>
<li><code>seaJS</code> 要解决的问题和<code>requireJS</code>一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</li>
</ul>
<p>2）语法</p>
<ul>
<li>定义模块：<code>define(function(require, exports, module) {...})</code>。只有一个工厂方法。</li>
<li>暴露模块：使用上面的工厂方法的<code>exports</code> 对象 <code>exports.doSomething = ...</code>。</li>
<li>引入模块：使用上面的工厂方法的<code>require</code> 对象。还提供了异步引入的方法<code>require.async</code>.</li>
</ul>
<blockquote>
<p>定义模块时其实也可以指定id和依赖，不常用，不推荐：<code>define(id?, dependencies?, function(require, exports, module) {...})</code></p>
</blockquote>
<pre><code class="language-js">// 定义模块moduleA
define(function(require, exports, module) {
  function fn1 () {
    //...
  }
  function fn2 () {
    //...
  }
  // 暴露模块内容
  export.fn1 = fn1;
});</code></pre>
<pre><code class="language-js">// 引入模块(同步)
define(function(require, exports, module) {
   //引入依赖模块(同步)
  var moduleA = require(&#39;./moduleA&#39;);
  moduleA.fn1();
});

// 引入模块(异步)
define(function(require, exports, module) {
  require.async(&#39;./moduleA&#39;, function (mA) {
    mA.fn1()
  })
});</code></pre>
<h3 id="AMD与CMD区别"><a href="#AMD与CMD区别" class="headerlink" title="AMD与CMD区别"></a>AMD与CMD区别</h3><p>注意，<code>AMD</code> 和<code>CMD</code>加载模块都是异步的。他们最大的区别是对依赖模块的<strong>执行时机</strong>处理不同，注意不是加载的时机。</p>
<ul>
<li><p><code>AMD</code>依赖前置，<code>js</code>可以方便知道依赖模块是谁，立即加载，加载模块完成后就会<strong>执行</strong>该模块，所有模块都加载执行完后会进入<code>require</code>的回调函数，执行主逻辑，这样的效果就是依赖模块的执行顺序和书写顺序不一定一致，看网络速度，哪个先下载下来，哪个先执行，但是主逻辑一定在所有依赖加载完成后才执行。</p>
</li>
<li><p><code>CMD</code>就近依赖，需要使用把模块变为字符串解析一遍才知道依赖了那些模块（这也是很多人诟病<code>CMD</code>的一点，牺牲性能来带来开发的便利性，实际上解析模块用的时间短到可以忽略）。<code>CMD</code>加载完某个依赖模块后并不执行，只是下载而已，在所有依赖模块加载完成后进入主逻辑，遇到require语句的时候才执行对应的模块，这样模块的执行顺序和书写顺序是完全一致的。</p>
</li>
</ul>
<blockquote>
<p>两者各有优劣，很多人说 <code>AMD</code>用户体验好，因为没有延迟，依赖模块提前执行了，<code>CMD</code>性能好，因为只有用户需要的时候才执行的原因。</p>
</blockquote>
<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p><code>UMD</code> 叫做通用模块定义规范（<code>Universal Module Definition</code>）。随着大前端的趋势所诞生，它可以通过运行时或者编译时让同一个代码模块在使用 <code>CommonJs</code>、<code>CMD</code> 甚至是 <code>AMD</code> 的项目中运行。未来同一个 <code>JavaScript</code> 包运行在浏览器端、服务区端甚至是 <code>APP</code> 端都只需要遵守同一个写法就行了。</p>
<p>它没有自己专有的规范，是集结了 <code>CommonJs</code>、<code>CMD</code>、<code>AMD</code> 的规范于一身，大体实现如下：</p>
<pre><code class="language-js">((root, factory) =&gt; {
    if (typeof define === &#39;function&#39; &amp;&amp; define.amd) {
        //AMD
        define([&#39;jquery&#39;], factory);
    } else if (typeof exports === &#39;object&#39;) {
        //CommonJS
        var $ = requie(&#39;jquery&#39;);
        module.exports = factory($);
    } else {
        root.testModule = factory(root.jQuery);
    }
})(this, ($) =&gt; {
    //todo
});</code></pre>
<h2 id="ESM-ECMA-Script-Modules"><a href="#ESM-ECMA-Script-Modules" class="headerlink" title="ESM (ECMA Script Modules)"></a>ESM (ECMA Script Modules)</h2><p>1) 介绍</p>
<p>前面讲到，<code>JS</code> 原生是不支持模块化的，必须借助其他抽象的工具库。<code>ES6</code> 的出现彻底改变了这种局面，对 <code>JS</code> 模块化方面进行了补充：</p>
<ul>
<li><code>export</code>: 用来暴露模块的 <code>API</code>，可以有多个输出。<code>export default</code>命令，为模块指定默认输出，其他模块加载该模块时，可以为该匿名函数指定任意名字。</li>
<li><code>import</code>: 用于引入其他模块提供的功能。</li>
</ul>
<p>导出示例：</p>
<pre><code class="language-js">//导出多个
const obj1 = { ... }
const obj2 = { ... }
export { obj1, obj2 }
//默认导出
export default { str: &quot;abc&quot; }
</code></pre>
<p>导入示例：</p>
<pre><code class="language-js">// 默认导出可以随意命名
import str1 , { obj1 , obj2 } from &quot;A.js&quot;；
// 导入多个api，命名需和导出一致
import { obj1 , obj2 } from &quot;A.js&quot;；
// 可设置别名
import { obj1 as obj3 , obj2 } from &quot;A.js&quot;；</code></pre>
<p><code>ESM</code> 运行机制与 <code>CommonJS</code> 不一样。<code>CommonJS</code> 模块输出的是一个值的拷贝；<code>ESM</code> 模块输出的是静态<strong>引用</strong>，并且不会缓存值，模块里面的变量绑定其所在的模块。<code>ESM</code>在编译时就能确定模块的依赖关系，以及输入和输出的变量，<code>Tree Shaking</code> 就是基于 <code>ESM</code> 来实现的。</p>
<pre><code class="language-js">// lib.js
export let counter = 3;
export function incCounter() {
  counter++;
}
// main.js
import { counter, incCounter } from &#39;./lib&#39;;
console.log(counter); // 3
incCounter();
console.log(counter); // 4</code></pre>
<p>2）使用</p>
<p>现在，基本上所有的主流浏览器版本都已经支持 <code>ESM</code>。但是浏览器对 <code>ES6</code> 语法的兼容还不够全面，我们需要使用 <code>Babel</code> 编译成浏览器都识别的 <code>ES5</code> 代码来使用。在实际项目中，我们通过打包构建工具（ 如 <code>webpack</code>,<code>rollup</code>） 来统一处理。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr>
<p><a href="https://github.com/ljianshu/Blog/issues/48" target="_blank" rel="noopener">前端模块化详解</a><br><a href="https://www.cnblogs.com/dolphinX/p/4381855.html" target="_blank" rel="noopener">前端模块化</a><br><a href="https://github.com/seajs/seajs/issues/266" target="_blank" rel="noopener">SeaJs快速API</a><br><a href="https://cloud.tencent.com/developer/article/1425476?from=information.detail.requirejs%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noopener">简单实现一个RequireJS</a><br><a href="http://www.ruanyifeng.com/blog/2015/05/require.html" target="_blank" rel="noopener">Node.js require()源码解读</a><br><a href="https://zhuanlan.zhihu.com/p/402155045" target="_blank" rel="noopener">SystemJs探秘</a><br><a href="https://segmentfault.com/a/1190000039305322" target="_blank" rel="noopener">差点被SystemJs惊掉了下巴，解密模块加载黑魔法</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/07/14/React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/07/14/React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/" itemprop="url">React核心原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-07-14T20:18:50+08:00">
                2020-07-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React哲学-简单之美"><a href="#React哲学-简单之美" class="headerlink" title="React哲学-简单之美"></a>React哲学-简单之美</h1><hr>
<ul>
<li><p><code>React</code> 通过 <code>UI = renderWithJSX(state)</code> 完美的解决了如何将 动态数据/频繁交互 高效地反映到复杂的用户界面上。</p>
</li>
<li><p><code>React</code> 通过 虚拟<code>DOM</code>，用 整体刷新 的方式替代了传统的局部刷新。开发人员不需要频繁进行复杂的 <code>DOM</code> 操作，只需要关注 数据状态变化 和最终的 UI 呈现，其他的 React 自动解决，大大降低了开发的复杂度。</p>
</li>
<li><p><code>React</code> 通过 <code>Diff</code> 算法，高效的解决了整体刷新带来的性能问题。</p>
</li>
<li><p><code>React</code> 把 组件 作为构建用户界面的基本单位。</p>
</li>
<li><p><code>React</code> 通过单向数据流动模型，来管理组件之间，组件和数据模型直接的通信。</p>
</li>
<li><p><code>React</code> 还提倡使用只读数据建立数据模型。并开发了一整套框架 <code>immutable.js</code> ，将只读数据的概念引入 <code>JavaScript</code>。只读的数据可以让代码更加的安全和易于维护，你不再需要担心数据在某个角落被某段神奇的代码所修改；也就不必再为了找到修改的地方而苦苦调试。</p>
</li>
<li><p><code>React</code> 项目经理在演讲中说过，<code>React</code> 最有价值的其实是声明式的，直观的编程方式。以简单直观，复合习惯的方式编程，让代码更容易被理解，从而易于维护和不断演进。这就是 <code>React</code> 的设计哲学。</p>
</li>
</ul>
<blockquote>
<p>软件工程向来不提倡用高深莫测的技巧去编程，相反，如何写出可理解可维护的代码才是质量和效率的关键。（深有同感）</p>
</blockquote>
<h1 id="虚拟DOM-amp-JSX"><a href="#虚拟DOM-amp-JSX" class="headerlink" title="虚拟DOM &amp; JSX"></a>虚拟DOM &amp; JSX</h1><hr>
<p>虚拟<code>DOM</code> 是 <code>React</code> 的核心机制之一。</p>
<p>虚拟 <code>DOM</code> 其实就是用 <code>JavaScript</code>对象表示的一个 <code>DOM</code> 节点, 内部包含了节点的 <code>tag</code> , <code>props</code> 和 <code>children</code> 。</p>
<p><code>React</code> 利用 虚拟<code>DOM</code> 将一部分昂贵的浏览器重绘工作转移到相对廉价的存储和计算资源上，以此减少对实际 <code>DOM</code> 的操作从而提升性能。</p>
<p>虚拟<code>DOM</code> 可以通过 <code>JavaScript</code> 来创建，例如：</p>
<pre><code class="language-js">var child1 = React.createElement(&#39;li&#39;, null, &#39;First Text Content&#39;);
var child2 = React.createElement(&#39;li&#39;, null, &#39;Second Text Content&#39;);
var root = React.createElement(&#39;ul&#39;, { className: &#39;my-list&#39; }, child1, child2);</code></pre>
<p>但这样的代码可读性并不好，于是 <code>React</code> 发明了 <code>JSX</code>，利用我们熟悉的 <code>Html</code> 语法来创建 虚拟<code>DOM</code>：</p>
<pre><code class="language-js">var root =(
  &lt;ul className=&quot;my-list&quot;&gt;
    &lt;li&gt;First Text Content&lt;/li&gt;
    &lt;li&gt;Second Text Content&lt;/li&gt;
  &lt;/ul&gt;
);</code></pre>
<p><code>JSX</code> 并不等同于传统 <code>MVC</code> 框架中的 模版引擎，而是一种类似 <code>XML</code> 的高级语法糖，它完美的将 <code>Javascript</code> 和 <code>Dom</code> 融合在一起，你中有我，我中有你。</p>
<p><code>JSX</code> 其实并没有增加 <code>React</code> 的学习门槛，只要你熟悉 <code>Html</code> 结构，会 <code>Javascript</code> 就很容易掌握。其并不比学习一些模版引擎的学习成本高。</p>
<p><code>JSX</code> 通过 <code>babel</code> 编译后，其实也是通过 <code>React.createElement</code> 创建的虚拟<code>Dom</code>对象。</p>
<h1 id="DIFF算法"><a href="#DIFF算法" class="headerlink" title="DIFF算法"></a>DIFF算法</h1><hr>
<p><code>React</code> 中最神奇的部分莫过于 虚拟<code>DOM</code>，以及其高效的 <code>Diff</code> 算法。这让我们可以无需担心性能问题而 “毫无顾忌” 的随时 “刷新”整个页面。</p>
<p>在 <code>React</code> 中，构建 <code>UI</code> 界面的思路是由当前状态决定界面。前后两个状态就对应两套界面，然后由 <code>React</code> 来比较两个界面的区别，这就需要对 <code>DOM</code> 树进行 <code>Diff</code> 算法分析。</p>
<p>但是树的标准 <code>Diff</code> 算法复杂度需要 <code>O(n^3)</code>，这显然无法满足性能要求。<code>Facebook</code> 工程师结合 <code>Web</code> 界面的特点做出了两个简单的假设，使得 <code>Diff</code> 算法复杂度直接降低到 <code>O(n)</code>。</p>
<ul>
<li>两个相同组件产生类似的 <code>DOM</code> 结构，不同的组件产生不同的 <code>DOM</code> 结构。</li>
<li>对于同一层次的一组子节点，它们可以通过唯一的 <code>id</code> 进行区分。</li>
</ul>
<p>首先，<code>React</code> 的 <code>DOM Diff</code> 算法实际上只会对树进行逐层比较。</p>
<p><strong>如果节点类型/组件不同</strong>：<br><code>React</code> 直接删除前面的节点（包括所有子节点），然后创建并插入新的节点。同样的，当 <code>React</code> 在同一个位置遇到不同的组件时，会简单的销毁第一个组件，而把新创建的组件加上去。</p>
<p><strong>如果节点类型相同</strong>：<br>比较简单，<code>React</code> 会对属性进行重设来实现节点的转换。对于同一类型的组件，当组件的<code>props</code>更新时, 组件实例保持不变, <code>React</code>调用组件的 <code>componentWillReceiveProps()</code>, <code>componentWillUpdate()</code> 和 <code>componentDidUpdate()</code> 生命周期方法, 并执行 <code>render()</code>方法.</p>
<p><strong>列表节点比较特殊</strong>：<br>同层元素较多，经常会有删除，插入，排序操作。比如插入一条数据，按前面的逻辑，会频繁的进行销毁和重建，<code>Dom</code>操作过于频繁。<code>React</code> 没法高效的进行更新。所以，对于列表节点提供唯一的 <code>key</code> 属性可以帮助 <code>React</code> 定位到正确的节点进行比较，从而大幅减少 <code>DOM</code> 操作次数，提高性能。</p>
<p>当你了解了 <code>Diff</code>算法，在使用 <code>React</code> 开发组件的过程中，也要有意识的书写高性能的代码：</p>
<ul>
<li>保持稳定的 <code>DOM</code> 结构，比如通过<code>CSS</code>显示隐藏节点，而不是真的移除和添加。</li>
<li>对于列表，尽量设置唯一 <code>Key</code> 属性，让 <code>React</code> 更高效的更新。</li>
</ul>
<blockquote>
<p>切记，这里的 <code>key</code> 一定是能唯一标示这一条数据的，遍历方法中(<code>(item,index) =&gt; {}</code>) 的 <code>index</code> 属性是不行的，还会引发不确定的<code>bug</code>。因为插入，排序，删除操作以后重新遍历，相同的 <code>index</code> 已经指向了不同的数据。</p>
</blockquote>
<p>但是，我们面临着一个重大的性能问题：</p>
<p>刷新率：大部分显示器屏幕都有固定的刷新率（比如最新的一般在 60Hz），所以浏览器更新最好是在 60fps。如果在两次硬件刷新之间浏览器进行两次重绘是没有意义的只会消耗性能。 浏览器会利用这个间隔 16ms(一帧)适当地对绘制进行节流，如果在 16ms 内做了太多事情，会阻塞渲染，造成页面卡顿， 因此 16ms 就成为页面渲染优化的一个关键时间。</p>
<p>浏览器的 渲染线程 和<code>JS</code>的 执行线程 是互斥的。当如果 组件树 的层级很深，递归处理 虚拟<code>Dom</code> 会长时间占用主线程。这使得一些需要高优先级处理的操作如用户输入、动画等被阻塞，造成卡顿， 严重影响使用体验。</p>
<blockquote>
<p>上述问题是普遍存在的，浏览器中其实已经提供了 <code>window.requestIdleCallback()</code> 方法试图解决这个问题（目前还处于实验性阶段）。这个方法将在浏览器的空闲时段内调用方法设置的函数队列。这使开发者能够在主事件循环上执行后台和低优先级工作，而不会影响延迟关键事件，如动画和输入响应。函数一般会按先进先调用的顺序执行，然而，如果回调函数指定了执行超时时间<code>timeout</code>，则有可能为了在超时前执行函数而打乱执行顺序。</p>
</blockquote>
<h1 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h1><hr>
<p>为了解决高优先级处理任务被阻塞的问题，<code>React16</code> 版本对其核心进行了一系列重构，<code>React16</code> 架构可以分为三层：</p>
<ul>
<li><code>Scheduler</code>（调度器）—— 调度任务的优先级，高优任务优先进入<code>Reconciler</code></li>
<li><code>Reconciler</code>（协调器）—— 负责找出变化的组件</li>
<li><code>Renderer</code>（渲染器）—— 负责将变化的组件渲染到页面上</li>
</ul>
<p>可以看到，相较于<code>React15</code>，<code>React16</code>中 新增了 <code>Scheduler</code>（调度器）。<code>Reconciler</code> 内部采用了<code>Fiber</code>的架构。</p>
<p><em>*时间切片策略</em> 要求我们将 虚拟<code>DOM</code> 的更新操作分解为小的工作单元, 同时具备以下特性:</p>
<ul>
<li>可暂停、可恢复的更新;</li>
<li>可跳过的重复性、覆盖性更新;</li>
<li>具备优先级的更新.</li>
</ul>
<p>对于递归形式的程序来说, 这些是难以实现的。 于是就需要一个处于递归形式的 虚拟<code>DOM</code> 树更上层的一种数据结构, 来辅助完成这些特性。</p>
<p>这就是 <code>React16</code> 在重构中引入的算法核心 —— <code>Fiber</code> 链表数据结构。</p>
<p>从概念上来说, <code>Fiber</code> 就是重构后的 虚拟<code>DOM</code> 节点, 一个<code>Fiber</code>就是一个<code>JS</code>对象。</p>
<p><code>Fiber</code>节点之间构成 单向链表 结构。<code>React</code> 使用 “双缓存” 来完成 <code>Fiber</code> 树的构建与替换——对应着 <code>DOM</code> 树的创建与更新。</p>
<blockquote>
<p>在内存中构建并直接替换的技术叫做双缓存.</p>
</blockquote>
<p><code>Scheduler</code> 是 <code>React</code> 引入 <strong>时间切片</strong>(<code>Time Slice</code>)策略的产物。考虑到浏览器的兼容性以及 <code>requestIdleCallback</code> 方法的不稳定性（没秒执行20次，正常浏览器刷新是60）, <code>React</code> 自己实现了 <code>React</code> 专用的的类似 <code>requestIdleCallback</code> 且功能更完备的 <code>Scheduler</code> 来实现空闲时触发回调, 并提供了多种优先级供任务设置。</p>
<p>主要用到的技术点如下：</p>
<ul>
<li><p><code>requestAnimationFrame</code></p>
</li>
<li><p><code>macrotasks</code>(宏任务)。</p>
</li>
<li><p><code>MessageChannel/postMessage</code> 生成高优先级宏任务（比 <code>setTimeout</code> 执行时机更靠前）</p>
</li>
</ul>
<blockquote>
<p>浏览器一帧内工作：一个task(宏任务) – 队列中全部job(微任务) – requestAnimationFrame – 浏览器重排/重绘 – requestIdleCallback</p>
</blockquote>
<p>调度器主要工作流程如下：</p>
<ul>
<li><p>更新队列产生以后，调度器启动。</p>
</li>
<li><p>调度时通过 <code>requestAnimationFrame</code> 在浏览器每次重绘前做想做的事。给<code>requestAnimationFrame</code> 设置的回调方法<code>animationTick</code> 会在浏览器动画执行前执行。</p>
</li>
<li><p>在 <code>animationTick</code> 中可以确定下一帧结束的时间点，因为不知道 <code>react</code> 更新需要多少时间，所以不在 <code>animationTick</code> 中判断当前帧剩余时间来执行 <code>react</code> 更新，而是通过 postMessage 把用于更新 的 <code>flushWork</code> 推入宏任务队列 <code>macrotasks</code>。</p>
</li>
<li><p>在 <code>window.addEventListener(&#39;message&#39;, idleTick, false);</code> 的 <code>idleTick</code>回调中，会一直拖到当前帧完全过期时才把 <code>didTimeout = true</code>, 才去执行这次 <code>react</code> 更新。</p>
</li>
<li><p>这样， <code>react</code> 更新 的 <code>flushWork</code> 作为 宏任务 会先于 <code>requestAnimationFrame</code> 执行。这时 <code>flushWork</code> 就算更新时间超过当前帧剩余时间借用了下一帧的时间，也是最大限度的保证了浏览器动画的流畅性和优先级。</p>
</li>
</ul>
<h1 id="合成事件-SyntheticEvent"><a href="#合成事件-SyntheticEvent" class="headerlink" title="合成事件 SyntheticEvent"></a>合成事件 SyntheticEvent</h1><hr>
<p><code>React</code> 提供了一种 “顶层注册，事件收集，统一触发” 的事件机制。我们称其为合成事件（<code>SyntheticEvent</code>）。它自己遵循<code>W3C</code>的规范又实现了一遍浏览器的事件对象接口，这样可以抹平差异，而原生的事件对象只不过是它的一个属性（<code>nativeEvent</code>）</p>
<p><code>SyntheticEvent</code> 是浏览器的原生事件的跨浏览器包装器，除了兼容所有浏览器外，还拥有浏览器原生事件接口，包括<code>e.stopPropagation()</code>，<code>e.preventDefault()</code>。当你需要使用浏览器底层事件时，只需要使用 <code>nativeEvent</code>属性来获取即可。比如 <code>e.nativeEvent.stopImmediatePropagation()</code>。 </p>
<p>我们在 <code>React</code> 组件中通过 <code>JSX</code> 语法中的绑定的所有事件都挂载在 <code>document</code> 上（ 不是 <code>window</code>，也不是 <code>document.body</code> ）。当真实 <code>Dom</code> 触发后冒泡到 <code>document</code> 后才会对 <code>React</code> 事件进行处理。</p>
<p>当同时存在 原生<code>API</code>注册事件 和 合成事件 的情况下，事件触发顺序如下：</p>
<ul>
<li>声明为 捕获阶段 执行的原生事件 执行（父元素上事件先执行）。</li>
<li>其他 绑定在 <code>document</code> 子元素上的 原生事件（默认为冒泡阶段执行） 执行。</li>
<li><code>React</code>事件按实际触发元素的 冒泡顺 序执行 （子  &gt;  父）。</li>
<li>绑定在 <code>docoment</code> 元素上的 原生事件 执行。</li>
<li>绑定在 <code>window</code> 上的 原生事件 执行。</li>
</ul>
<p>依次举例如下：</p>
<ul>
<li><code>document.addEventListener(&#39;click&#39;, () =&gt; {}), true)；</code></li>
<li><code>document.body.addEventListener(&#39;click&#39;, () =&gt; {}), false)；</code></li>
<li><code>&lt;div onClick={ () =&gt; {} }&gt;&lt;/div&gt;</code></li>
<li><code>document.addEventListener(&#39;click&#39;, () =&gt; {}), false)；</code></li>
<li><code>window.addEventListener(&#39;click&#39;, () =&gt; {}), false)；</code></li>
</ul>
<p>阻止冒泡：</p>
<ul>
<li><code>e.stopPropagation()</code>：能阻止下层 <code>React</code>合成事件 到 上层 <code>React</code> 合成事件的冒泡。因为 <code>React</code> 合成事件 都是注册在<code>document</code> 上，所以对于原生事件，只能阻止向 <code>window</code> 事件冒泡。</li>
<li><code>e.nativeEvent.stopImmediatePropagation()</code>：阻止 原生事件执行。条件是这个原生事件一定是绑定在<code>document</code>元素上，并且是冒泡阶段执行。</li>
</ul>
<p>下面我们来探究以下合成事件的实现原理，我们可以分为两个阶段：</p>
<ul>
<li>事件注册 和 存储。</li>
<li>事件触发 并 执行。</li>
</ul>
<h2 id="事件注册-存储"><a href="#事件注册-存储" class="headerlink" title="事件注册/存储"></a>事件注册/存储</h2><p>每当组件进入 <code>render</code> 阶段的 <code>complete</code>阶段时，名称为 <code>onClick...</code> 的 <code>prop</code> 会被识别为 事件 进行事件注册处理。通过<code>lastProps</code>、<code>nextProps</code> 判断事件是新增还是删除，删除会调用事件卸载方法。</p>
<p><code>React</code>会根据 事件名称匹配它所依赖的原生事件，例如 <code>onMouseEnter</code> 事件依赖了 <code>mouseout</code> 和 <code>mouseover</code> 两个原生事件，onClick只依赖了click一个原生事件。</p>
<p>并将 事件回调 存储在 <code>EventPluginHub.listenerBank</code>中，并通过元素的唯一 <code>key</code> 来标识：<code>listenerBank[registrationName][key]</code>，其中 <code>registrationName</code> 是事件名称，如<code>onClick</code>。</p>
<p>最终 <code>document</code> 元素上会注册所有涉及类型的原生事件。事件处理函数则是 根据事件类型创建的各类事件监听器 <code>listener</code> 。一般有以下三种事件监听器：</p>
<ul>
<li><code>dispatchDiscreteEvent</code>: 处理离散事件</li>
<li><code>dispatchUserBlockingUpdate</code>：处理用户阻塞事件</li>
<li><code>dispatchEvent</code>：处理连续事件</li>
</ul>
<h2 id="事件触发-执行"><a href="#事件触发-执行" class="headerlink" title="事件触发/执行"></a>事件触发/执行</h2><p>当 <code>React</code> 在 <code>document</code> 元素上注册的原生事件被触发，对应的事件监听器 <code>listener</code> 开始工作。它按照事件的优先级去安排接下来的工作：构造合成事件、将事件处理函数收集到执行路径、 事件执行。</p>
<p>根据事件类型，通过 <code>SyntheticEvent</code> 构造函数生成对应的合成事件对象。</p>
<p>从触发事件的的最深层元素开始，遍历这个元素的所有父元素，根据事件名称，收集到之前存储的所有 事件处理函数 到 执行路径。</p>
<p>最后会生产如下的 <code>dispatchQueue</code> 结构的 <code>eventQueue</code>：</p>
<pre><code class="language-js">[
  {
    event: SyntheticEvent,
    listeners: [ listener1, listener2, ... ]
  }
]</code></pre>
<p>可以看到，我们将 同一类事件 构造的合成事件存储在 <code>listeners</code> 事件队列中，用于冒泡/捕获的模拟处理。我们遍历事件队列，执行带有合成事件对象（<code>event</code>）参数的回调函数。</p>
<ul>
<li>冒泡阶段事件，从前往后遍历。通过 <code>isPropagationStopped</code> 判断当前事件是否执行了阻止冒泡方法。如果阻止了冒泡，则停止遍历。</li>
<li>捕获阶段事件，从后往前遍历 即可。</li>
</ul>
<img src="/2020/07/14/React%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86/react%E4%BA%8B%E4%BB%B6%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6.jpeg" class="">

<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr>
<p><a href="https://www.infoq.cn/news/react-art-of-simplity" target="_blank" rel="noopener">深入浅出 React</a><br><a href="https://juejin.cn/post/6844903790198571021#heading-6" target="_blank" rel="noopener">React事件机制</a><br><a href="https://zhuanlan.zhihu.com/p/347531057" target="_blank" rel="noopener">深入React合成事件机制原理</a><br><a href="https://juejin.cn/post/6987197729046790175" target="_blank" rel="noopener">React核心原理浅析</a><br><a href="https://react.iamkasong.com/#%E5%AF%BC%E5%AD%A6%E8%A7%86%E9%A2%91" target="_blank" rel="noopener">React技术揭秘</a><br><a href="https://pomb.us/build-your-own-react/" target="_blank" rel="noopener">Build Your Own React</a><br><a href="https://www.jianshu.com/p/87533d64626a" target="_blank" rel="noopener">React 源码解析 - 调度模块原理 - 实现 requestIdleCallback </a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/05/24/React-Hooks-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/24/React-Hooks-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/" itemprop="url">React Hooks 原理与应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-24T20:15:11+08:00">
                2020-05-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React-Hooks-起源"><a href="#React-Hooks-起源" class="headerlink" title="React Hooks 起源"></a>React Hooks 起源</h1><ul>
<li>React 一直都提倡使用函数式组件。更轻便，更优雅，性能更佳。函数式组件又称<strong>无状态组件(FSC)</strong>。</li>
<li>以前，需要使用 <code>state</code> ，生命周期等React 特性，必须重构为 class 组件。</li>
<li><code>Hooks</code> 是 React 16.8 新增的特性，它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 React 特性。</li>
<li>现在，你可以直接在现有的函数式组件中使用 <code>Hooks</code>，而无须重构为 <code>class</code> 组件。</li>
<li>全新的思维方式。no magic, just javascript and some rules。</li>
</ul>
<img src="/2020/05/24/React-Hooks-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/hooks-1.jpg" class="" title="hooks起源">

<h1 id="类组件被诟病"><a href="#类组件被诟病" class="headerlink" title="类组件被诟病"></a>类组件被诟病</h1><ul>
<li>类(累)：自js开天辟地，就是面向函数式编程(<code>FP</code>), 面向对象编程(<code>OOP</code>)为何物。烦人的构造函数。<code>super</code>是什么？……</li>
<li>this绑定：类方法不会自动绑定 this 到实例上。现有四种<code>bind</code>方式。不优雅，易出错，<code>bind</code>还影响性能（使用箭头函数后有所改善）。</li>
<li><code>setState()</code>: 异步更新机制，<code>state</code> 浅合并机制。不理解这些概念，很容易踩坑。</li>
<li>生命周期耦合：每个生命周期方法通常包含一堆不相关的逻辑；不同生命周期中的逻辑又有关联。</li>
</ul>
<p>下面组件来自实际项目，经过简化和微调（方便演示和直观感受），基本上暴露出了上面所有问题。业务逻辑严谨性不用推敲：</p>
<pre><code class="language-jsx">class NumberInput extends React.Component {
  constructor(props) {
    // 为什么必须super，不传props会怎样
    super(props)
    this.state = {
      focus: false
    }
    this.tradingpwd = &#39;&#39;
    // 第一种bind，官方推荐
    ;[&#39;onBlur&#39;].forEach(method =&gt; {
      this[method] = this[method].bind(this)
    })
  }
  // 下面两个生命周期得相互配合，实现某些功能
  componentDidMount() {
    this.tradingPwdHideInput.focus()
    // 处理某类兼容问题
    let bodyTop = document.body.getBoundingClientRect().top
    const styleText = &#39;position: fixed; width: 100%; top: &#39; + bodyTop + &#39;px&#39;
    document.body.style.cssText = styleText
  }

  componentWillUnmount() {
    this.tradingPwdHideInput.blur()
    document.body.style.position = &#39;static&#39;
  }

  tradingPwdChange(e) {
    // ...
    this.tradingpwd = e.target.value
    this.props.inputChangeCallback(e.target.value)
    // ...
  }
  // 第二种bind
  onFocus = () =&gt; {
    this.setState({
      focus: true
    })
  }
  onBlur() {
    this.setState({
      focus: false
    })
  }

  render() {
    return (
      &lt;div className={classNames(&#39;NumberInput&#39;)}&gt;
        &lt;input
          type=&#39;tel&#39;
          ref={ref =&gt; {
            this.tradingPwdHideInput = ref
          }}
          id=&#39;tradingPwdHideInput&#39;
          /* 第三种bind */
          onClick={() =&gt; {
            this.tradingPwdHideInput.focus()
          }}
          onBlur={ this.onBlur }
          onFocus={ this.onFocus }
          /* 第四种bind，不推荐，在每次 render() 方法执行时绑定类方法，消耗性能*/
          onChange={ this.tradingPwdChange.bind(this) }
        /&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<blockquote>
<p><a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">proposal-class-fields</a> 新提案会改善上述情况，目前处于第三阶段。</p>
</blockquote>
<p>随着类组件趋于复杂，还有其他诟病：</p>
<ul>
<li>难拆分，本地<code>state</code>逻辑到处都是，当组件越来越复杂，想拆分比较难。</li>
<li>状态逻辑难复用：需要引入高阶特性进行代码重构，需要调整组件结构，成本高。</li>
<li>抽象地狱：大型<code>React</code>往往使用<code>render props</code> ，<code>HOC</code>，<code>Context</code> 等高阶特性，形成大量包装组件（wrapping components）。层级冗余，逻辑难追踪。</li>
</ul>
<h1 id="Hooks-优越性"><a href="#Hooks-优越性" class="headerlink" title="Hooks 优越性"></a>Hooks 优越性</h1><p><code>Hooks</code> 引入的一个重要的原因，就是类组件存在着种种诟病。那他必然存在一些优越性。</p>
<p>在说明这些优越性之前，先了解一个概念：</p>
<blockquote>
<p><strong>副作用</strong>：React 中主要指那些没有发生在数据向视图（M-V）转换过程中的逻辑，如 <code>Ajax</code> 请求、访问原生 <code>DOM</code> 元素、本地持久化缓存、绑定/解绑事件、添加/取消订阅、设置定时器、记录日志等。</p>
</blockquote>
<p>Hooks 的优越性：</p>
<ul>
<li>函数式编程：No <code>class</code>, No <code>super</code>, No <code>this</code>。对于不了解 <code>OOP</code> 的 <code>React</code> 初学者更友好。</li>
<li>有状态逻辑易复用：可以通过 <code>Custom Hook</code>（后面讲解）重构，而不用修改组件结构。</li>
<li>易拆分：状态管理和副作用管理松耦合，原子性强。很容易将一些相关联的逻辑拆分成更小的函数。</li>
<li>可逐步引入：<code>Hooks</code> 向后兼容，与现有代码可并行工作，因此我们可以逐步采用它们。</li>
<li>副作用分组：很多副作用逻辑分散在类组件生命周期函数中。而 <code>Hooks</code> 可以将每个副作用的设置和清理封装在一个函数中。</li>
<li>副作用分离：副作用操作都在页面渲染之后。</li>
</ul>
<h1 id="抛弃类组件？"><a href="#抛弃类组件？" class="headerlink" title="抛弃类组件？"></a>抛弃类组件？</h1><p>既然 <code>Hooks</code> 存在这么多优越性。那是不是就到了抛弃 <code>class</code> 组件的时候了。</p>
<p>对此，官方说：</p>
<ul>
<li>新版本依然支持 <code>class</code> 相关API，在相当一段时期内，<code>class</code> 组件 和 <code>Hooks</code> 组件并存。</li>
<li>向后兼容，是加法。注意，是函数组件的加法，即 <code>Hooks</code> 只能用在函数组件中。</li>
<li>推荐使用 函数组件 + <code>Hooks</code>。</li>
</ul>
<p>个人看法：</p>
<p>不抛弃，不放弃。<code>class</code> 组件将我们带到了 <code>OOP</code> 的世界，<code>OOP</code>在编程界举足轻重，其思想是值得学习的，还会长期存在。即便 <code>class</code> 组件已然成为一种历史产物，但他的存量巨大，依然需要去维护，去慢慢消化。</p>
<p>所以：</p>
<ul>
<li>对于 <code>React</code> 老司机：拥抱<code>Hooks</code>，是拥抱变化。这个变化，是加法，是学习新的<code>API</code>，新的技能，新的思想。</li>
<li>对于 <code>React</code> 新手：拥抱<code>Hooks</code>，降低了学习门槛，可以更快入门。但是类组件也非常有必要去了解，理解。知己知彼，重构不殆。</li>
</ul>
<p>说了这么多，我们来和这些 <code>React Hooks</code> 的 <code>API</code> 见个面：</p>
<p>基础 <code>Hook</code></p>
<ul>
<li><code>useState</code> 简单状态管理</li>
<li><code>useEffect</code> 副作用管理</li>
</ul>
<p>常用 <code>Hook</code></p>
<ul>
<li><code>useContext</code> 全局状态管理</li>
<li><code>useReducer</code> 复杂状态管理</li>
<li><code>useRef</code> 访问 <code>Dom</code> 元素</li>
</ul>
<p>其他 <code>Hook</code></p>
<ul>
<li><code>useMemo</code></li>
<li><code>useCallback</code></li>
<li><code>useImperativeHandle</code></li>
<li><code>useLayoutEffect</code></li>
<li><code>useDebugValue</code></li>
<li>… 还会增加</li>
</ul>
<h1 id="useState-hook"><a href="#useState-hook" class="headerlink" title="useState hook"></a>useState hook</h1><ul>
<li>功能：在函数组件中用来进行简单状态管理，创建<strong>一些</strong>本地 <code>state</code>。</li>
<li>API：<code>const [currentState, setFunction] = useState(initialState);</code>。传一个参数，返回一个数组（包含两个值）- 三要素。</li>
</ul>
<pre><code class="language-jsx">import React, { useState } from &#39;react&#39;;
function Form() {
  // ES6 解构
  const [name, setName] = useState(&#39;Mary&#39;);              // State 变量 1
  const [surname, setSurname] = useState(&#39;Poppins&#39;);     // State 变量 2
  const [width, setWidth] = useState(window.innerWidth); // State 变量 3

  function handleNameChange(e) {
    setName(e.target.value);
  }

  function handleSurnameChange(e) {
    setSurname(e.target.value);
  }

  return (
    &lt;&gt;
      &lt;input value={name} onChange={handleNameChange} /&gt;
      &lt;input value={surname} onChange={handleSurnameChange} /&gt;
      &lt;p&gt;Hello, {name} {surname}&lt;/p&gt;
      &lt;p&gt;Window width: {width}&lt;/p&gt;
    &lt;/&gt;
  );
}
export default Form;</code></pre>
<h2 id="useState「粒度」问题"><a href="#useState「粒度」问题" class="headerlink" title="useState「粒度」问题"></a>useState「粒度」问题</h2><p>看到这里，对于写过<code>class</code>组件的我们，很容易产生一个疑问。 实际工作中，一个类组件的 <code>this.state</code> 中往往有十几项，用 <code>Hooks</code> 改写的话难道要写十几个 <code>useState</code> 么？</p>
<p>根据官方文档，总结下来，有几点：</p>
<ul>
<li>建议将 <code>state</code> 分割为多个 <code>useState</code>。粒度更细，更易于管理，更好复用。</li>
<li>可能一起改变的 <code>state</code> 可合并成一个<code>useState</code>（ 比如<code>Dom</code>元素的 <code>top</code> <code>left</code>）。</li>
<li>当 <code>state</code> 逻辑趋于复杂，建议使用 <code>useReducer</code> 或 <code>Custom Hook</code> 管理（<strong>后面介绍</strong>）。</li>
</ul>
<p>当组件的 <code>state</code> 很多的时候，为了提高代码的可读性，也可以把逻辑相关的一些 <code>state</code> 合并为一个 <code>useState</code>（ 比如分页参数 ）。但这些 <code>state</code> 并不是一起改变的，所以当其中一个 <code>state</code> 改变，调用对应的 <code>setFunction</code> 的时候。你需要做<strong>对象合并</strong>(不合并就丢了)：</p>
<pre><code class="language-jsx">const [ pageData, setPageDate ] = useState({ pageSize: 20, current: 1, total:0, })

const onPageChange = current =&gt; {
  // 常规操作
  setPageDate( Object.assign( {}, pageData, { current } ) ）
  // 官方建议
  setPageDate(currentPageData =&gt; ({ ...currentPageData, current}));
}
</code></pre>
<blockquote>
<p>知识点：调用 <code>useState</code> 的更新函数时，可以传一个箭头函数，这个函数的参数是当前最新的 <code>state</code>， 返回值是要设置的 <code>state</code>。</p>
</blockquote>
<h1 id="useEffect-hook"><a href="#useEffect-hook" class="headerlink" title="useEffect hook"></a>useEffect hook</h1><p>API 可抽象为: <code>useEffect(arrowFunction, [depsArr])</code> </p>
<ul>
<li><code>arrowFunction</code>: 必须。执行函数，执行副作用操作。它决定了做什么。</li>
<li><code>depsArr</code>: 非必须。一个依赖项数组。它决定了什么时候做（下面示例中介绍）。</li>
</ul>
<p>根据实际情况，可细分为三种：</p>
<pre><code class="language-jsx">// 第一种
// 最基础的，只有箭头函数。没有依赖项，所以组件每次渲染都会执行。
// 相当于  componentDidMount + componentDidUpdate
useEffect(() =&gt; { 
  //side-effect 
})
// 第二种
// 有依赖项，是一个空数组，因为它永远不会变，所以只会首次执行。
// 相当于 componentDidMount
useEffect(() =&gt; { 
  //side-effect 
}, [])
// 第三种
// 有第二个参数，且非空数组。首次渲染会执行。重新渲染时，只有当依赖项的值改变了才会执行。
useEffect(() =&gt; { 
  //side-effect 
}, [...state])</code></pre>
<p>总结下来：</p>
<ul>
<li>功能：管理 <code>React</code> 函数组件的副作用，赋予生命周期能力。</li>
<li>怎么管：组件每次渲染到屏幕之后，根据依赖项的情况判断是否调用执行函数。</li>
<li>二要素：执行函数，依赖项。</li>
<li>清理机制：你可以在执行函数中返回另一个函数-<strong>清理函数</strong>，清理函数会在组件卸载的时候，会在组件重新渲染，且useEffect的依赖项值改变的时候调用。起到了 class 组件中<code>componentWillUnmount</code>的作用, 后续会在场景实例中介绍。</li>
<li>使用上：和 <code>useState</code> 一样，可使用多个。建议一个副作用对应一个 <code>useEffect</code>。</li>
</ul>
<p>以定时器为例，让我们来实现一个秒表组件。这是一个学习和理解 <code>useEffect</code> 非常有意思的例子:</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;

function App() {
  // 秒表开关
  const [isOn, setIsOn] = useState(false);
  // 计数
  const [timer, setTimer] = useState(0);

  useEffect(() =&gt; {
    let interval;
    //开关打开的时候才执行
    if (isOn) {
      // 通过定时器增加计数
      interval = setInterval(
        () =&gt; setTimer(val =&gt; val + 1),
        1000,
      );
    }
    // 需要清除定时器
    return () =&gt; clearInterval(interval);
  },[isOn]);

  return (
    &lt;&gt;
      &lt;p&gt;{timer}&lt;/p&gt;

      {!isOn &amp;&amp; (
        &lt;button type=&quot;button&quot; onClick={() =&gt; setIsOn(true)}&gt;
          Start
        &lt;/button&gt;
      )}

      {isOn &amp;&amp; (
        &lt;button type=&quot;button&quot; onClick={() =&gt; setIsOn(false)}&gt;
          Stop
        &lt;/button&gt;
      )}
    &lt;/&gt;
  );
}

export default App;
</code></pre>
<blockquote>
<p>规则：<code>useEffect</code> 不能接收 <code>async</code> 作为执行函数。<code>useEffect</code> 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 <code>async</code> 返回的是 <code>promise</code>。<br><code>useEffect</code> 调用的函数如果依赖 <code>state</code> 或者 <code>props</code>。最好在执行函数中定义。这样依赖容易追踪。</p>
</blockquote>
<p><code>useEffect</code> 的使用，看起来很简单。但是要做到不滥用，正确使用也不是那么容易。主要在使用之前要多一些思考。</p>
<h1 id="Custom-Hooks"><a href="#Custom-Hooks" class="headerlink" title="Custom Hooks"></a>Custom Hooks</h1><p>它并不是 <code>React hooks</code> 的 <code>API</code>，而是<strong>自定义 hook</strong>。顾名思义，<code>React</code>允许你构建自己的 <code>hooks</code>。在学习完前面两个最受欢迎的 <code>hooks</code> 以后，你完全具备了实现自定义 <code>hooks</code> 的能力。</p>
<blockquote>
<p>官网定义： 自定义 <code>Hook</code> 是一个 <code>JavaScript</code> 函数，其名称以 <code>”use”</code> 开头，可以调用其他 <code>Hook</code>。</p>
</blockquote>
<p>为什么需要<code>Custom Hooks？</code></p>
<ul>
<li><code>useState</code> 解决了函数组件无状态的问题。</li>
<li><code>useEffect</code> 实现了副作用管理，生命周期的功能。</li>
<li><code>Custom Hooks</code> 将解决有状态（<code>stateful</code>）逻辑共享的问题（相当于类组件中<code>Hoc</code>的功能）。👇</li>
</ul>
<p>我们来到一个实际场景。如今 <code>HTML5</code> 移动应用或 <code>Web app</code> 中越来越普遍的使用了离线浏览技术，所以用 <code>JS</code> 检测浏览器在线/离线状态非常常见。首先，我们用 <code>React Hooks</code> 来实现这个功能：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
function App() {
  const [isOffline, setIsOffline] = useState(window.navigator.onLine);
  // 离线事件处理方法
  function onOffline() {
    setIsOffline(true);
  }
  // 在线事件处理方法
  function onOnline() {
    setIsOffline(false);
  }
  useEffect(() =&gt; {
    // 事件监听
    window.addEventListener(&#39;offline&#39;, onOffline);
    window.addEventListener(&#39;online&#39;, onOnline);
    // 清理函数
    return () =&gt; {
      window.removeEventListener(&#39;offline&#39;, onOffline);
      window.removeEventListener(&#39;online&#39;, onOnline);
    };
  }, []); // 只需要首次执行
  return (
    &lt;&gt;
       { 
         isOffline
         ? &lt;div&gt;网断已断开 ...&lt;/div&gt;
         : &lt;div&gt;网络已连接 ...&lt;/div&gt;
       }
    &lt;/&gt;
  )
}
export default App;</code></pre>
<blockquote>
<p>无论浏览器是否在线，<code>navigator.onLine</code> 属性都会提供一个布尔值。 如果浏览器在线，则设置为 <code>true</code> ，否则设置为 <code>false</code> 。</p>
</blockquote>
<p>OK，我们实现了一个很不错的功能。很明显，这个功能是可复用的，应该共享的。<br>我们把功能逻辑提取出来，把它封装成一个 <code>Custom hook</code> 就可以了：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
// 自定义 hook
function useOffline() {
  const [isOffline, setIsOffline] = useState(window.navigator.onLine);
  function onOffline() {
    setIsOffline(true);
  }
  function onOnline() {
    setIsOffline(false);
  }
  useEffect(() =&gt; {
    window.addEventListener(&#39;offline&#39;, onOffline);
    window.addEventListener(&#39;online&#39;, onOnline);
    return () =&gt; {
      window.removeEventListener(&#39;offline&#39;, onOffline);
      window.removeEventListener(&#39;online&#39;, onOnline);
    };
  }, []);
  return isOffline; // 只暴露一个 state
}

// 函数组件
function App() {
  const isOffline = useOffline();
  return (
    &lt;&gt;
       { 
         isOffline
         ? &lt;div&gt;网断已断开 ...&lt;/div&gt;
         : &lt;div&gt;网络已连接 ...&lt;/div&gt;
       }
    &lt;/&gt;
  )
}
export default App;</code></pre>
<p>从重构层面来说，就是把组件中的一些 <code>hooks</code> 抽离到一个函数中，再使用这个函数。这个函数就是 <code>React custom hooks</code>。</p>
<p>书写 <code>custom hooks</code> 需要注意些什么呢：</p>
<ul>
<li>自定义 <code>Hooks</code> 自然地遵循 <code>Hooks</code> 设计的约定。即遵循所有你用到的 <code>Hooks</code>  的规则。</li>
<li>请使用 <code>use</code> 开头。这个习惯非常重要。如果没有它，我们就不能自动检查该 <code>Hook</code> 是否违反了 <code>Hooks</code> 的规则，因为我们无法判断某个函数是否包含对其内部 <code>Hooks</code> 的调用。</li>
</ul>
<h1 id="useRef-Hook"><a href="#useRef-Hook" class="headerlink" title="useRef Hook"></a>useRef Hook</h1><p>在典型的 <code>React</code> 数据流中，<code>DOM</code> 元素的修改都是通过 <code>M-V</code> 的形式重新渲染。<code>M</code> 主要是组件的本地 <code>state</code> ，以及父组件传递给子组件的 <code>props</code>。<br>但是，在某些情况下，你需要在典型数据流之外，手动使用/操作 <code>DOM</code>：</p>
<ul>
<li>管理焦点，媒体播放，文本选择，触发强制动画等。</li>
<li>集成第三方 <code>DOM</code> 库。</li>
</ul>
<pre><code class="language-jsx">import React, { useState, useEffect, useRef } from &quot;react&quot;;
function App() {
  const [value, setValue] = useState(&quot;hellow hooks&quot;);
  //创建 refs 只有这里有修改
  const inputRef = useRef();
  // 日志A
  console.log(inputRef.current) 
  useEffect(() =&gt; {
    // 日志B
    console.log(inputRef.current);
    inputRef.current.focus();
  });
  function inputHandler(val) {
    setValue(val.target.value);
  }
  return (
    &lt;&gt;
      &lt;input type=&quot;text&quot; value={value} ref={inputRef} onChange={inputHandler} /&gt;
    &lt;/&gt;
  );
}
export default App;</code></pre>
<ul>
<li>类组件中：<code>React16.3</code> 及以上版本建议使用 <code>React.createRef</code> 这个<code>API</code>，低版本使用 <code>回调refs</code>。</li>
<li>函数组件中：为性能考虑，建议都使用 <code>useRef</code> 这个 <code>hook</code>。</li>
</ul>
<h1 id="useContext-Hook"><a href="#useContext-Hook" class="headerlink" title="useContext Hook"></a>useContext Hook</h1><p><code>React 16.3.0</code> 中引入了 <code>Context</code> 系列 <code>API</code>。用于共享那些对于一个组件树而言是 “全局” 的 <code>state</code>。可用于解决 <code>prop drilling</code> 问题。</p>
<p><code>useContext Hook</code> 只是新增了一种方式，让你在函数组件中更方便，更优雅的消费 <code>context</code>:</p>
<pre><code class="language-jsx">//
// 目标子组件 - D
// 使用 context 对象的 Consumer 组件获取共享数据,通过更新函数更新数据
const D = () =&gt; (
  const { value, setValue } = React.useContext(MyContext)
  return (
    &lt;input
      type=&quot;text&quot;
      value={value}
      onChange={e =&gt; {
        setValue(e.target.value);
      }}
    /&gt;
  )
);</code></pre>
<p>可读性更高了，还可很方便的消费多个 <code>context</code>。</p>
<h1 id="UseReducer-Hook"><a href="#UseReducer-Hook" class="headerlink" title="UseReducer Hook"></a>UseReducer Hook</h1><p><code>useReducer hook</code> 用于 <code>React</code> 函数组件中管理<strong>复杂的</strong> <code>state</code> 。它把一个<code>reducer</code>方法，和初始<code>state</code>作为输入，包含当前<code>state</code>，和一个<code>dispatch</code>方法的解构数组作为输出。</p>
<p><code>API</code>（ 对照 <code>useState</code> ）：</p>
<pre><code class="language-js">// useReducer hook API
const [current, dispatch] = useReducer(reducer, initState);

// useState hook API
const [current, setFunc] = useReducer(initState);
</code></pre>
<p>来看一个使用 <code>useReducer</code> 的简单例子：</p>
<pre><code class="language-jsx">const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;:
      return {count: state.count + 1};
    case &#39;decrement&#39;:
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({type: &#39;decrement&#39;})}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({type: &#39;increment&#39;})}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>上述示例中的 <code>state</code> 很简单，其实使用 <code>useState</code> 就可以。那么，我们什么时候该使用 <code>useReducer</code> 呢？</p>
<p>适用于<code>useReducer</code> 的复杂 <code>state</code> 的场景主要有:</p>
<ul>
<li><code>state</code> 逻辑较复杂且包含多个子值（大的对象，数组）。</li>
<li><code>state</code> 更新依赖于之前的 <code>state</code>。</li>
<li><code>state</code> 组件树深层更新。使用<code>useReducer</code>可以向子组件传递 <code>dispatch</code> 而不是回调函数，这样可以优化性能。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ul>
<li><strong>集中管理</strong>：每个组件都有一个 “内存单元” 的内部列表，作为 <code>Hooks</code>管理中心。</li>
<li><strong>just js</strong>：只是 <code>JavaScript</code> 对象 + 闭包。你可以想象它是一个数组（实际上是一个单向链表），我们可以在其中放置一些数据。</li>
<li><strong>顺序调用</strong>：当组件调用 <code>useState()</code> 等 <code>Hook</code> 时，它读取当前单元格(或在第一次呈现时初始化它)，然后将指针(<code>cursor</code>) 移动到下一个单元格。这就是多个 <code>useState()</code> 调用各自获取独立本地<code>state</code>的方式。</li>
</ul>
<img src="/2020/05/24/React-Hooks-%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/react-hooks2.jpg" class="" title="hooks原理">

<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>需要开发者遵从许多规则。理解并合理运用这些规则，能写出优雅的，可读性高的，性能好的代码。反之，很容易出现死循环，数据重复请求等问题。最让人担心的是性能，很多时候业务功能实现了，但是其实存在很多不必要的开销。</p>
<hr>
<p><strong>参考资料</strong><br><a href="http://react.html.cn/docs/hooks-intro.html" target="_blank" rel="noopener">官网-Hooks</a><br><a href="https://www.robinwieruch.de/react-hooks" target="_blank" rel="noopener">What Are React Hooks</a><br><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d#heading-17" target="_blank" rel="noopener">React Hooks 详解 + 项目实战</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/05/13/Nodejs%E5%B7%A5%E5%85%B7-Commander/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/13/Nodejs%E5%B7%A5%E5%85%B7-Commander/" itemprop="url">(Nodejs 开发 cli 工具) - Commander</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-13T11:00:43+08:00">
                2020-05-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Nodejs/" itemprop="url" rel="index">
                    <span itemprop="name">Nodejs</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Nodejs</code> 的出现让前端具备了服务端的能力，还有一个特别重要的用途是用来开发很多提升效率的 <code>CLI</code> 工具，比如初始化项目的 <code>脚手架</code>，项目打包运行的工具库等。<code>CLI</code> 是 <code>Command-Line Interface</code> 的缩写，命令行界面的意思。</p>
<p>基于<code>Nodejs</code>开发<code>CLI</code>工具，首先就离不开 <code>Commander</code> 库。它是  <code>Nodejs</code> 进行 <code>CLI</code> 开发的完整解决方案。</p>
<h1 id="Commander安装"><a href="#Commander安装" class="headerlink" title="Commander安装"></a><code>Commander</code>安装</h1><pre><code class="language-js">
npm install commander@5.0.0
</code></pre>
<blockquote>
<p>注意： 本文基于 <code>commander@5.0.0</code> 版本。</p>
</blockquote>
<h1 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h1><p>常规方式：</p>
<pre><code class="language-js">const program  = require(&#39;commander&#39;);</code></pre>
<p>复杂程序中，<code>Commander</code> 可能通过多样化的方式使用，可以通过创建本地 <code>Commander</code>的方式使用：</p>
<pre><code class="language-js">// 方式A
const Command  = require(&#39;commander&#39;);
const program = new Command();

// 方式B 
// 5.0.0 版本新增
const { createCommand } = require(&#39;commander&#39;);
const program = createCommand();</code></pre>
<h1 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h1><pre><code class="language-js">
const program = require(&#39;commander&#39;);
// 写死版本
program.version(&#39;0.0.1&#39;);
</code></pre>
<pre><code class="language-js">
const program = require(&#39;commander&#39;);
// 动态读取 package 的版本
program.version(require(&#39;../package&#39;).version);
</code></pre>
<blockquote>
<p>可以通过 <code>$ comd-cli -V</code> 显示版本号。</p>
</blockquote>
<h1 id="options"><a href="#options" class="headerlink" title="options"></a>options</h1><p><code>option()</code> 方法用于 定义 <code>Commander</code> 的参数选项 <code>options</code>。</p>
<h2 id="基本API："><a href="#基本API：" class="headerlink" title="基本API："></a>基本API：</h2><pre><code class="language-js">program.option(&#39;-n, -name&#39;, &#39;description&#39;)</code></pre>
<ul>
<li><code>n</code>: 参数名称的短标示（<code>flag</code>），用单个字符表示。</li>
<li><code>name</code>: 参数名称。</li>
<li><code>n</code> 和 <code>name</code>之间除了用 <code>,</code>，还可以用 <code>空格</code> 或者 <code>|</code> 分割。</li>
<li><code>description</code>: 参数描述。</li>
</ul>
<p>示例：</p>
<pre><code class="language-js">const program = require(&#39;commander&#39;);

program
  .option(&#39;-d, --debug&#39;, &#39;debugging&#39;)
  .option(&#39;-s, --small&#39;, &#39;small size&#39;)
  .parse(process.argv);
console.log(program.opts());

//执行日志如下👇
$ comd-cli
 { debug: undefined, small: undefined}
$ comd-cli -d
 { debug: true, small: undefined}
$ comd-cli -ds
 { debug: true, small: true}</code></pre>
<ul>
<li><code>program.opts()</code> 获取命令所有参数信息。</li>
<li>不带对应标示，参数的默认值是 <code>undefined</code>。</li>
<li>带对应标示，参数值为<code>boolean</code>类型 - <code>true</code>。</li>
<li><code>-d -s</code> 可以简写为 <code>-ds</code>。</li>
<li><code>$comd-cli --debug</code> 等同于 <code>$comd-cli -d</code>, 一般都使用更短的标示。</li>
<li>类似 <code>--template-engine</code> 这种命名的名称，会被自动转为驼峰 <code>templateEngine</code>。</li>
</ul>
<blockquote>
<p>后续示例都假定通过 <code>$comd-cli</code> 这个 <code>CLI</code> 执行。</p>
</blockquote>
<h2 id="非-boolean-类型参数"><a href="#非-boolean-类型参数" class="headerlink" title="非 boolean 类型参数"></a>非 <code>boolean</code> 类型参数</h2><p>如果希望参数不是一个 <code>boolean</code> 类型，而是具体的 <code>vaue</code>。可以通过增加 <code>&lt;type&gt;</code> 或者 <code>[type]</code> 实现：</p>
<pre><code class="language-js">const program = require(&#39;commander&#39;);

program
  .option(&#39;-d, --debug &#39;, &#39;if debugging&#39;)
  .option(&#39;-s, --size &lt;type&gt;&#39;, &#39;size type&#39;)
  .option(&#39;-l, --limit [type]&#39;, &#39;file size limit&#39;)
  .parse(process.argv);
console.log(program.opts());

//执行日志如下👇
$ comd-cli -s
 error option &#39;-s, --size &lt;type&gt;&#39; argument missing
$ comd-cli -s small
 { debug: undefined, size: &#39;small&#39;, limit: undefined }
$ comd-cli -l
 { debug: undefined, size: &#39;small&#39;, limit: true }
$ comd-cli -l 1m
 { debug: undefined, size: &#39;small&#39;, limit: &#39;1m&#39; }</code></pre>
<ul>
<li>被 <code>&lt;&gt;</code> 包裹的拓展参数 <code>type</code> 为<strong>必输值</strong>。</li>
<li>被 <code>[]</code> 包裹的拓展参数 <code>type</code> 为<strong>非必输</strong>，默认值为 <code>true</code>。</li>
<li><code>type</code> 是由用户自主命名。</li>
</ul>
<h2 id="自定义默认值"><a href="#自定义默认值" class="headerlink" title="自定义默认值"></a>自定义默认值</h2><p>如前所述，参数的默认值都为 <code>true</code>。你可以在 <code>options()</code> 方法中添加<strong>第三个参数</strong>作为默认值</p>
<pre><code class="language-js">const program  = require(&#39;commander&#39;);

program
  .option(&#39;-d, --debug &#39;, &#39;if debugging&#39;, &#39;&#39;)
  .option(&#39;-s, --size &lt;type&gt;&#39;, &#39;size type&#39;, &#39;smal&#39;)
  .option(&#39;-l, --limit [type]&#39;, &#39;file size limit&#39;, &#39;1M&#39;)
  .parse(process.argv);
console.log(program.opts());

//执行日志如下👇
$ comd-cli 
 { debug: undefined, size: &#39;small&#39;, limit: &#39;1M&#39; }
$ comd-cli -s large
 { debug: undefined, size: &#39;large&#39;, limit: &#39;1M&#39; }</code></pre>
<ul>
<li>对于带拓展 <code>type</code> 的参数，如上例的 <code>size</code> 和 <code>limit</code>，可设置默认值。</li>
<li>无拓展 <code>type</code> 的参数，如上例的 <code>debug</code>，设置默认值无效。</li>
<li>默认值可以是对象，数组等。</li>
</ul>
<h2 id="变更默认值"><a href="#变更默认值" class="headerlink" title="变更默认值"></a>变更默认值</h2><p>可以通过 <code>--no-name</code> 达到修改 <code>name</code> 参数的默认值的效果。</p>
<pre><code class="language-js">const program  = require(&#39;commander&#39;);

program
  .option(&#39;-d, --debug &#39;, &#39;if debugging&#39;)
  .option(&#39;-s, --size &lt;type&gt;&#39;, &#39;size type&#39;, &#39;small&#39;)
  .option(&#39;--no-debug&#39;, &#39;change debug&#39;)
  .option(&#39;--no-size&#39;, &#39;Remove size&#39;)
  .parse(process.argv);
console.log(program.opts());
//执行日志如下👇
$ comd-cli 
 { debug: true, size: true}
$ comd-cli -d
 { debug: false, size: true}
$ comd-cli -s big
 { debug: false, size: &#39;big&#39;}
$ comd-cli --no-debug
 { debug: false, size: true}
$ comd-cli --no-size
 { debug: false, size: undefined}</code></pre>
<ul>
<li><code>--no-name</code> 参数会把 <code>name</code> 命名的参数的默认值变为 <code>true</code>，不管它是 <code>boolean</code> 还是 <code>value</code>。</li>
<li>命令带 <code>--no-name</code> 参数执行，<code>boolean</code> 类型的 <code>name</code> 会变成 <code>false</code>，<code>value</code> 值会变成<code>undefined</code>。</li>
</ul>
<h2 id="自定义option处理"><a href="#自定义option处理" class="headerlink" title="自定义option处理"></a>自定义option处理</h2><p>当 <code>option()</code> 方法的第三个参数是一个函数（回调函数）的时候，该函数会自动对参数值做处理。</p>
<pre><code class="language-js">const program  = require(&#39;commander&#39;);

const func = (dummyValue, previous) =&gt; {
  console.log(`dummyValue: ${dummyValue} ; previous: ${previous}`);
  return dummyValue.split(&#39;,&#39;)
}

program
  .option(&#39;-d, --debug &#39;, &#39;if debugging&#39;)
  .option(&#39;-s, --size [type]&#39;, &#39;size type&#39;,func,[&#39;1&#39;])
  .parse(process.argv);
console.log(program.opts());

//执行日志如下👇
$ comd-cli -s 2,3,4
  dummyValue: 2,3,4 ; previous: 1
  { debug: undefined, size: [ &#39;2&#39;, &#39;3&#39;, &#39;4&#39; ] }
</code></pre>
<ul>
<li>这个时候，默认值可做为 <code>option()</code> 方法的第四个参数。</li>
<li>回调函数参数：<code>dummyValue</code> 用户指定的值; <code>previous</code>: 当前值，上述示例是默认值。</li>
<li>回调函数返回值作为 <code>option</code> 最新值。</li>
</ul>
<h2 id="必需参数"><a href="#必需参数" class="headerlink" title="必需参数"></a>必需参数</h2><p>如果一个命令行必须有某个参数才可以执行，可以通过 <code>requiredOption()</code> 方法处理。</p>
<pre><code class="language-js">const { program } = require(&#39;commander&#39;);

program
  .option(&#39;-d, --debug &#39;, &#39;if debugging&#39;)
  .requiredOption(&#39;-s, --size &lt;type&gt;&#39;, &#39;size type&#39;);
  .parse(process.argv);

//执行日志如下👇
$ comd-cli
  error: required option &#39;-s, --size &lt;type&gt;&#39; not specified </code></pre>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>你可以使用 <code>--</code> 来表示选项的结束，剩余的参数将被使用而不会被解释。这对于将选项传递给另一条命令特别有用。</p>
<pre><code class="language-js">const program  = require(&#39;commander&#39;);
console.log(process.argv);
program
  .option(&#39;-d, --debug &#39;, &#39;if debugging&#39;)
  .option(&#39;-s, --size [type]&#39;, &#39;size type&#39;,&#39;small&#39;)
  .parse(process.argv);
console.log(program.opts());
console.log(program.args);

//执行日志如下👇
$ comd-cli -d -- -s big git react 
 { debug: true, size: &#39;small&#39; }
 [ &#39;-s&#39;, &#39;big&#39;, &#39;git&#39;, &#39;react&#39; ]</code></pre>
<ul>
<li>注意，<code>--</code> 后面的 <code>-s big</code> 便不会被 <code>option</code> 处理。</li>
<li>一般，我们通过 <code>parse(process.argv)</code> 方法把其他没有被 <code>options</code> 处理的参数变为 <code>program.args</code> 对象使用。</li>
</ul>
<h1 id="Commands"><a href="#Commands" class="headerlink" title="Commands"></a>Commands</h1><p><code>Commander</code> 提供了两种用于添加命令的方式，分别对应一下两个 <code>API</code>:</p>
<ul>
<li><code>command()</code>: 通过用户自己定义命令名称，和一些命令参数来添加一个命令。</li>
<li><code>addCommand()</code>: 用于添加一个已经初始化好的子命令。复杂场景下，往往会定义一个方法来生成命令，就需要使用该方式。</li>
</ul>
<p>其实，用 <code>addCommand()</code> 添加的子命令，也是通过 <code>command()</code> 方式初始化的。</p>
<blockquote>
<p><code>addCommand()</code> 方式是在 <code>5.0.0</code> 版本才引入的。</p>
</blockquote>
<p>命令的执行也有两种方式:</p>
<ul>
<li>给命令添加一个 <code>action</code> 事件处理程序。需要<code>5.0.0</code>及以上版本</li>
<li>通过一个单独的可执行文件。</li>
</ul>
<p>下面，我们通过以下三种情况来了解：</p>
<ul>
<li><code>command()</code>+ <code>action handler</code></li>
<li><code>command()</code>+ 可执行文件</li>
<li><code>addCommand()</code> 使用示例</li>
</ul>
<h2 id="command-action-handler"><a href="#command-action-handler" class="headerlink" title="command()+ action handler"></a><code>command()</code>+ <code>action handler</code></h2><p>一定注意，<code>5.0.0</code>及以上版本才支持的方式：</p>
<pre><code class="language-js">program
  .command(&#39;clone &lt;required&gt; [optional]&#39;)
  .alise(&#39;c&#39;)
  .useage(&#39;&lt;command&gt; &lt;fileName&gt;&#39;)
  .desciption(&#39;clone command descption&#39;)
  .action((required, optional) =&gt; {
    console.log(&#39;command called&#39;)
  })

//执行日志如下👇
$ comd-cli clone fileName
  command called
</code></pre>
<ul>
<li><code>clone</code>:  命令名称。</li>
<li><code>required</code>: 必须参数。</li>
<li><code>optional</code>: 其他可选参数。</li>
<li><code>alise(&#39;c&#39;)</code>: 给命令一个简短的别名 <code>c</code>。</li>
<li><code>usage()</code>: 命令的使用格式。使用 <code>--help</code> 会显示。</li>
<li><code>desciption()</code>: 设置命令描述信息。</li>
<li><code>action(handler)</code>: 命令执行程序，<code>handler</code> 是一个回调函数，可以获取到命令参数。</li>
</ul>
<h2 id="command-可执行文件"><a href="#command-可执行文件" class="headerlink" title="command()+ 可执行文件"></a><code>command()</code>+ 可执行文件</h2><p>这种方式是早期版本便一直支持的方式：</p>
<pre><code class="language-js">// 假设该入口脚本文件目录为：example/comdCli.js
program
  .command(&#39;clone &lt;required&gt; [optional]&#39;,&#39;clone command descption&#39;)
  .alise(&#39;c&#39;)

//执行日志如下👇
$ comdCli clone fileA
  Error: &#39;comdCli-clone&#39; does not exist
</code></pre>
<ul>
<li>命令描述作为 <code>command()</code> 方法的第二个参数。这个时候就会通过可执行文件执行命令。</li>
<li><code>Commander</code> 会自动使用 <code>program-subCommand</code>（上例中是 <code>comdCli-clone</code> ） 的名字搜索入口脚本文件目录下的可执行文件来执行子命令。</li>
<li>不需要 <code>description</code> 和 <code>action</code>。<code>usage</code> 和 <code>alise</code>同上。</li>
</ul>
<h1 id="addCommand-使用示例"><a href="#addCommand-使用示例" class="headerlink" title="addCommand() 使用示例"></a><code>addCommand()</code> 使用示例</h1><p><code>addCommand()</code> 只是 <code>5.0.0</code> 版本增加的一个用于增加一个已经初始化好的子命令到 <code>program</code> 的方法：</p>
<pre><code class="language-js">const Command  = require(&#39;commander&#39;);
const program = new Command();
program
  .command(&#39;tea&#39;)
  .action(() =&gt; {
    console.log(&#39;brew tea&#39;);
  });
function makeHeatCommand() {
  const heat = new Command();
  heat
    .command(&#39;jug&#39;)
    .action(() =&gt; {
      console.log(&#39;heat jug&#39;);
    });
  return heat;
}
// 看这里
program.addCommand(makeHeatCommand());
program.parse(process.argv);
</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://github.com/tj/commander.js/" target="_blank" rel="noopener">gitHub-commander</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/05/09/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%BA%94%EF%BC%89-useReducer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/05/09/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%BA%94%EF%BC%89-useReducer/" itemprop="url">拥抱React-Hooks (五) - useReducer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-05-09T10:15:10+08:00">
                2020-05-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Redux-基础"><a href="#Redux-基础" class="headerlink" title="Redux 基础"></a>Redux 基础</h1><hr>
<p>我们都知道，像 <code>React</code> 框架，本地 <code>state</code> 是交给用户自己打理的，它们分散在组件树中，并随着数据的流动而相互影响。随着应用的复杂性提升，<code>state</code> 也会越来越复杂。很容易就陷入 <code>state</code>难管理，逻辑难追踪，应用难维护的境地。</p>
<p><code>Redux</code> 的出现就是为了解决以上的问题。目标是让 <code>state</code> 可维护，可预测，可持续。<br><code>Redux</code> 原理很简单，它就是 <code>Javascript + 设计模式（思想）</code>。其设计模式也非常简单，可总结为：</p>
<p>三原则</p>
<ul>
<li>单一数据源 <code>store</code> 用来存储 <code>state</code></li>
<li><code>state</code> 只读，只能通过 <code>action</code>修改</li>
<li>使用纯函数执行 <code>state</code> 修改，需要编写 <code>reducers</code></li>
</ul>
<p>对应三要素：</p>
<ul>
<li><code>Store</code> 数据集中存储的容器。</li>
<li><code>Action</code> 含有<code>type</code>属性的一个对象，修改数据的唯一途径，它会运送数据到 <code>Store</code>。</li>
<li><code>Reducer</code> 一个纯函数，接受当前 <code>State</code> 和 <code>Action</code> 作为参数，返回一个新的 <code>State</code>。</li>
</ul>
<p><code>Store</code> 三方法：</p>
<ul>
<li><code>store.getState()</code>: 获取当前 <code>state</code></li>
<li><code>store.dispatch(action)</code>: <code>View</code> 发出 <code>Action</code> 的唯一方法。</li>
<li><code>store.subscribe(func)</code>: 订阅方法，当 <code>state</code> 改变，会触发 <code>func</code> 重新执行。</li>
</ul>
<p>在<code>React</code>中应用<code>Redux</code>的大致流程图：</p>
<img src="/2020/05/09/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%BA%94%EF%BC%89-useReducer/redux+react.jpg" class="" title="react + redux">

<p>在 <code>React</code> 中使用 <code>Redux</code> 的代码示例：</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
import ReactDOM from &quot;react-dom&quot;;
import { createStore } from &quot;redux&quot;;

// 创建reducer纯函数计算state
const reducer = (state = 0, action) =&gt; {
  switch (action.type) {
    case &quot;INCREMENT&quot;:
      return state + 1;
    case &quot;DECREMENT&quot;:
      return state - 1;
    default:
      return state;
  }
};
// 使用 createStore 方法创建 store，参数为 reducer
// 多个reducer的情况下 应该有一个reducer工厂方法
const store = createStore(reducer);

const rootElement = document.getElementById(&quot;root&quot;);
const render = () =&gt; {
  // 使用 getState 方法 获取state
  const count = store.getState();
  // 使用 dispatch 方法 发送 Action 触发state修改
  const INCREMENT = () =&gt; {
    store.dispatch({ type: &quot;INCREMENT&quot; });
  };
  const DECREMENT = () =&gt; {
    store.dispatch({ type: &quot;INCREMENT&quot; });
  };
  ReactDOM.render(
    &lt;React.StrictMode&gt;
      &lt;div&gt;
        &lt;h1&gt;{count}&lt;/h1&gt;
        &lt;button onClick={INCREMENT}&gt;+&lt;/button&gt;
        &lt;button onClick={DECREMENT}&gt;-&lt;/button&gt;
    &lt;/div&gt;
    &lt;/React.StrictMode&gt;,
    rootElement
  );
};
render();
// 通过 subscribe 方法 关联 store 和 App 组件
// 当 state 改变 触发组件重新渲染
store.subscribe(render);
</code></pre>
<hr>
<h1 id="UseReducer-Hook"><a href="#UseReducer-Hook" class="headerlink" title="UseReducer Hook"></a>UseReducer Hook</h1><hr>
<p><code>useReducer hook</code> 用于 <code>React</code> 函数组件中管理<strong>复杂的</strong> <code>state</code> 。它把一个<code>reducer</code>方法，和初始<code>state</code>作为输入，包含当前 <code>state</code>，和一个 <code>dispatch</code> 方法的 解构数组 作为输出。</p>
<p><code>API</code>（ 对照 <code>useState</code> ）：</p>
<pre><code class="language-js">// useReducer hook API
const [current, dispatch] = useReducer(reducer, initState);

// useState hook API
const [current, setFunc] = useReducer(initState);
</code></pre>
<ul>
<li><code>reducer</code> 用于改变 <code>state</code> 的 <code>reducer</code> 函数，同 <code>Redux</code>。</li>
<li><code>initState</code>  初始<code>state</code>。</li>
<li><code>current</code> 当前<code>state</code>。</li>
<li><code>dispatch</code> 负责传递一个 <code>action</code> 给 <code>reducer</code> 函数，以此改变当前 <code>state</code>。</li>
</ul>
<p>和 <code>useState</code> 相比，<code>useReducer</code> 多一个<code>reducer</code> 函数。<code>reducer</code> 函数通过 <code>dispatch</code> 传递的 <code>action</code>执行不同的<code>state</code>修改操作。</p>
<p>和<code>redux</code>相比，用户无需关心 <code>store</code> 对象。另外 <code>state</code> 改变，组件会自动触发重新渲染。</p>
<p>来看一个使用 <code>useReducer</code> 的简单例子：</p>
<pre><code class="language-jsx">const initialState = {count: 0};

function reducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;:
      return {count: state.count + 1};
    case &#39;decrement&#39;:
      return {count: state.count - 1};
    default:
      throw new Error();
  }
}

function Counter() {
  const [state, dispatch] = useReducer(reducer, initialState);
  return (
    &lt;&gt;
      Count: {state.count}
      &lt;button onClick={() =&gt; dispatch({type: &#39;decrement&#39;})}&gt;-&lt;/button&gt;
      &lt;button onClick={() =&gt; dispatch({type: &#39;increment&#39;})}&gt;+&lt;/button&gt;
    &lt;/&gt;
  );
}
</code></pre>
<p>上述示例中的 <code>state</code> 很简单，其实使用 <code>useState</code> 就可以。那么，我们什么时候该使用 <code>useReducer</code> 呢？</p>
<hr>
<h1 id="useReducer-适用场景"><a href="#useReducer-适用场景" class="headerlink" title="useReducer 适用场景"></a>useReducer 适用场景</h1><hr>
<p>我们先来看看和 <code>state</code> 管理相关的三大 <code>Hooks</code> 定位：</p>
<ul>
<li><code>useState</code>: 简单 <code>State</code></li>
<li><code>useReducer</code>: 复杂 <code>State</code></li>
<li><code>useContext</code>: 全局 <code>State</code></li>
</ul>
<p>适用于<code>useReducer</code> 的复杂 <code>state</code> 的场景主要有:</p>
<ul>
<li><code>state</code> 逻辑较复杂且包含多个子值（大的对象，数组）。</li>
<li><code>state</code> 更新依赖于之前的 <code>state</code>。</li>
<li><code>state</code> 组件树深层更新。使用<code>useReducer</code>可以向子组件传递 <code>dispatch</code> 而不是回调函数，这样可以优化性能。</li>
</ul>
<p>相对于 <code>useState</code>， <code>useReducer</code>只是略复杂。所以当 <code>state</code> 有一定复杂度，便可以大胆使用 <code>useReducer</code>。我们更多的不是纠结要不要使用 <code>useReducer</code>，而是怎么用好 <code>useReducer</code>。</p>
<p>比如上面的代码示例中，<code>reducer</code> 函数可以优化一下，使其可持续发展：</p>
<pre><code class="language-jsx">...
// 用好`useReducer`的关键 - reducer 函数
function reducer(state, action) {
  switch (action.type) {
    case &#39;increment&#39;:
      return {...state, { count: state.count + 1} }; // 看这里
    case &#39;decrement&#39;:
      return {...state, { count: state.count - 1} }; // 看这里
    default:
      throw new Error();
  }
}
...
</code></pre>
<p>这样改写的原因是，随着组件复杂度提升，<code>state</code> 对象会扩展其他属性，而不仅有 <code>count</code>。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="http://www.ruanyifeng.com/blog/2016/09/redux_tutorial_part_one_basic_usages.html" target="_blank" rel="noopener">Redux 入门教程（一）</a><br><a href="https://cn.redux.js.org" target="_blank" rel="noopener">Redux 中文网</a><br><a href="https://www.robinwieruch.de/javascript-reducer" target="_blank" rel="noopener">What is a Reducer in JavaScript/React/Redux?</a><br><a href="https://www.robinwieruch.de/react-usereducer-hook" target="_blank" rel="noopener">How to useReducer in React</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/04/16/React-%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%AE%80%E7%95%A5%E8%AF%AD%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/16/React-%E7%B1%BB%E7%BB%84%E4%BB%B6%E7%AE%80%E7%95%A5%E8%AF%AD%E6%B3%95/" itemprop="url">React 类组件简略语法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-16T15:05:54+08:00">
                2020-04-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常规标准语法"><a href="#常规标准语法" class="headerlink" title="常规标准语法"></a>常规标准语法</h1><hr>
<pre><code class="language-jsx">class Counter extends Component {
  constructor(props) {
    super(props);
    this.state = {
      counter: 0,
    };
    this.onIncrement = this.onIncrement.bind(this);
    this.onDecrement = this.onDecrement.bind(this);
  }
  onIncrement() {
    this.setState(state =&gt; ({ counter: state.counter + 1 }));
  }
  onDecrement() {
    this.setState(state =&gt; ({ counter: state.counter - 1 }));
  }
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;{this.state.counter}&lt;/p&gt;
        &lt;button
          onClick={this.onIncrement}
          type=&quot;button&quot;
        &gt;
          Increment
        &lt;/button&gt;
        &lt;button
          onClick={this.onDecrement}
          type=&quot;button&quot;
        &gt;
          Decrement
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<h1 id="简略语法"><a href="#简略语法" class="headerlink" title="简略语法"></a>简略语法</h1><hr>
<ul>
<li><code>Arrow Function</code> 实现 <code>auto-bind</code> 。</li>
<li>类属性( <code>class properties</code> ) 简化构造函数。</li>
</ul>
<pre><code class="language-jsx">class Counter extends Component {
  state = {
    counter: 0,
  };
  onIncrement = () =&gt; {
    this.setState(state =&gt; ({ counter: state.counter + 1 }));
  }
  onDecrement = () =&gt; {
    this.setState(state =&gt; ({ counter: state.counter - 1 }));
  }
  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;{this.state.counter}&lt;/p&gt;
        &lt;button
          onClick={this.onIncrement}
          type=&quot;button&quot;
        &gt;
          Increment
        &lt;/button&gt;
        &lt;button
          onClick={this.onDecrement}
          type=&quot;button&quot;
        &gt;
          Decrement
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<blockquote>
<p>类属性尚在提案阶段，需要引入专门的<a href="https://babeljs.io/docs/en/babel-plugin-transform-class-properties/" target="_blank" rel="noopener">babel插件</a>处理。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/04/13/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/13/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E5%9B%9B%EF%BC%89-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" itemprop="url">拥抱React-Hooks（四）- 性能优化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-13T21:28:45+08:00">
                2020-04-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="ReRender-问题"><a href="#ReRender-问题" class="headerlink" title="ReRender 问题"></a>ReRender 问题</h1><hr>
<p>在 <code>React</code> 组件树中，组件重新渲染的情况主要有以下几种：</p>
<ul>
<li>当组件的 <code>state</code> 或者 <code>props</code> 发生变化，会触发组件的重新渲染。</li>
<li>类组件中，当 <code>setState</code> 调用后，组件的 <code>render</code> 方法也会自动调用，并且会嵌套渲染所有子组件。</li>
<li>函数组件中，使用 <code>useState</code>，<code>state</code> 改变导致组件重新渲染时，也会嵌套渲染所有子组件。</li>
</ul>
<p>上述特性暴露出 <code>React</code> 一个典型的性能问题 - <code>reRender</code> 问题。确切的说，是子组件不必要的 <code>reRender</code> 问题。</p>
<blockquote>
<p><code>Context</code> 中 <code>Provider</code> 的 <code>value</code> 值改变以后，所有对应的 <code>Consumer</code> 组件也会重新渲染。不过没有<code>reRender</code> 问题。</p>
</blockquote>
<h1 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h1><hr>
<p><code>reRender</code> 问题是问题么，<code>React</code> 不是有 <code>diff</code> 算法么？我之前也有这个误解。<br>我们可以把重新渲染过程分为两个阶段：</p>
<ul>
<li>阶段一：重新渲染，生成新的虚拟 <code>Dom</code> 树。<code>reRender</code> 问题发生在这个阶段。</li>
<li>阶段二：通过对比新旧虚拟 <code>Dom</code> 树。如有差异，更新真实 <code>Dom</code>。<code>diff</code> 算法作用于这个阶段。</li>
</ul>
<p>虽然不必要的 <code>reRender</code> 在 <code>diff</code> 的时候没有差异，所以不会更新真实 <code>Dom</code>。但是生成新的虚拟<code>Dom</code>，进行<code>diff</code>计算本身就消耗很多性能。</p>
<h1 id="shouldComponentUpdate"><a href="#shouldComponentUpdate" class="headerlink" title="shouldComponentUpdate"></a>shouldComponentUpdate</h1><hr>
<p>在类组件中，我们一般通过 <code>shouldComponentUpdate</code> 生命周期来阻止 <code>reRender</code> 。<br><code>shouldComponentUpdate</code> 函数在重渲染时，会在 <code>render()</code> 函数调用前被调用，它接受两个参数：<code>nextProps</code>和<code>nextState</code>，分别表示下一个<code>props</code>和下一个<code>state</code>的值。并且，当函数返回<code>false</code>时候，阻止接下来的<code>render()</code>函数的调用，阻止组件重新渲染，而返回<code>true</code>时，组件照常重新渲染。</p>
<pre><code class="language-jsx">class Square extends Component {
  shouldComponentUpdate(nextProps, nextState) {
    if (this.props.number === nextProps.number) {
      return false;
    } else {
      return true;
    }
  }
  render() {
    return &lt;Item&gt;{this.props.number * this.props.number}&lt;/Item&gt;;
  }
}</code></pre>
<p>实际项目中，要考虑对象引用，复杂数据结构在 <code>===</code> 时候的坑。浅比较可能对比不出深层差异，深比较本身性能消耗也较大。要仔细权衡。</p>
<p>如果你不关心具体数据的变更，想对 <code>props</code> 和 <code>state</code> 整体对比的常规写法如下：</p>
<pre><code class="language-jsx">shouldComponentUpdate(nextProps, nextState) {
  if (this.props === nextProps &amp;&amp; this.state === nextState) {
    return false;
  } else {
    return true;
  }
}</code></pre>
<p> 这个时候，你可以考虑使用 <code>PurComponent</code>。</p>
<h1 id="React-PurComponent"><a href="#React-PurComponent" class="headerlink" title="React.PurComponent"></a>React.PurComponent</h1><p><code>React.PurComponent</code> “纯”组件，是自带 <code>shouldComponentUpdate</code> 生命周期函数实现的组件。它会在组件重新渲染的时候对 新旧 <code>state</code> 和 <code>props</code> 整体做浅层比较。如果都相等，就阻止重新渲染。 </p>
<pre><code class="language-jsx">// PurComponent 实现源码
if (this._compositeType === CompositeTypes.PureClass) {
  shouldUpdate = !shallowEqual(prevProps, nextProps) || ! shallowEqual(inst.state, nextState);
}
// shallowEqual 源码
const hasOwn = Object.prototype.hasOwnProperty
function is(x, y) {
  if (x === y) {
    return x !== 0 || y !== 0 || 1 / x === 1 / y
  } else {
    return x !== x &amp;&amp; y !== y
  }
}

export default function shallowEqual(objA, objB) {
  //在 === 基础上 修复了 NaN 和 +-0 的情况
  if (is(objA, objB)) return true

  if (typeof objA !== &#39;object&#39; || objA === null ||
      typeof objB !== &#39;object&#39; || objB === null) {
    return false
  }

  const keysA = Object.keys(objA)
  const keysB = Object.keys(objB)

  if (keysA.length !== keysB.length) return false

  for (let i = 0; i &lt; keysA.length; i++) {
    if (!hasOwn.call(objB, keysA[i]) ||
        !is(objA[keysA[i]], objB[keysA[i]])) {
      return false
    }
  }

  return true
}</code></pre>
<p>因为是浅层比较，一些不合理的写法，会导致 <code>PurComponent</code>中 <code>shallowEqual</code> 无法找出差异。</p>
<p>看下面代码：</p>
<pre><code class="language-jsx">const newObj = this.state.obj;
newObj.id = 1;
this.setState({
  obj: newObj
})</code></pre>
<p><code>newObj</code> 和 <code>obj</code> 指向同一个引用地址，<code>shallowEqual</code> 比较结果是 <code>true</code> 阻止了重新渲染。正确的书写方式是通过 <code>clone</code>来定义<code>newObj</code>。</p>
<p>另外，因为是浅层比较，对于复杂数据结构，不建议使用 <code>PurComponent</code>。<br><code>PurComponent</code> 并不等于高性能，对于 <code>props</code> 经常改变的组件，<code>PurComponent</code> 频繁比较，反而性能会降低。</p>
<h1 id="React-memo"><a href="#React-memo" class="headerlink" title="React.memo"></a>React.memo</h1><hr>
<p><code>React.memo</code> 为高阶组件。它与 <code>React.PureComponent</code> 非常相似，但只适用于函数组件，而不适用类组件。<br><code>React.memo</code> 仅检查 <code>props</code> 变更。如果函数组件被 <code>React.memo</code> 包裹。其内部使用了 <code>useState</code> 或 <code>useContext</code>。当 <code>state</code> , <code>context</code> 发生变化时，它仍会重新渲染。</p>
<p>默认情况下其只会对复杂对象做浅层对比，如果你想要控制对比过程，那么请将自定义的比较函数通过第二个参数传入来实现。</p>
<pre><code class="language-jsx">function MyComponent(props) {
  /* 使用 props 渲染 */
}
function areEqual(prevProps, nextProps) {
  /*
  如果把 nextProps 传入 render 方法的返回结果与
  将 prevProps 传入 render 方法的返回结果一致则返回 true，
  否则返回 false
  */
}
export default React.memo(MyComponent, areEqual);</code></pre>
<h1 id="useCallback-Hook"><a href="#useCallback-Hook" class="headerlink" title="useCallback Hook"></a>useCallback Hook</h1><hr>
<p>在函数组件中，我们经常会创建很多函数。还会把函数作为子组件的参数向下传递。那么当组件 <code>reRender</code> 的时候，这些函数每次都会重新定义。</p>
<p>所以我们会有这样的误解：这会不会很消耗性能，是不是应该缓存下来？而 <code>useCallback</code> 的功能就是在函数组件中做函数的缓存来优化性能。</p>
<p>所以很多人陷入一个误区：对于会频繁 <code>reRender</code> 的函数组件，我们定义的函数都应该使用 <code>useCallback</code> 来缓存下来，避免反复定义。</p>
<ul>
<li>一方面，官方文档也指出，在现代浏览器中，创建函数和闭包的性能消耗，只有在个别极端情况下才会有明显差异。* 另一方面，在 <code>javascript</code> 中，当组件刷新时，未被 <code>useCallback</code> 包裹的函数将被垃圾回收并重新定义，但被 <code>useCallback</code> 所制造的闭包将保持对回调函数和依赖项的引用，不利于垃圾回收。用的越多，反而负担越重。</li>
</ul>
<p><code>useCallback</code> 正确的用法是配合 <code>React.memo</code> 来避免渲染成本较高的子组件非必要 <code>reRender</code> 问题。比如这样一个典型的场景：</p>
<pre><code class="language-jsx">import React, { useState } from &#39;react&#39;;

const  FatherComp = () =&gt; {
  const [dataA, setDataA] = useState(0);
  const [dataB, setDataB] = useState(0);

  const onClickA = () =&gt; {
      setDataA(o =&gt; o + 1);
  };

  const onClickB = () =&gt; {
      setDataB(o =&gt; o + 1);
  }

  return (
    &lt;div&gt;
      &lt;A data= {dataA} onClick={(onClickA)}/&gt;
      &lt;B data= {dataB} onClick={(onClickB)}/&gt;
    &lt;/div&gt;
  )
}
export default FatherComp;</code></pre>
<p>父组件 <code>FatherComp</code> 中有2个受控子组件，其中组件 <code>A</code> 交互频繁，而导致父组件频繁 <code>reRender</code>。子组件 <code>B</code> 也因此频繁进行不必要的 <code>reRender</code>。如果 <code>B</code> 是一个渲染成本非常高的组件，那就得优化其不必要<code>reRender</code> 的问题。</p>
<p>这个时候，你只是用 <code>React.memo</code> 包裹 <code>B</code> 组件是没有办法阻止其重新渲染的，因为每次 <code>onClickB</code> 都是重新定义的，<code>B</code> 组件的 <code>props</code> 是改变的。这个时候就需要 <code>useCallback</code> 来包裹 <code>onClickB</code> 来达到阻止的效果。</p>
<pre><code class="language-jsx">import React, { useState } from &#39;react&#39;;

const  FatherComp = () =&gt; {
  const [dataA, setDataA] = useState(0);
  const [dataB, setDataB] = useState(0);

  const onClickA = () =&gt; {
    setDataA(o =&gt; o + 1);
  };

  const onClickB = useCallback(() =&gt; {
    setDataB(o =&gt; o + 1);
  },[])

  return (
    &lt;div&gt;
      &lt;A data= {dataA} onClick={(onClickA)}/&gt;
      &lt;MemoB data= {dataB} onClick={(onClickB)}/&gt;
    &lt;/div&gt;
  )
}

const MemoB =  React.memo(B);

export default FatherComp;</code></pre>
<p>我们抽象 <code>useCallback</code> 的API为：<code>const memoFun = useCallback(arrFun, depsArr)</code>;</p>
<ul>
<li>arrFun: 必须，是一个函数，首次渲染时，会赋给 <code>memoFun</code> 并缓存。</li>
<li>depsArr：可为空，依赖项，更新渲染时：<ul>
<li>依赖项没有变化，会直接将上次缓存的 <code>arrFun</code> 赋给 <code>memoFun</code>（<code>memoFun</code> 没有变）。</li>
<li>依赖项发生变化，会重新声明一个 <code>arrFun</code> 赋给 <code>memoFun</code>（<code>memoFun</code> 改变了）。</li>
</ul>
</li>
</ul>
<h1 id="useMemo-Hook"><a href="#useMemo-Hook" class="headerlink" title="useMemo Hook"></a>useMemo Hook</h1><hr>
<p><code>useMemo</code> 这个 <code>Hook</code>，用于函数组件重新渲染时，阻止无用方法的调用（无需重新调用），尤其一些高开销的计算逻辑。它用于局部优化，而不是阻止整个组件 <code>Rerender</code>。</p>
<pre><code class="language-jsx">import React, { useMemo, useState } from &#39;react&#39;

export default function UseMemoPage() {

    const [count, setCount] = useState(0)
    const [value, setValue] = useState(&quot;&quot;)

    //-----------当前的计算只和count有关------
    const expensive = useMemo(() =&gt; {
        console.log(&quot;compute&quot;);
        let sum = 0;
        for (let i = 0; i &lt; count; i++) {
            sum += i
        }
        return sum;
        // 只有 count 发生改变的时候，才执行这个方法
    }, [count])
    //-------------重点！！局部优化---------

    return (
        &lt;div&gt;
            &lt;h3&gt;UseMemo&lt;/h3&gt;
            &lt;p&gt;count：{count}&lt;/p&gt;
            &lt;p&gt;expensive:{expensive}&lt;/p&gt;
            &lt;button onClick={() =&gt; setCount(count + 1)}&gt;add&lt;/button&gt;
            &lt;input value={value} onChange={event =&gt; setValue(event.target.value)} /&gt;
        &lt;/div&gt;
    )
}</code></pre>
<p>把 <strong>局部高开销计算封装成一个函数</strong> , 和 依赖项数组 一起作为参数传入 <code>useMemo</code>，返回一个 <code>memoized</code> 值 。重新渲染时，它仅会在某个依赖项改变时才重新调用函数计算 <code>memoized</code> 值。</p>
<ul>
<li><p>传入 <code>useMemo</code> 的函数会在渲染期间执行。请不要在这个函数内部执行与渲染无关的操作，诸如副作用这类的操作属于 <code>useEffect</code> 的适用范畴，而不是 <code>useMemo</code>。</p>
</li>
<li><p>所有计算函数中引用的值都应该出现在依赖项数组中。如果没有提供依赖项数组，<code>useMemo</code> 在每次渲染时都会计算新的值，便没有任何意义。</p>
</li>
<li><p>依赖项数组不会作为参数传给计算函数。</p>
</li>
<li><p>保险起见，先编写在没有 <code>useMemo</code> 的情况下也可以执行的代码。之后再在你的代码中添加 <code>useMemo</code>，以达到优化性能的目的。</p>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><hr>
<ul>
<li><code>shouldComponentUpdate</code>生命周期 和 <code>React.PurComponent</code> 用于类组件优化 <code>reRender</code>。</li>
<li><code>React.memo</code> 和 <code>useCallback</code> 用于函数组件优化 <code>reRender</code>性能问题。适用于组件树中父组件交互频繁，而自身 <code>props</code> 较少修改而渲染消耗较大的子组件。</li>
<li><code>useMemo</code>用于局部包含复杂计算逻辑方法优化，相对其他<code>API</code>，更灵活，更放心。</li>
<li>以上 <code>API</code> 本身存在额外性能消耗。所以很多时候，<code>reRender</code> 问题不一定要优化。</li>
<li>别不小心阻止了必要<code>reRender</code>的情况。</li>
</ul>
<hr>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr>
<p><a href="https://zh-hans.reactjs.org/docs/react-api.html#reactpurecomponent" target="_blank" rel="noopener">官网-purecomponent</a><br><a href="https://juejin.im/post/5c9472085188252d6a08731a" target="_blank" rel="noopener">React 渲染优化</a><br><a href="https://www.robinwieruch.de/react-prevent-rerender-component/" target="_blank" rel="noopener">React rerender component</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/04/09/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%B8%89%EF%BC%89-Context/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/04/09/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%B8%89%EF%BC%89-Context/" itemprop="url">拥抱React-Hooks（三）- useContext</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-04-09T14:22:43+08:00">
                2020-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Prop-Drilling-问题"><a href="#Prop-Drilling-问题" class="headerlink" title="Prop Drilling 问题"></a>Prop Drilling 问题</h1><hr>
<ul>
<li>当 <code>React</code> 应用趋于复杂，往往会形成深层组件树。</li>
<li>父子组件通过 <code>props</code> 传递参数来通信。</li>
<li><code>React</code> 是单向数据流。</li>
</ul>
<p>基于上述三点，就容易产生这样的问题：父组件要逐层把一些 <code>props</code> 传递给目标子组件，而中间子组件并不关心这些<code>props</code>，却要负责透传这些 <code>props</code> ，还要确保中间不出问题。</p>
<p>这就是 <code>React</code> 中 <code>Prop Drilling</code> 问题。</p>
<pre><code class="language-jsx">          +----------------+
          |                |
          |        A       |
          |        |Props  |
          |        v       |
          |                |
          +--------+-------+
                   |
         +---------+-----------+
         |                     |
         |                     |
+--------+-------+    +--------+-------+
|                |    |                |
|                |    |        +       |
|       B        |    |        |Props  |
|                |    |        v       |
|                |    |                |
+----------------+    +--------+-------+
                               |
                      +--------+-------+
                      |                |
                      |        +       |
                      |        |Props  |
                      |        v       |
                      |                |
                      +--------+-------+
                               |
                      +--------+-------+
                      |                |
                      |        +       |
                      |        |Props  |
                      |        C       |
                      |                |
                      +----------------+</code></pre>
<hr>
<h1 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h1><hr>
<p><code>React 16.3.0</code> 中引入了 <code>Context</code> 系列 <code>API</code>。用于共享那些对于一个组件树而言是 “全局” 的 <code>state</code>。可用于解决 <code>prop drilling</code> 问题。但会导致组件复用性降低，忌滥用。</p>
<p><code>Context</code> 的设计基于 <code>Provider-Consumer</code> 模式，包含一系列 <code>API</code>。</p>
<h2 id="基础-API"><a href="#基础-API" class="headerlink" title="基础 API"></a>基础 API</h2><ul>
<li><code>React.createContext(defaultValue)</code> : 创建一个 <code>Context</code> 对象。</li>
<li><code>Context.Provider</code> : 你创建的 <code>Context</code> 对象的组件，用于 初始化 共享数据的组件。</li>
<li><code>Context.Consumer</code>: 你创建的 <code>Context</code> 对象的组件，用于 获取 共享数据的组件。</li>
</ul>
<p>我们来通过示例来看一下这些 <code>API</code> ：</p>
<pre><code class="language-jsx">// ./MyContext.jsx
import React from &quot;react&quot;;
// 创建 context 对象
const MyContext = React.createContext(&quot;hello&quot;);
// Devtools 中显示用
MyContext.displayName = &#39;MyDisplayName&#39;;
export default MyContext</code></pre>
<pre><code class="language-jsx">import React from &quot;react&quot;;
// 引入 context 对象
import MyContext from &quot;./MyContext&quot;;
// 父组件（Provider）
// 使用 context 对象的 Provider 组件共享数据
const A = () =&gt; (
  &lt;&gt;
    &lt;MyContext.Provider value=&quot;hello context&quot;&gt;
      &lt;B /&gt;
    &lt;/MyContext.Provider&gt;
    &lt;DD/&gt;
  &lt;/&gt;
);
// B C 为 中间组件 
const B = () =&gt; &lt;C /&gt;;
const C = () =&gt; &lt;D /&gt;;
// 目标子组件 - D
// 使用 context 对象的 Consumer 组件获取共享数据 
const D = () =&gt; (
  &lt;MyContext.Consumer&gt;
    {value =&gt; &lt;input type=&quot;text&quot; value={value} /&gt;}
  &lt;/MyContext.Consumer&gt;
);
// 没有被 Provider 组件包裹的子组件 - DD
// value 的值为 `hello` 即context创建时的默认值
const DD= () =&gt; (
  &lt;MyContext.Consumer&gt;
    {value =&gt; &lt;input type=&quot;text&quot; value={value} /&gt;}
  &lt;/MyContext.Consumer&gt;
);
export default A;
</code></pre>
<ul>
<li>使用 <code>React.createContext(&quot;hello&quot;)</code> 创建了一个 <code>context</code> 对象 - <code>MyContext</code> 。</li>
<li>使用 <code>MyContext</code> 对象的 <code>Provider</code> 组件来共享数据。数据赋值给 <code>value</code> 属性，可以是复杂数据。被<code>Provider</code> 组件包裹的子组件链才能获取 <code>value</code> 中数据。</li>
<li>使用 <code>MyContext</code> 对象的 <code>Consumer</code> 组件来<strong>获取</strong>共享数据。获取数据是通过内部的一个回调函数，回调函数的参数就是共享的数据。</li>
<li><code>DD</code> 子组件没有在 <code>Provider</code> 包裹的组件链中，使用<code>Consumer</code> 组件只能获取到定义 <code>context</code> 时候的默认值 - <code>hello</code>。</li>
</ul>
<pre><code class="language-jsx">          +----------------+
          |                |
          |       A        |
          |                |
          |     Provide    |
          |     Context    |
          +--------+-------+
                   |
         +---------+-----------+
         |                     |
         |                     |
+--------+-------+    +--------+-------+
|                |    |                |
|                |    |                |
|       DD       |    |        B       |
|                |    |                |
|                |    |                |
+----------------+    +--------+-------+
                               |
                      +--------+-------+
                      |                |
                      |                |
                      |        C       |
                      |                |
                      |                |
                      +--------+-------+
                               |
                      +--------+-------+
                      |                |
                      |        D       |
                      |                |
                      |     Consume    |
                      |     Context    |
                      +----------------+</code></pre>
<p>其他须知：</p>
<ul>
<li>多个 <code>Provider</code> 也可以嵌套使用，里层的会覆盖外层的数据。</li>
<li>当 <code>Provider</code> 的 <code>value</code> 值发生变化时，它内部的所有 <code>Consume</code> 组件都会重新渲染。且都不受制于<code>shouldComponentUpdate</code> 函数。</li>
</ul>
<h2 id="Class-contextType"><a href="#Class-contextType" class="headerlink" title="Class.contextType"></a>Class.contextType</h2><p>这是一种<strong>仅</strong>支持 <code>class组件</code>的，更灵活的一种消费<strong>单个</strong> <code>context</code> 的 <code>API</code>：</p>
<pre><code class="language-jsx">class MyClass extends React.Component {
  componentDidMount() {
    let value = this.context;
    /* 在组件挂载完成后，使用 MyContext 组件的值来执行一些有副作用的操作 */
  }
  componentDidUpdate() {
    let value = this.context;
    /* ... */
  }
  componentWillUnmount() {
    let value = this.context;
    /* ... */
  }
  render() {
    let value = this.context;
    /* 基于 MyContext 组件的值进行渲染 */
  }
}
MyClass.contextType = MyContext;</code></pre>
<p>挂载在 <code>class</code> 上的 <code>contextType</code> 属性会被重赋值为一个由 <code>React.createContext()</code> 创建的 <code>Context</code> 对象。这能让你使用 <code>this.context</code> 来消费最近 <code>Context</code> 上的那个值。你可以在任何生命周期中访问到它，包括 <code>render</code> 函数中。</p>
<h2 id="复杂场景"><a href="#复杂场景" class="headerlink" title="复杂场景"></a>复杂场景</h2><ul>
<li>动态 &amp; 可更新 <code>Context</code></li>
<li>多个 <code>Context</code></li>
</ul>
<h3 id="动态-amp-可更新-Context"><a href="#动态-amp-可更新-Context" class="headerlink" title="动态 &amp; 可更新 Context"></a>动态 &amp; 可更新 Context</h3><p>对于复杂交互的深层嵌套组件树，其 <code>Prop Drilling</code> 问题可能更严重 - 数据双向传递。即父组件把初始数据通过 <code>props</code> 层层传递到目标子组件。目标子组件会改变数据，再通过 <code>callback</code> 层层传递给父组件来统一提交。</p>
<p>对于这种个别情况，你也不想因此引入 <code>redux</code>。那么，你可以通过 <code>Context</code> 来解决。<code>Context</code> 可以是动态的，可更新的。</p>
<p>来看下面示例：</p>
<pre><code class="language-jsx">// 创建context 
// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！
export default MyContext = React.createContext({
  value: &#39;hello&#39;,
  setValue: () =&gt; {},
});</code></pre>
<pre><code class="language-jsx">// 父组件
import React from &quot;react&quot;;
import MyContext from &quot;./MyContext&quot;;
class A extends React.Component {
  constructor(props) {
    super(props);

    this.setValue = newValue =&gt; {
      this.setState({ value: newValue });
    };
    // State 也包含了更新函数，因此它会被传递进 context provider。
    this.state = {
      value: &quot;Hello context&quot;,
      setValue: this.setValue
    };
  }
  render() {
    return (
      &lt;&gt;
        &lt;MyContext.Provider value={this.state}&gt;
          &lt;B /&gt;
        &lt;/MyContext.Provider&gt;
        &lt;p&gt;{this.state.value}&lt;/p&gt;
      &lt;/&gt;
    );
  }
}
// B C 为 中间组件
const B = () =&gt; &lt;C /&gt;;
const C = () =&gt; &lt;D /&gt;;
// 目标子组件 - D
// 使用 context 对象的 Consumer 组件获取共享数据,通过更新函数更新数据
const D = () =&gt; (
  &lt;MyContext.Consumer&gt;
    {({ value, setValue }) =&gt; (
      &lt;input
        type=&quot;text&quot;
        value={value}
        onChange={e =&gt; {
          setValue(e.target.value);
        }}
      /&gt;
    )}
  &lt;/MyContext.Consumer&gt;
);

export default A;
</code></pre>
<p>我们把父组件本地 <code>state</code>，和用于更新 <code>state</code> 的函数作为一个对象，赋于 <code>provider</code> 的 <code>value</code>。目标子组件可以读取父组件共享的动态数据，并在数据改变的时候更新它。这相当于把修改后数据回传给了父组件。 </p>
<h3 id="多个-Context"><a href="#多个-Context" class="headerlink" title="多个 Context"></a>多个 Context</h3><p>当共享数据较多，不同的子组件需要的数据也不一样。我们可以考虑创建多个 <code>context</code>。而其中某个组件需要不止一个 <code>context</code> 共享数据的时候，它可以消费多个 <code>context</code>: </p>
<pre><code class="language-jsx">// 一个组件通过Consumer组件嵌套，消费多个 context 👇
function Content() {
  return (
    &lt;ThemeContext.Consumer&gt;
      {theme =&gt; (
        &lt;UserContext.Consumer&gt;
          {user =&gt; (
            &lt;ProfilePage user={user} theme={theme} /&gt;
          )}
        &lt;/UserContext.Consumer&gt;
      )}
    &lt;/ThemeContext.Consumer&gt;
  );
}</code></pre>
<hr>
<h1 id="useContext-hook"><a href="#useContext-hook" class="headerlink" title="useContext hook"></a>useContext hook</h1><hr>
<p>既然 <code>React Context</code> 的 <code>API</code> 也可以在函数组件中使用，为什么还需要 <code>useContext Hook</code> 呢？<br>前面我们了解到，子组件要消费 <code>context</code> 需要通过 <code>Consumer</code> 组件包装。要消费多个 <code>context</code>，还需要嵌套 <code>Consumer</code> 组件。<code>useContext Hook</code> 只是新增了一种方式，让你在函数组件中更方便，更优雅的消费 <code>context</code>。创建 和 <code>Provider</code> 方式不变。</p>
<p>前面 动态&amp;更新<code>context</code> 的示例，目标子组件使用 <code>useContext Hook</code> 消费 <code>context</code> 代码如下：</p>
<pre><code class="language-jsx">//
// 目标子组件 - D
// 直接使用 useContext 消费共享数据, 并通过更新函数更新数据。
const D = () =&gt; (
  const { value, setValue } = React.useContext(MyContext)
  return (
    &lt;input
      type=&quot;text&quot;
      value={value}
      onChange={e =&gt; {
        setValue(e.target.value);
      }}
    /&gt;
  )
);</code></pre>
<p>可读性更高了，还可很方便的消费多个 <code>context</code>，这是 <code>class组件</code> 的 <code>contextType</code> 所不能的。</p>
<hr>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://zh-hans.reactjs.org/docs/context.html" target="_blank" rel="noopener">官网-Context</a><br><a href="https://www.robinwieruch.de/react-context" target="_blank" rel="noopener">React Context</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/30/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%BA%8C%EF%BC%89-Refs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/30/%E6%8B%A5%E6%8A%B1React-Hooks%EF%BC%88%E4%BA%8C%EF%BC%89-Refs/" itemprop="url">拥抱React-Hooks（二）- useRef</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-30T19:53:19+08:00">
                2020-03-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Why-amp-When-Refs"><a href="#Why-amp-When-Refs" class="headerlink" title="Why &amp; When Refs"></a>Why &amp; When Refs</h1><hr>
<p>在典型的 <code>React</code> 数据流中，<code>DOM</code> 元素的修改都是通过 <code>M-V</code> 的形式重新渲染。<code>M</code> 主要是组件的本地 <code>state</code> ，以及父组件传递给子组件的 <code>props</code>。<br>但是，在某些情况下，你需要在典型数据流之外，手动使用/操作 <code>DOM</code>：</p>
<ul>
<li>管理焦点，媒体播放，文本选择，触发强制动画等。</li>
<li>集成第三方 <code>DOM</code> 库。</li>
</ul>
<p>这个时候，就不要用类似 <code>document.getElementById()</code> 这种原生方式了。<code>React</code> 提供了 <code>Refs</code> 这样一种方式，来访问 <code>DOM</code> 节点或在 <code>render</code> 方法中创建的 <code>React</code> 元素。</p>
<p>另外，<code>refs</code> 还可用于创建一个可变对象（mutable object），并且修改它不会触发组件更新。</p>
<p>但是，一定不能滥用 <code>Refs</code>。避免使用 <code>refs</code> 来做任何可以通过<strong>声明式渲染</strong>（Declarative，DOM随状态（数据）更新而更新）来完成的事情。</p>
<h1 id="Class-组件中的-Refs"><a href="#Class-组件中的-Refs" class="headerlink" title="Class 组件中的 Refs"></a>Class 组件中的 Refs</h1><hr>
<p>在类组件中，目前有三种方式来创建和使用Refs：</p>
<ul>
<li><code>String类Refs</code>: 官方表示会弃用的，过时的 <code>API</code>，还不支持函数组件。所以<strong>别再用了</strong>。</li>
<li><code>回调Refs</code>：将 回调函数 作为 <code>ref</code> 的一种方式。</li>
<li><code>React.createRef</code>: 这是 <code>React@16.3</code> 版本引入的 顶层 <code>API</code>。</li>
</ul>
<h2 id="String类refs"><a href="#String类refs" class="headerlink" title="String类refs"></a>String类refs</h2><p>命名一个 <code>string</code> 作为元素的<code>ref</code>属性，然后通过 <code>this.refs[string]</code> 的形式访问。我们来看一个媒体播放的示例：</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
class VideoPlay extends React.Component {
  constructor(props) {
    super(props);
  }
  componentDidMount () {
    // 使用refs
    this.refs.myVideo.play()
  }
  render() {
    // 创建refs
    return (
      &lt;video 
        ref=&#39;myVideo&#39; 
        src=&quot;https://media.w3.org/2010/05/sintel/trailer.mp4&quot; 
        playsinline=&quot;&quot; 
      /&gt;
    );
  }
}</code></pre>
<p>过时 <code>API</code>，了解一下即可。再次强调：<strong>不要再这样使用</strong>。</p>
<blockquote>
<p>备注：本篇文章的示例验证，都是使用 <code>React 16.12.0</code> 版本。</p>
</blockquote>
<h2 id="回调Refs"><a href="#回调Refs" class="headerlink" title="回调Refs"></a>回调Refs</h2><p>你可以传递一个函数作为 <code>ref</code>。这个函数中接受 <code>React</code> 组件实例或 <code>DOM</code> 元素作为参数，以便它们能在其他地方被存储和访问。<br><code>React</code> 在组件挂载时，会调用 <code>ref</code> 回调函数并传入 <code>DOM</code> 元素，当卸载时调用它并传入 <code>null</code>。在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 触发前，<code>React</code> 会保证 <code>ref</code> 一定是最新的。</p>
<p>上面的例子用 <code>回调Refs</code> 实现如下：</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
class VideoPlay extends React.Component {
  constructor(props) {
    super(props);
  }
  componentDidMount () {
    // 使用refs
    this.myVideo.play()
  }
  render() {
    // 创建refs
    return (
      &lt;video 
        ref={ (elem) =&gt; { this.myVideo = elem } }
        src=&quot;https://media.w3.org/2010/05/sintel/trailer.mp4&quot; 
        playsinline=&quot;&quot; 
      /&gt;
    );
  }
}
</code></pre>
<h2 id="React-createRef"><a href="#React-createRef" class="headerlink" title="React.createRef"></a>React.createRef</h2><p><code>React 16.3</code> 版本新增的这个顶层 <code>API</code>，用于创建 <code>ref</code>。组件挂载时，会把 <code>DOM</code> 元素或组件实例传给 <code>ref</code> 的 <code>current</code> 属性，并在组件卸载时置为 <code>null</code> 。<code>ref</code> 会在 <code>componentDidMount</code> 或 <code>componentDidUpdate</code> 生命周期钩子触发前更新。</p>
<p><code>ref</code> 的值根据它所赋予的节点的类型有所不同：</p>
<ul>
<li>当 <code>ref</code> 属性用于 <code>DOM</code> 元素时，<code>ref</code> 接收底层 <code>DOM</code> 元素作为其 <code>current</code> 属性 ：</li>
</ul>
<pre><code class="language-jsx">import React from &#39;react&#39;;
class APP extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 textInput 的 DOM 元素
    this.textInput = React.createRef();
  }

  focusTextInput = () =&gt; {
    // 直接使用原生 API 使 text 输入框获得焦点
    // 注意：我们通过 &quot;current&quot; 来访问 DOM 节点
    this.textInput.current.focus();
  }

  render() {
    // 告诉 React 我们想把 &lt;input&gt; ref 关联到
    // 构造器里创建的 `textInput` 上
    return (
      &lt;div&gt;
        &lt;input
          type=&quot;text&quot;
          ref={this.textInput} /&gt;
        &lt;input
          type=&quot;button&quot;
          value=&quot;Focus the text input&quot;
          onClick={this.focusTextInput}
        /&gt;
      &lt;/div&gt;
    );
  }
}
export default APP;</code></pre>
<ul>
<li>当 <code>ref</code> 属性用于自定义 <code>class</code> 子组件时，<code>ref</code> 对象接收 组件的挂载实例 作为其 <code>current</code> 属性。</li>
</ul>
<pre><code class="language-jsx">import React from &quot;react&quot;;
class APP extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 子组件的实例
    this.textInput = React.createRef();
  }

  focusTextInput = () =&gt; {
    // 注意：这里 “ref” 的 &quot;current&quot; 是子组件的实例 
    // 所以可以调用实例的 “setValue” 方法
    this.textInput.current.setValue(&quot;hello&quot;);
  };

  render() {
    // 告诉 React 我们想把 &lt;input&gt; ref 关联到
    // 构造器里创建的 `textInput` 上
    return (
      &lt;div&gt;
        &lt;InputText ref={this.textInput} /&gt;
        &lt;input
          type=&quot;button&quot;
          value=&quot;Focus the text input&quot;
          onClick={this.focusTextInput}
        /&gt;
      &lt;/div&gt;
    );
  }
}
// 注意 仅在 InputText 组件声明为 class 的时候有用
class InputText extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: &quot;&quot;
    };
  }
  // 演示用的实例方法，没现实意义
  setValue = value =&gt; {
    this.setState({ value });
  };
  render() {
    return &lt;input type=&quot;text&quot; value={this.state.value} /&gt;;
  }
}
export default APP;
</code></pre>
<p>如果子组件通过 <code>import InputText from &quot;./InputText&quot;</code> 的方式引入，<code>InputText</code> 就是子组件的实例。那这种 <code>refs</code> 作用于子组件的使用方式意义何在？可能用 <code>refs</code> 显得更语义化，规范化。比如使用了多个 <code>InputText</code> 的情况。</p>
<blockquote>
<p>注意： 你不能在函数组件上像这样使用 <code>ref</code> 属性，因为函数组件没有实例。不过可以通过forwardRef转发refs使用，这个后面会讲到。</p>
</blockquote>
<h1 id="函数组件中的-Refs"><a href="#函数组件中的-Refs" class="headerlink" title="函数组件中的 Refs"></a>函数组件中的 Refs</h1><hr>
<p>首先，我们思考这样一个问题：类组件中三种 <code>refs</code> 的使用方式能否在函数组件中应用。我们来逐个分析一下。</p>
<p>首先，<code>String类refs</code>。不能！官方明确表示不支持函数组件，也是过时 <code>API</code>, Just forget about it。</p>
<p>其次，我们在函数组件中应用一下 <code>回调refs</code>，比如写一个自动聚焦的 <code>input</code>组件：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &quot;react&quot;;

function App() {
  const [value, setValue] = useState(&quot;hellow hooks&quot;);
  let inputRef = null;

  console.log(inputRef);// 日志A
  useEffect(() =&gt; {
    console.log(inputRef); //日志B
    inputRef.focus();
  });

  function inputHandler(val) {
    setValue(val.target.value);
  }

  return (
    &lt;&gt;
      &lt;input
        type=&quot;text&quot;
        value={value}
        ref={elem =&gt; {
          inputRef = elem;
        }}
        onChange={inputHandler}
      /&gt;
    &lt;/&gt;
  );
}
export default App;</code></pre>
<ul>
<li><p>上面是一个简单的 <code>input</code> 输入组件。</p>
</li>
<li><p>通过 <code>回调refs</code> 创建一个 <code>ref</code>（ 对应 <code>input</code>元素） 赋值给 <code>inputRef</code> 变量。</p>
</li>
<li><p>使用 <code>useEffect</code> 实现自动 <code>focus</code>功能。这里没有加依赖项 <code>[]</code> 是想看看组件重新渲染以后，<code>refs</code>的变化。</p>
</li>
<li><p>发现功能一切正常。每次渲染，日志A 为 <code>null</code>，日志B 为 <code>&lt;input type=&quot;text&quot; value=&quot;hellow hooks&quot;&gt;&lt;/input&gt;</code>(其中 <code>value</code> 是当前最新值)。</p>
</li>
</ul>
<p>以上，我们完全可以得出一个结论：至少在函数组件内部，<code>回调refs</code> 完全可用。但是从<code>日志A</code>和<code>日志B</code>看出，每次渲染都会通过<code>回调refs</code> 的方式重新创建一个 <code>ref</code> 赋值给 <code>inputRef</code> 变量。明显存在性能问题。</p>
<p>让我们再试试<code>createRef</code>，还是上面的例子：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &quot;react&quot;;

function App() {
  const [value, setValue] = useState(&quot;hellow hooks&quot;);
  //创建 refs
  const inputRef = React.createRef();
  // 日志A
  console.log(inputRef.current || null) 
  useEffect(() =&gt; {
    // 日志B
    console.log(inputRef.current);
    inputRef.current.focus();
  });

  function inputHandler(val) {
    setValue(val.target.value);
  }

  return (
    &lt;&gt;
      &lt;input type=&quot;text&quot; value={value} ref={inputRef} onChange={inputHandler} /&gt;
    &lt;/&gt;
  );
}
export default App;</code></pre>
<ul>
<li>使用 <code>createRef</code> 创建一个 <code>inputRef</code>，直接赋予 <code>input</code> 的 <code>ref</code> 属性。比 <code>回调refs</code> 优美一些。</li>
<li>功能正常。日志跟<code>回调refs</code> 一样。</li>
</ul>
<p>结论：和 <code>回调refs</code> 一样 <code>react.createRef</code> 同样可以在函数组件内部使用。当然也有同样的性能问题。</p>
<blockquote>
<p>网上有看到<a href="https://juejin.im/post/5e5c5f6a6fb9a07cad3ba383" target="_blank" rel="noopener">文章</a>说在函数组件内部，使用 <code>react.createRef</code> 永远获取不到 <code>refs</code> 。这和我的验证不符，可能是由于 <code>React</code> 版本差异。</p>
</blockquote>
<p>这里有一点需要说明，上面的两个示例之所以有性能问题，是因为我们在函数组件中使用了 <code>hooks</code>。而我们使用的两种 <code>refs</code> 并没有 <code>hooks</code> 特性。所以，我们需要更好的选择。</p>
<h1 id="useRef-hooks"><a href="#useRef-hooks" class="headerlink" title="useRef hooks"></a>useRef hooks</h1><hr>
<p>更好的选择那就是 <code>useRef hooks</code>，我们将要学习的新的 <code>React Hooks</code>，也是今天的主角。<br>和<code>createRef</code>相比，就是改用  <code>useRef</code> 这个 <code>hooks API</code> 来创建 <code>ref</code>，使用上并无差别。</p>
<p>还是同样的示例：</p>
<pre><code class="language-jsx">import React, { useState, useEffect, useRef } from &quot;react&quot;;

function App() {
  const [value, setValue] = useState(&quot;hellow hooks&quot;);
  //创建 refs 只有这里有修改
  const inputRef = useRef();

  // 日志A
  console.log(inputRef.current) 
  useEffect(() =&gt; {
    // 日志B
    console.log(inputRef.current);
    inputRef.current.focus();
  });

  function inputHandler(val) {
    setValue(val.target.value);
  }

  return (
    &lt;&gt;
      &lt;input type=&quot;text&quot; value={value} ref={inputRef} onChange={inputHandler} /&gt;
    &lt;/&gt;
  );
}
export default App;</code></pre>
<ul>
<li><strong>API</strong>：和 <code>createRef</code> 非常类似。<code>useRef</code> 也可以接受一个参数作为 <code>ref</code> 的 <code>current</code>值。有个细微区别是 <code>createRef</code> 的 <code>current</code> 默认值是 <code>null</code>，而 <code>useRef</code> 中默认是 <code>undefined</code>。</li>
<li><strong>性能</strong>：重新渲染时，<code>inputRef</code> 不会再被初始化。<code>日志A</code> 和 <code>日志B</code> 都打印 <code>&lt;input type=&quot;text&quot; value=&quot;Hello Reac&quot;&gt;&lt;/input&gt;</code>，并且其中 <code>value</code> 是当前最新值。</li>
<li>原理：和 <code>useState</code> <code>useEffect</code> 一样，每个组件都有一个 “内存单元”，首次渲染的时候初始化，把<code>Hooks</code>的数据按顺序存入各个内存单元格，重新渲染的时候再按顺序依次从单元格读取。</li>
</ul>
<h1 id="暴露-Ref-给父组件"><a href="#暴露-Ref-给父组件" class="headerlink" title="暴露 Ref 给父组件"></a>暴露 Ref 给父组件</h1><p>在实际复杂业务场景中，你可能希望在父组件中引用子节点的 <code>DOM</code> 节点。也就是我们不光需要 <code>Ref</code>，还要把 <code>Ref</code> 的控制权也交给父组件。</p>
<blockquote>
<p>官方不建议如此，因为它会打破组件的封装，逻辑分散。所以我们要慎用，然后该用还得用。</p>
</blockquote>
<p>当你决定如此，这里有三种办法：</p>
<ul>
<li>ref属性传递: 支持<strong>所有</strong> <code>React</code> 版本，不支持函数子组件。<strong>不推荐</strong></li>
<li>props传递: 支持<strong>所有</strong> <code>React</code> 版本，也支持函数子组件。</li>
<li>转发refs: 支持 <strong>React16.3</strong>及以上版本。也支持函数子组件。</li>
</ul>
<blockquote>
<p>父组件是类组件还是函数组件，只决定你是用<code>createRef</code> 还是 <code>useRef</code> 创建 <code>refs</code>。</p>
</blockquote>
<h2 id="ref属性传递"><a href="#ref属性传递" class="headerlink" title="ref属性传递"></a>ref属性传递</h2><p>前面在介绍 <code>createRef</code> 的时候有提到：当 <code>ref</code> 属性用于自定义 <code>class</code> 子组件时，<code>ref</code> 对象接收<strong>组件的挂载实例</strong> 作为其 <code>current</code> 属性。</p>
<p>注意了，我们获取到的是子组件的实例，而不是具体的 <code>DOM</code> 元素。这个时候，你想操作子组件，还需要在子组件也创建 <code>ref</code>, 并把相关操作封装成一个方法供父组件调用。这也是不推荐这种方式的原因。</p>
<p>比如在某些场景，我们想在父组件让子组件中的 <code>input</code> 输入框聚焦:</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;

class APP extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 子组件的实例
    this.inputText = React.createRef();
  }
  // 按钮事件处理中，实现聚焦。
  // 你也可以在 componentDidMount 中处理，实现自动聚焦。
  focusInputText = () =&gt; {
    // 注意：这里 “ref” 的 &quot;current&quot; 是子组件的实例 
    // 只能通过调用实例的 doFocus 方法达到控制目的
    this.inputText.current.doFocus();
    // 更不优雅的方式如下
    this.inputText.current.inputRef.current.focus();
  };

  render() {
    return (
      &lt;&gt;
        &lt;InputText ref={this.inputText} /&gt;
        &lt;input
          type=&quot;button&quot;
          value=&quot;Focus the text input&quot;
          onClick={this.focusInputText}
        /&gt;
      &lt;/&gt;
    );
  }
}
// 注意 仅在 InputText 组件声明为 class 的时候有用
class InputText extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: &quot;&quot;
    };
    // 子组件也需要创建一个ref
    this.inputRef = React.createRef();
  }
  // 提供一个给父组件调用的方法
  doFocus = () =&gt; {
    this.inputRef.current.focus();
  };
  render() {
    return &lt;input type=&quot;text&quot; value={this.state.value} ref={this.inputRef} /&gt;;
  }
}
export default APP;</code></pre>
<p>缺点很明显：</p>
<ul>
<li>不支持函数子组件，很致命。</li>
<li>父子组件都需要创建 <code>refs</code>，性能不佳。</li>
</ul>
<h2 id="props传递"><a href="#props传递" class="headerlink" title="props传递"></a>props传递</h2><p>顾名思义，既然 <code>ref</code> 属性作用于子组件，是返回整个组件实例。那么我们可以通过 <code>props</code> 传递 <code>refs</code>。你只需要给它起一个独一无二的名字。</p>
<p>上面的示例修改后是这样的：</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
class APP extends React.Component {
  constructor(props) {
    super(props);
    // 创建一个 ref 来存储 子组件的实例
    this.inputRef = React.createRef();
  }
  // 按钮事件处理中，实现聚焦。
  focusInputText = () =&gt; {
    // 注意：这里 “ref” 的 &quot;current&quot; 在子组件挂载的时候 已经指向 input 元素
    this.inputRef.current.focus();
  };

  render() {
    return (
      &lt;&gt;
        &lt;InputText inputRef={this.inputRef} /&gt;
        &lt;input
          type=&quot;button&quot;
          value=&quot;Focus the text input&quot;
          onClick={this.focusInputText}
        /&gt;
      &lt;/&gt;
    );
  }
}
// 注意 这里用函数组件也同样可以
class InputText extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      value: &quot;&quot;
    };
    // ref 通过参数获取
    this.inputRef = props.inputRef;
  }
  render() {
    return &lt;input type=&quot;text&quot; value={this.state.value} ref={this.inputRef} /&gt;;
  }
}
export default APP;</code></pre>
<p>复制上述代码到 <code>codesandbox</code> 验证，功能ok。发现没有，代码相对于 “ref属性”，精简优雅了许多。而且，也支持函数组件。</p>
<p>我们用 函数组件 + <code>hooks</code> 来实现上述示例，并且使用 <code>useEffect</code> 实现自动<code>focus</code>：</p>
<pre><code class="language-jsx">import React, { useState, useEffect, useRef } from &#39;react&#39;;
const App = () =&gt; {
  const [greeting, setGreeting] = useState(&#39;Hello React!&#39;);
  const ref = useRef();
  useEffect(() =&gt; ref.current.focus(), []);
  const handleChange = event =&gt; setGreeting(event.target.value);
  return (
    &lt;div&gt;
      &lt;h1&gt;{greeting}&lt;/h1&gt;
      &lt;Input value={greeting} handleChange={handleChange} inputRef={ref} /&gt;
    &lt;/div&gt;
  );
};
const Input = ({ value, handleChange, inputRef }) =&gt; (
  &lt;input
    type=&quot;text&quot;
    value={value}
    onChange={handleChange}
    ref={inputRef}
  /&gt;
);
export default App;
</code></pre>
<h2 id="转发refs-forwardRef"><a href="#转发refs-forwardRef" class="headerlink" title="转发refs - forwardRef"></a>转发refs - forwardRef</h2><ul>
<li><p><code>Ref转发</code> 是通过 <code>React</code> 提供的一个顶层 <code>API</code> - <code>forwardRef</code> 来实现。</p>
</li>
<li><p><code>forwardRef</code> 通过包装子组件的形式，允许子组件能接收 <code>ref</code> 作为第二个参数，并将其向下传递（换句话说，“转发” 它）给子组件。</p>
</li>
<li><p>前面提到过，将 <code>ref</code> 作为子组件的 <code>JSX</code> 属性，是没法把 <code>ref</code> 传递下去。函数组件不支持，类组件也只能获取到子组件的实例。现在通过 <code>forwardRef</code> 包装即可实现。</p>
<p>请看示例：</p>
</li>
</ul>
<pre><code class="language-jsx">import React, {
  useState,
  useEffect,
  useRef,
  forwardRef,
} from &#39;react&#39;;

const App = () =&gt; {
  const [greeting, setGreeting] = useState(&#39;Hello React!&#39;);
  const handleChange = event =&gt; setGreeting(event.target.value);
  const ref = useRef();
  useEffect(() =&gt; ref.current.focus(), []);
  return (
    &lt;div&gt;
      &lt;h1&gt;{greeting}&lt;/h1&gt;
      &lt;Input value={greeting} handleChange={handleChange} ref={ref} /&gt;
    &lt;/div&gt;
  );
};

const Input = forwardRef(({ value, handleChange }, ref) =&gt; (
  &lt;input
    type=&quot;text&quot;
    value={value}
    onChange={handleChange}
    ref={ref}
  /&gt;
));

export default App;</code></pre>
<p>以下是对上述示例发生情况的逐步解释：</p>
<ul>
<li>我们通过调用 <code>React.useRef</code> 创建了一个 <code>ref</code> 并将其赋值给 <code>ref</code> 变量。</li>
<li>我们通过指定 <code>ref</code> 为 <code>JSX</code> 属性，将其向下传递给 <code>&lt;Input ref={ref}&gt;</code>。</li>
<li><code>React</code> 传递 <code>ref</code> 给 <code>forwardRef</code> 内函数 <code>(props, ref) =&gt; ...</code>，作为其第二个参数。</li>
<li>我们向下转发该 <code>ref</code> 参数到 <code>&lt;input ref={ref}&gt;</code>，将其指定为 <code>JSX 属性</code>。</li>
<li>当 <code>ref</code> 挂载完成，<code>ref.current</code> 将指向 <code>&lt;input/&gt;</code> <code>DOM</code> 节点。</li>
</ul>
<h3 id="forwardRef-useImperativeHandle"><a href="#forwardRef-useImperativeHandle" class="headerlink" title="forwardRef + useImperativeHandle"></a>forwardRef + useImperativeHandle</h3><p>我们通过 forwardRef 进行 refs转发，并配合 useImperativeHandle hooks，可以将函数子组件的指定元素和方法暴露给父组件使用。这在很多稍复杂的业务场景非常有用。</p>
<p>API 可抽象为: <code>useImperativeHandle(refParam, arrowFunction, [depsArr])</code> </p>
<ul>
<li><code>refParam</code>: 必须。通过 <code>forwardRef</code>转发的父组件传递的 <code>ref</code>，也就是<code>forwardRef</code>里函数的第二个参数。</li>
<li><code>arrowFunction</code>: 必须。回调函数，该函数返回的对象将暴露给父组件访问。</li>
<li><code>depsArr</code>: 非必须。一个依赖项数组。当依赖项改变的时候会重新调用 <code>arrowFunction</code>。</li>
</ul>
<p>我们改一下上面的示例，让父组件可以直接调用子组件的方法来聚焦子组件中的 <code>input</code>。</p>
<pre><code class="language-jsx">import React, {
  useState,
  useEffect,
  useRef,
  forwardRef,
  useImperativeHandle
} from &#39;react&#39;;

const App = () =&gt; {
  const [greeting, setGreeting] = useState(&#39;Hello React!&#39;);
  const handleChange = event =&gt; setGreeting(event.target.value);
  const ref = useRef();

  useEffect(() =&gt; ref.current.doFocus(), []);

  return (
    &lt;div&gt;
      &lt;h1&gt;{greeting}&lt;/h1&gt;
      &lt;Input value={greeting} handleChange={handleChange} ref={ref} /&gt;
    &lt;/div&gt;
  );
};

const Input = forwardRef( ({ value, handleChange }, ref) =&gt; {
  const inputRef = useRef();

  useImperativeHandle(ref, () =&gt; ({ doFocus }), []);

  const doFocus = () =&gt; {
    inputRef.current.focus();
  }

  return (
    &lt;input
      type=&quot;text&quot;
      value={value}
      onChange={handleChange}
      ref={inputRef}
    /&gt;
  )
});

export default App;</code></pre>
<h1 id="可变对象"><a href="#可变对象" class="headerlink" title="可变对象"></a>可变对象</h1><p>前面提到，<code>refs</code> 不光可以用于引用和操作<code>Dom</code>，还可以用于创建可变对象。<br>我们在函数组件中使用<code>useRef hook</code>  来创建一个看看：</p>
<pre><code class="language-jsx">import React, { useState, useRef } from &quot;react&quot;;
function App() {
  const valRef = useRef(0);// React.createRef don&#39;t work
  let normalVal = 0;
  const [, setChange] = useState();
  return (
    &lt;div style={{ padding: "100px 200px" }}&gt;
      refValue: {valRef.current} | 
      normalValue: {normalVal}
      &lt;button
        onClick={() =&gt; {
          valRef.current += 80;
          normalVal += 1;
          setChange({});
        }}
      &gt;
        +
      &lt;/button&gt;
    &lt;/div&gt;
  );
}
export default App;</code></pre>
<ul>
<li>可变对象的改变，不会触发组件的重新渲染。所以示例增加调用了 <code>setChange({})</code> 来触发组件重新渲染，来展示可变对象的变化。</li>
<li>点击 <code>+</code> 号，你会发现 <code>refValue</code> 会不断递增，而 <code>normalValue</code> 始终为 <code>0</code>.</li>
<li>这是一个有趣的功能，暂时还不知道会在哪些场景会用到它。了解一下即可。</li>
</ul>
<h1 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h1><p>所谓的最佳实践，也就是对一些规则的总结：</p>
<ul>
<li>尽量在必要的时候使用<code>refs</code>，除了个别需要手动获取/操作Dom的场景：管理焦点，媒体播放，文本选择，触发强制动画，集成第三方 DOM 库等。</li>
<li>不要再使用<code>String类refs</code>，类似 <code>this.refs.XX</code> 这种形式。</li>
<li>类组件中：<code>React16.3</code> 及以上版本建议使用<code>React.createRef</code> 这个<code>API</code>，低版本使用<code>回调refs</code>。</li>
<li>函数组件中：为性能考虑，建议都使用 <code>useRef</code> 这个 <code>hook</code>。即便它无状态，无副作用。</li>
<li>对于 <code>refs</code> 在父子组件间传递的情况，慎用但该用还得用，然后首推 <code>refs转发</code>，其次 <code>props传递</code>。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://zh-hans.reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">官网-refs</a><br><a href="https://zh-hans.reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">官网-refs转发</a><br><a href="https://zh-hans.reactjs.org/docs/lifting-state-up.html" target="_blank" rel="noopener">官网-状态提升</a><br><a href="https://www.robinwieruch.de/react-function-component" target="_blank" rel="noopener">React Function Components</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/" itemprop="url">拥抱 React Hooks （一）基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-18T14:16:43+08:00">
                2020-03-18
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="React-Hooks-起源"><a href="#React-Hooks-起源" class="headerlink" title="React Hooks 起源"></a>React Hooks 起源</h1><ul>
<li>React 一直都提倡使用函数式组件。更轻便，更优雅，性能更佳。函数式组件又称<strong>无状态组件(FSC)</strong>。</li>
<li>以前，需要使用 <code>state</code> ，生命周期等React 特性，必须重构为 class 组件。</li>
<li><code>Hooks</code> 是 React 16.8 新增的特性，它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 React 特性。</li>
<li>现在，你可以直接在现有的函数式组件中使用 <code>Hooks</code>，而无须重构为 class 组件。</li>
<li>全新的思维方式。no magic, just javascript and some rules。</li>
</ul>
<img src="/2020/03/18/%E6%8B%A5%E6%8A%B1React-Hooks/hooks-1.jpg" class="" title="hooks起源">

<h1 id="类组件被诟病"><a href="#类组件被诟病" class="headerlink" title="类组件被诟病"></a>类组件被诟病</h1><ul>
<li>类(累)：自js开天辟地，就是面向函数式编程(FP), 面向对象编程(OOP)为何物。烦人的构造函数。super是什么？……</li>
<li>this绑定：类方法不会自动绑定 this 到实例上。现有四种<code>bind</code>方式。不优雅，易出错，<code>bind</code>还影响性能（使用箭头函数后有所改善）。</li>
<li>setState(): 异步更新机制，<code>state</code>浅合并机制。不理解这些概念，很容易踩坑。</li>
<li>生命周期耦合：每个生命周期方法通常包含一堆不相关的逻辑；不同生命周期中的逻辑又有关联。</li>
</ul>
<p>下面组件来自实际项目，经过简化和微调（方便演示和直观感受），基本上暴露出了上面所有问题。业务逻辑严谨性不用推敲：</p>
<pre><code class="language-jsx">class NumberInput extends React.Component {
  constructor(props) {
    // 为什么必须super，不传props会怎样
    super(props)
    this.state = {
      focus: false
    }
    this.tradingpwd = &#39;&#39;
    // 第一种bind，官方推荐
    ;[&#39;onBlur&#39;].forEach(method =&gt; {
      this[method] = this[method].bind(this)
    })
  }
  // 下面两个生命周期得相互配合，实现某些功能
  componentDidMount() {
    this.tradingPwdHideInput.focus()
    // 处理某类兼容问题
    let bodyTop = document.body.getBoundingClientRect().top
    const styleText = &#39;position: fixed; width: 100%; top: &#39; + bodyTop + &#39;px&#39;
    document.body.style.cssText = styleText
  }

  componentWillUnmount() {
    this.tradingPwdHideInput.blur()
    document.body.style.position = &#39;static&#39;
  }

  tradingPwdChange(e) {
    // ...
    this.tradingpwd = e.target.value
    this.props.inputChangeCallback(e.target.value)
    // ...
  }
  // 第二种bind
  onFocus = () =&gt; {
    this.setState({
      focus: true
    })
  }
  onBlur() {
    this.setState({
      focus: false
    })
  }

  render() {
    return (
      &lt;div className={classNames(&#39;NumberInput&#39;)}&gt;
        &lt;input
          type=&#39;tel&#39;
          ref={ref =&gt; {
            this.tradingPwdHideInput = ref
          }}
          id=&#39;tradingPwdHideInput&#39;
          /* 第三种bind */
          onClick={() =&gt; {
            this.tradingPwdHideInput.focus()
          }}
          onBlur={ this.onBlur }
          onFocus={ this.onFocus }
          /* 第四种bind，不推荐，在每次 render() 方法执行时绑定类方法，消耗性能*/
          onChange={ this.tradingPwdChange.bind(this) }
        /&gt;
      &lt;/div&gt;
    )
  }
}</code></pre>
<blockquote>
<p><a href="https://github.com/tc39/proposal-class-fields" target="_blank" rel="noopener">proposal-class-fields</a> 新提案会改善上述情况，目前处于第三阶段。</p>
</blockquote>
<p>随着类组件趋于复杂，还有其他诟病：</p>
<ul>
<li>难拆分，本地state逻辑到处都是，当组件越来越复杂，想拆分比较难。</li>
<li>状态逻辑难复用：需要引入高阶特性进行代码重构，需要调整组件结构，成本高。</li>
<li>抽象地狱：大型React往往使用render props ，HOC，Context 等高阶特性，形成大量包装组件（wrapping components）。层级冗余，逻辑难追踪。</li>
</ul>
<p>深度包装的组件长这样：</p>
<pre><code class="language-jsx">import { compose } from &#39;recompose&#39;;
import { withRouter } from &#39;react-router-dom&#39;;
function App({ history, state, dispatch }) {
  return (
    &lt;ThemeContext.Consumer&gt;
      {theme =&gt;
        &lt;Content theme={theme}&gt;
          ... 
        &lt;/Content&gt;
      }
    &lt;/ThemeContext.Consumer&gt;
  );
}
export default compose(
  withRouter,
  withReducer(reducer, initialState)
)(App);</code></pre>
<p>确实很抽象。这是 React 中典型的<strong>抽象地狱（Abstraction hell）</strong>问题，也叫<strong>包装地狱（The wrapper hell）</strong>。</p>
<h1 id="Hooks-优越性"><a href="#Hooks-优越性" class="headerlink" title="Hooks 优越性"></a>Hooks 优越性</h1><p><code>Hooks</code> 引入的一个重要的原因，就是类组件存在着种种诟病。那他必然存在一些优越性。</p>
<p>在说明这些优越性之前，先了解一个概念：</p>
<blockquote>
<p><strong>副作用</strong>：React 中主要指那些没有发生在数据向视图（M-V）转换过程中的逻辑，如 <code>Ajax</code> 请求、访问原生 <code>DOM</code> 元素、本地持久化缓存、绑定/解绑事件、添加/取消订阅、设置定时器、记录日志等。</p>
</blockquote>
<p>Hooks 的优越性：</p>
<ul>
<li>函数式编程：No <code>class</code>, No <code>super</code>, No <code>this</code>。对于不了解 <code>OOP</code> 的 React 初学者更友好。</li>
<li>有状态逻辑易复用：可以通过 <code>Custom Hook</code>（后面讲解）重构，而不用修改组件结构。</li>
<li>易拆分：状态管理和副作用管理松耦合，原子性强。很容易将一些相关联的逻辑拆分成更小的函数。</li>
<li>可逐步引入：<code>Hooks</code> 向后兼容，与现有代码可并行工作，因此我们可以逐步采用它们。</li>
<li>副作用分组：很多副作用逻辑分散在类组件生命周期函数中。而 <code>Hooks</code> 可以将每个副作用的设置和清理封装在一个函数中。</li>
<li>副作用分离：副作用操作都在页面渲染之后。</li>
</ul>
<h1 id="抛弃类组件？"><a href="#抛弃类组件？" class="headerlink" title="抛弃类组件？"></a>抛弃类组件？</h1><p>既然 <code>Hooks</code> 存在这么多优越性。那是不是就到了抛弃 class 组件的时候了。</p>
<p>对此，官方说：</p>
<ul>
<li>新版本依然支持 <code>class</code> 相关API，在相当一段时期内，class 组件 和 Hooks 组件并存。</li>
<li>向后兼容，是加法。注意，是函数组件的加法，即 <code>Hooks</code> 只能用在函数组件中。</li>
<li>推荐使用 函数组件 + <code>Hooks</code>。</li>
</ul>
<p>个人觉得：</p>
<ul>
<li><strong>当下</strong>：不抛弃，不放弃。class 组件将我们带到了 OOP 的世界，OOP在编程界举足轻重，其思想是值得学习的。即便 class 组件已然成为一种历史产物，但他的存量巨大，依然需要去维护，去慢慢消化。</li>
<li><strong>未来</strong>：有可能弃用 class 组件及其生命周期。一方面，前端的世界本来变化就快。另一方面，class 组件确实存在一些弊端。随着 <code>Hooks</code>的不断成熟（或新的技术诞生）， 使得开发效率，代码可读性，维护性，性能等综合优势比较明显的时候，弃用是必然。</li>
</ul>
<p>所以：</p>
<ul>
<li>对于 React 老司机：拥抱Hooks，是拥抱变化。这个变化，是加法，是学习新的API，新的技能，新的思想。</li>
<li>对于 React 新手：拥抱Hooks，降低了学习门槛，可以更快入门。但是类组件也非常有必要去了解，理解。知己知彼，重构不殆。</li>
</ul>
<p>说了这么多，来，我们先来和这些 React Hooks 的 API 见个面：</p>
<p>基础 Hook</p>
<ul>
<li>useState</li>
<li>useEffect</li>
</ul>
<p>其他 Hook</p>
<ul>
<li>useContext</li>
<li>useReducer</li>
<li>useCallback</li>
<li>useMemo</li>
<li>useRef</li>
<li>useImperativeHandle</li>
<li>useLayoutEffect</li>
<li>useDebugValue</li>
<li>… 还会增加</li>
</ul>
<p>是不是有点多，其实<code>useState</code> <code>useEffect</code> 这两个已经能应付多数场景了。Let‘s go👇</p>
<h1 id="useState-hook"><a href="#useState-hook" class="headerlink" title="useState hook"></a>useState hook</h1><ul>
<li>功能：在函数组件中用来进行状态管理，创建<strong>一些</strong>本地 state。</li>
<li>API：<code>const [currentState, setFunction] = useState(initialState);</code>。传一个参数，返回一个数组（包含两个值）- 三要素。</li>
<li><code>initialState</code>：参数，state 初始值。可以是任何类型： String，Object，Array，Bool，Number等。</li>
<li><code>currentState</code>：返回值，state 当前最新值。可自主命名。</li>
<li><code>setFunction</code>：返回值，state 更新函数。可自主命名。你可以在任意位置调用，来改变 state 的值。每次调用，会触发组件重新渲染（这也是返回值用 <code>const</code> 非 <code>let</code> 的原因）。</li>
<li>特点：可使用多个<code>useState</code>，彼此独立。而类组件，只有一个 state，每次<code>setState</code> 要进行浅合并（内部实现）。 </li>
</ul>
<p>这个API很简单，请看下面示例(24行代码)：</p>
<pre><code class="language-jsx">import React, { useState } from &#39;react&#39;;
function Form() {
  // ES6 解构
  const [name, setName] = useState(&#39;Mary&#39;);              // State 变量 1
  const [surname, setSurname] = useState(&#39;Poppins&#39;);     // State 变量 2
  const [width, setWidth] = useState(window.innerWidth); // State 变量 3

  function handleNameChange(e) {
    setName(e.target.value);
  }

  function handleSurnameChange(e) {
    setSurname(e.target.value);
  }

  return (
    &lt;&gt;
      &lt;input value={name} onChange={handleNameChange} /&gt;
      &lt;input value={surname} onChange={handleSurnameChange} /&gt;
      &lt;p&gt;Hello, {name} {surname}&lt;/p&gt;
      &lt;p&gt;Window width: {width}&lt;/p&gt;
    &lt;/&gt;
  );
}
export default Form;</code></pre>
<blockquote>
<p><code>&lt;&gt;&lt;/&gt;</code> 是 <code>React.Fragment</code> 的简写语法。</p>
</blockquote>
<p>用class类实现的话（31行代码），上述代码相当于：</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
class Form extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      name: &#39;Mary&#39;,
      surname:&#39;Poppins&#39;,
      width: window.innerWidth
    };
  }
  handleNameChange = (e) =&gt; {
    this.setState({ name: e.target.value });
  }

  handleSurnameChange = (e) =&gt; {
    this.setState({ surname: e.target.value });
  }

  render() {
    const { name, surname, width } = this.state
    return (
      &lt;&gt;
        &lt;input value={name} onChange={ this.handleNameChange } /&gt;
        &lt;input value={surname} onChange={ this.handleSurnameChange } /&gt;
        &lt;p&gt;Hello, {name} {surname}&lt;/p&gt;
        &lt;p&gt;Window width: {width}&lt;/p&gt;
      &lt;/&gt;
    );
  }
}
export default Form;</code></pre>
<h2 id="useState「粒度」问题"><a href="#useState「粒度」问题" class="headerlink" title="useState「粒度」问题"></a>useState「粒度」问题</h2><p>看到这里，对于写过class组件的我们，很容易产生一个疑问。 实际工作中，一个类组件的 <code>this.state</code> 中往往有十几项，用 <code>Hooks</code> 改写的话难道要写十几个 <code>useState</code> 么？</p>
<blockquote>
<p>对于这个常见问题，官方文档有<a href="http://react.html.cn/docs/hooks-faq.html#should-i-use-one-or-many-state-variables" target="_blank" rel="noopener">解答</a>。</p>
</blockquote>
<p>根据官方文档，总结下来，有几点：</p>
<ul>
<li>建议将 <code>state</code> 分割为多个 <code>useState</code>。粒度更细，更易于管理，更好复用。</li>
<li>可能一起改变的 <code>state</code> 可合并成一个<code>useState</code>（ 比如<code>Dom</code>元素的 <code>top</code> <code>left</code>）。</li>
<li>当 <code>state</code> 逻辑趋于复杂，建议使用 <code>reducer</code> 或 <code>Custom Hook</code> 管理（<strong>后面介绍</strong>）。</li>
</ul>
<p>当组件的 <code>state</code> 很多的时候，为了提高代码的可读性，也可以把逻辑相关的一些 <code>state</code> 合并为一个 <code>useState</code>（ 比如分页参数 ）。但这些 <code>state</code> 并不是一起改变的，所以当其中一个 <code>state</code> 改变，调用对应的 <code>setFunction</code> 的时候。你需要做<strong>对象合并</strong>(不合并就丢了)：</p>
<pre><code class="language-jsx">const [ pageData, setPageDate ] = useState({ pageSize: 20, current: 1, total:0, })

const onPageChange = current =&gt; {
  // 常规操作
  setPageDate( Object.assign( {}, pageData, { current } ) ）
  // 官方建议
  setPageDate(currentPageData =&gt; ({ ...currentPageData, current}));
}
</code></pre>
<blockquote>
<p>知识点：调用 useState 的更新函数时，可以传一个箭头函数，这个函数的参数是当前最新的 state， 返回值是要设置的 state 。</p>
</blockquote>
<h1 id="useEffect-hook"><a href="#useEffect-hook" class="headerlink" title="useEffect hook"></a>useEffect hook</h1><p>API 可抽象为: <code>useEffect(arrowFunction, [depsArr])</code> </p>
<ul>
<li><code>arrowFunction</code>: 必须。执行函数，执行副作用操作。它决定了做什么。</li>
<li><code>depsArr</code>: 非必须。一个依赖项数组。它决定了什么时候做（下面示例中介绍）。</li>
</ul>
<p>根据实际情况，可细分为三种：</p>
<pre><code class="language-jsx">// 第一种
// 最基础的，只有箭头函数。没有依赖项，所以组件每次渲染都会执行。
// 相当于  componentDidMount + componentDidUpdate
useEffect(() =&gt; { 
  //side-effect 
})
// 第二种
// 有依赖项，是一个空数组，因为它永远不会变，所以只会首次执行。
// 相当于 componentDidMount
useEffect(() =&gt; { 
  //side-effect 
}, [])
// 第三种
// 有第二个参数，且非空数组。首次渲染会执行。重新渲染时，只有当依赖项的值改变了才会执行。
useEffect(() =&gt; { 
  //side-effect 
}, [...state])</code></pre>
<blockquote>
<p>相当是 <code>==</code> 而非  <code>===</code>。</p>
</blockquote>
<p>总结下来：</p>
<ul>
<li>功能：管理 React 函数组件的副作用，赋予生命周期能力。</li>
<li>怎么管：组件每次渲染到屏幕之后，根据依赖项的情况判断是否调用执行函数。</li>
<li>二要素：执行函数，依赖项。</li>
<li>清理机制：你可以在执行函数中返回另一个函数-<strong>清理函数</strong>，清理函数会在组件卸载的时候，会在组件重新渲染，且useEffect的依赖项值改变的时候调用。起到了 class 组件中<code>componentWillUnmount</code>的作用, 后续会在场景实例中介绍。</li>
<li>使用上：和 <code>useState</code> 一样，可使用多个。建议一个副作用对应一个 <code>useEffect</code>。</li>
</ul>
<p>根据副作用是否需要清理，<code>useEffect</code> 可分为 <strong>不需要清理的</strong> <code>useEffect</code>，和 <strong>需要清理的</strong> <code>useEffect</code>。下面，我们分别通过一些示例来直观的感受一下。</p>
<h2 id="不需要清理的场景"><a href="#不需要清理的场景" class="headerlink" title="不需要清理的场景"></a>不需要清理的场景</h2><p>有时，我们希望在 React 渲染页面之后运行一些额外的代码。 网络请求、手动修改DOM 和日志记录都是不需要清理 副作用 的常见例子。可以这么说，我们运行它们，然后可以马上忘记它们。</p>
<p>就拿官网的例子来说，一个计数器组件，计数发生改变以后，更新 <code>Dom</code> 标题。类组件是这样实现的：</p>
<pre><code class="language-jsx">
class Example extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      count: 0
    };
  }

  componentDidMount() {
    document.title = `You clicked ${this.state.count} times`; 
  }

  componentDidUpdate() {
    document.title = `You clicked ${this.state.count} times`;
  }

  render() {
    return (
      &lt;div&gt;
        &lt;p&gt;You clicked {this.state.count} times&lt;/p&gt;
        &lt;button onClick={() =&gt; this.setState({ count: this.state.count + 1 })}&gt;
          Click me
        &lt;/button&gt;
      &lt;/div&gt;
    );
  }
}</code></pre>
<p>用 <code>useEffect</code> 实现如下：</p>
<pre><code class="language-jsx">import { useState, useEffect } from &#39;react&#39;;

function Example() {
  const [count, setCount] = useState(0);
  // 第一种useEffect
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  });

  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<blockquote>
<p>规则：每一次渲染后都去运行所有的 effects 可能并不高效。（并且在某些场景下，它可能会导致无限循环。）– Dan Abramov</p>
</blockquote>
<p>这条规则告诉我们，在写无依赖的 <code>useEffect</code> 的时候，多一点思考。上面代码现在看没有问题，后续增加了其他 state 和功能以后，这个 <code>useEffect</code> 就不高效了，可改写为：</p>
<pre><code class="language-jsx">import { useState, useEffect } from &#39;react&#39;;

function Example() {
  const [count, setCount] = useState(0);
  useEffect(() =&gt; {
    document.title = `You clicked ${count} times`;
  },[count]);// 看这里
  return (
    &lt;div&gt;
      &lt;p&gt;You clicked {count} times&lt;/p&gt;
      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;
        Click me
      &lt;/button&gt;
    &lt;/div&gt;
  );
}</code></pre>
<h2 id="需要清理的场景"><a href="#需要清理的场景" class="headerlink" title="需要清理的场景"></a>需要清理的场景</h2><p>有一些场景，我们需要做副作用的清理，保证引起不必要内存泄漏。比如，手动绑定事件，订阅，定时器等。</p>
<p>以定时器为例，让我们来实现一个秒表组件。这是一个学习和理解 <code>useEffect</code> 非常有意思的例子。</p>
<p>这里，我们直接用 <code>Hooks</code> 来实现：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;

function App() {
  // 秒表开关
  const [isOn, setIsOn] = useState(false);
  // 计数
  const [timer, setTimer] = useState(0);

  useEffect(() =&gt; {
    let interval;
    //开关打开的时候才执行
    if (isOn) {
      // 通过定时器增加计数
      interval = setInterval(
        () =&gt; setTimer(timer + 1),
        1000,
      );
    }
    // 需要清除定时器
    // 不清理会如何？codesandbox中尝试，页面直接卡死
    return () =&gt; clearInterval(interval);
  }); 

  return (
    &lt;&gt;
      &lt;p&gt;{timer}&lt;/p&gt;

      {!isOn &amp;&amp; (
        &lt;button type=&quot;button&quot; onClick={() =&gt; setIsOn(true)}&gt;
          Start
        &lt;/button&gt;
      )}

      {isOn &amp;&amp; (
        &lt;button type=&quot;button&quot; onClick={() =&gt; setIsOn(false)}&gt;
          Stop
        &lt;/button&gt;
      )}
    &lt;/&gt;
  );
}

export default App;
</code></pre>
<p>运行代码，你会发现，秒表效果实现了。但是，同样的错误，故意犯了2次：既然用了定时器，为什么还要 effect 每次执行。让我们来分析下上面代码的执行流程：</p>
<ul>
<li>首次加载：effect执行。因为<code>isOn</code>是<code>false</code>，所以 定时器 没有创建。</li>
<li>点击 <code>start</code> 打开开关(<code>setIsOn(true)</code>)。<code>isOn</code> 这个 state 改变，组件重新渲染。effect再次执行，此时创建定时器。</li>
<li>定时器生效，1秒后执行 <code>setTimer(timer + 1)</code>，<code>timer</code> 这个 state 改变，触发组件重新渲染（定时器也会清除）。effect再次执行，重新创建定时器。</li>
<li>一直重复上面步骤。</li>
</ul>
<p>有没有发现问题，定时器在循环创建，清除。用什么定时器，用延时器（<code>setTimeout</code>）好了。最糟糕的是，如果你忘了清除定时器，不光计数会错乱，页面也会奔溃。</p>
<p>怎么优化呢？同样的解决方案。很显然，我们的 effect 依赖 <code>isOn</code> 这个 state，所以我们可以把它作为 <code>useEffect</code> 的依赖项：</p>
<pre><code class="language-jsx">//...
useEffect(() =&gt; {
  let interval;
  if (isOn) {
    interval = setInterval(
      () =&gt; setTimer(timer + 1),
      1000,
    );
  }
  return () =&gt; clearInterval(interval);
  },[isOn]); // 看这里！！！！！！！！！
// ...</code></pre>
<p>这样是不是就ok了？拷贝代码到 codeSandBox 验证一下。what？点击 <code>start</code> ，计数器增加到 <code>1</code> 以后不动了！。<br>页面卡死了么？我们再分析一下流程：</p>
<ul>
<li>首次加载：effect 执行。因为 <code>isOn</code> 是 <code>false</code>，所以定时器没有创建。</li>
<li>点击 <code>start</code> 打开开关。<code>isOn</code> 改变，组件重新渲染。effect 的依赖项 <code>isOn</code> 也改变了，effect 再次执行。此时，<code>isOn</code> 是 <code>true</code>，定时器创建。</li>
<li>定时器生效，1秒后执行 <code>setTimer(timer + 1)</code>，<code>timer</code> 改变，触发组件重新渲染。注意了，此时 effect 的依赖项<code>isOn</code> 并没有改变，所以定时器在重新渲染后不会清除，effect 也不会再次执行。看上去这就是我们想要的，定时器还在工作。那为什么一直是 <code>1</code> 。</li>
</ul>
<blockquote>
<p>规则：React 约定 Effect 拿到的总是定义它的那次渲染中的 <code>props</code> 和 <code>state</code>。– Dan Abramov<br>我也注意到，上面的代码在 codeSandBox 中执行会看到一条告警信息：<code>React Hook useEffect has a missing dependency: &#39;timer&#39;. Either include it or remove the dependency array. You can also do a functional update &#39;setTimer(t =&gt; ...)&#39; if you only need &#39;timer&#39; in the &#39;setTimer&#39; call. (react-hooks/exhaustive-deps) -- eslint</code></p>
</blockquote>
<p>疑惑解开。这其实就是js常见的<strong>闭包</strong>，你也可以理解为这是 <code>useEffect</code> 的约定。这个非常非常重要，划重点。<br>上面的告警信息，已经明确的告诉了我们如何解决这个问题。</p>
<p>办法一： 增加依赖项 <code>timer</code> ，这样<code>timer</code> 改变也会触发重新渲染，然后 effect 都、会再次执行，定时器会拿到新的 <code>timer</code>。</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
  let interval;
  if (isOn) {
    interval = setInterval(
      () =&gt; setTimer(timer + 1),
      1000,
    );
  }
  return () =&gt; clearInterval(interval);
  },[isOn,timer]); // 看这里！！！！！！！！！</code></pre>
<blockquote>
<p>规则： 我鼓励你诚实地告知 effect 依赖作为一条硬性规则，并且要列出所有依赖。– Dan Abramov</p>
</blockquote>
<p>办法二：采用 <strong>更新函数</strong> 来改变 state。前面提到过，<code>useState</code> 的 <code>setFunction</code>中 ，可以传一个箭头函数（更新函数），这个函数的参数是当前最新的 <code>state</code>， 返回值是要设置的 <code>state</code>。</p>
<pre><code class="language-jsx">useEffect(() =&gt; {
  let interval;
  if (isOn) {
    interval = setInterval(
      () =&gt; setTimer(val =&gt; val + 1),// 看这里！！！！
      1000,
    );
  }
  return () =&gt; clearInterval(interval);
  },[isOn]); // 看这里</code></pre>
<p>发现没有，使用更新函数后，我们相当于去除了对 <code>timer</code> 的依赖。</p>
<blockquote>
<p>规则： 当我们不想增加更多依赖，可以尝试修改 effect 使得依赖更少。– Dan Abramov</p>
</blockquote>
<p>所以 方法二 优于 方法一。</p>
<p>我们来看一个实际项目中常见的副作用 - Ajax请求。在class 组件中，我们经常会用生命周期 <code>componentDidMount</code>来处理一些初始化的 Ajax 数据请求，现在我们用 useEffect 来实现。</p>
<p>比如用 <code>axios</code> 请求一个列表：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
import axios from &#39;axios&#39;;
function App() {
  const [data, setData] = useState([]);
  useEffect(() =&gt; {
    // 更优雅的方式
    const fetchData = async () =&gt; {
      const result = await axios(
        &#39;https://hn.algolia.com/api/v1/search?query=redux&#39;,
      );
      setData(result.data);
    };
    fetchData();
  }, []);
  return (
    &lt;ul&gt;
      {data.hits.map(item =&gt; (
        &lt;li key={item.objectID}&gt;
          &lt;a href={item.url}&gt;{item.title}&lt;/a&gt;
        &lt;/li&gt;
      ))}
    &lt;/ul&gt;
  );
}
export default App;</code></pre>
<blockquote>
<p>规则：useEffect 不能接收 async 作为执行函数。useEffect 接收的函数，要么返回一个能清除副作用的函数，要么就不返回任何内容。而 async 返回的是 promise。<br>useEffect 调用的函数如果依赖 state 或者 props。最好在执行函数中定义。这样依赖容易追踪。</p>
</blockquote>
<p>useEffect 的使用，看起来很简单。但是要做到不滥用，正确使用也不是那么容易。主要在使用之前要多一些思考。</p>
<h1 id="Custom-Hooks"><a href="#Custom-Hooks" class="headerlink" title="Custom Hooks"></a>Custom Hooks</h1><p>终于讲到它了， 前面已经提到过。它并不是 <code>React hooks</code> 的 API，而是<strong>自定义 hook</strong>。顾名思义，React允许你构建自己的 <code>hooks</code>。在学习完前面两个最受欢迎的 <code>hooks</code> 以后，你完全具备了实现自定义 hooks 的能力。</p>
<blockquote>
<p>官网定义： 自定义 Hook 是一个 JavaScript 函数，其名称以 ”use” 开头，可以调用其他 Hook。</p>
</blockquote>
<p>为什么需要Custom Hooks？</p>
<ul>
<li><code>useState</code> 解决了函数组件无状态的问题。</li>
<li><code>useEffect</code> 实现了副作用管理，生命周期的功能。</li>
<li><code>Custom Hooks</code> 将解决有状态（stateful）逻辑共享的问题（相当于类组件中Hoc的功能）。👇</li>
</ul>
<p>我们来到一个实际场景。如今 <code>HTML5</code> 移动应用或 <code>Web app</code> 中越来越普遍的使用了离线浏览技术，所以用 JS 检测浏览器在线/离线状态非常常见。首先，我们用 <code>React Hooks</code> 来实现这个功能：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
function App() {
  const [isOffline, setIsOffline] = useState(window.navigator.onLine);
  // 离线事件处理方法
  function onOffline() {
    setIsOffline(true);
  }
  // 在线事件处理方法
  function onOnline() {
    setIsOffline(false);
  }
  useEffect(() =&gt; {
    // 事件监听
    window.addEventListener(&#39;offline&#39;, onOffline);
    window.addEventListener(&#39;online&#39;, onOnline);
    // 清理函数
    return () =&gt; {
      window.removeEventListener(&#39;offline&#39;, onOffline);
      window.removeEventListener(&#39;online&#39;, onOnline);
    };
  }, []); // 只需要首次执行
  return (
    &lt;&gt;
       { 
         isOffline
         ? &lt;div&gt;网断已断开 ...&lt;/div&gt;
         : &lt;div&gt;网络已连接 ...&lt;/div&gt;
       }
    &lt;/&gt;
  )
}
export default App;</code></pre>
<blockquote>
<p>无论浏览器是否在线，<code>navigator.onLine</code> 属性都会提供一个布尔值。 如果浏览器在线，则设置为 <code>true</code> ，否则设置为 <code>false</code> 。</p>
</blockquote>
<p>OK，我们实现了一个很不错的功能。很明显，这个功能是可复用的，应该共享的。<br>我们把功能逻辑提取出来，把它封装成一个 <code>Custom hook</code> 就可以了：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
// 自定义 hook
function useOffline() {
  const [isOffline, setIsOffline] = useState(window.navigator.onLine);
  function onOffline() {
    setIsOffline(true);
  }
  function onOnline() {
    setIsOffline(false);
  }
  useEffect(() =&gt; {
    window.addEventListener(&#39;offline&#39;, onOffline);
    window.addEventListener(&#39;online&#39;, onOnline);
    return () =&gt; {
      window.removeEventListener(&#39;offline&#39;, onOffline);
      window.removeEventListener(&#39;online&#39;, onOnline);
    };
  }, []);
  return isOffline; // 只暴露一个 state
}

// 函数组件
function App() {
  const isOffline = useOffline();
  return (
    &lt;&gt;
       { 
         isOffline
         ? &lt;div&gt;网断已断开 ...&lt;/div&gt;
         : &lt;div&gt;网络已连接 ...&lt;/div&gt;
       }
    &lt;/&gt;
  )
}
export default App;</code></pre>
<p>现在，你应该对 <code>custom hooks</code> 有了一个直观的认识：</p>
<ul>
<li>一个函数。</li>
<li>一个use开头的函数。</li>
<li>一个使用 React hooks 封装的，处理副作用的函数。</li>
<li>一个在函数组件中引入简单，不需要调整组件结构的函数。</li>
</ul>
<p>从重构层面来说，就是把组件中的一些 <code>hooks</code> 抽离到一个函数中，再使用这个函数。这个函数就是 <code>React custom hooks</code>。</p>
<p>既然是函数，那肯定可以传参。我们来看一个常见场景：很多时候，为了用户体验，页面会本地存储用户数据，然后在页面返回的时候自动填充。现在，我们用一个传参的 <code>custom hooks</code> 来实现该场景：</p>
<pre><code class="language-jsx">import React, { useState, useEffect } from &#39;react&#39;;
// 自定义 hook,接收一个 localStorageKey 参数
const useStateWithLocalStorage = localStorageKey =&gt; {
  const [value, setValue] = useState(
    localStorage.getItem(localStorageKey) || &#39;&#39;,
  );
  useEffect(() =&gt; {
    localStorage.setItem(localStorageKey, value);
  }, [value]);
  return [value, setValue];
};
const App = () =&gt; {
  // 使用带参数的 自定义 hooks
  const [value, setValue] = useStateWithLocalStorage(
    &#39;myValueInLocalStorage&#39;,
  );
  const onChange = event =&gt; setValue(event.target.value);
  return (
    &lt;div&gt;
      &lt;input value={value} type=&quot;text&quot; onChange={onChange} /&gt;
      &lt;p&gt;{value}&lt;/p&gt;
    &lt;/div&gt;
  );
};</code></pre>
<p>书写 custom hooks 需要注意些什么呢？看官网怎么说：</p>
<ul>
<li>自定义 Hooks 是一种惯例，它自然地遵循 Hooks 设计的约定。即遵循所有你用到的 <code>Hooks</code>  的规则。</li>
<li>请使用 use 开头。这个习惯非常重要。如果没有它，我们就不能自动检查该 Hook 是否违反了 Hooks 的规则，因为我们无法判断某个函数是否包含对其内部 Hooks 的调用。</li>
</ul>
<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>顺序调用：每个组件都有一个 “内存单元” 的内部列表。它们只是 <code>JavaScript</code> 对象，你可以想象它是一个数组（实际上是一个单向链表），我们可以在其中放置一些数据。当调用 <code>useState()</code> 这样的 <code>Hook</code> 时，它读取当前单元格(或在第一次呈现时初始化它)，然后将指针移动到下一个单元格。这就是多个 <code>useState()</code> 调用各自获取独立本地状态的方式。</p>
<ul>
<li><code>Hooks</code> 的状态值都被挂载在组件实例对象 <code>FiberNode</code> 的属性中。</li>
<li><code>Hooks</code> 是用链表来保存状态的，属性保存的实际上是这个链表的头指针。</li>
<li><code>useState / useReducer</code> 的信息保存在 <code>FiberNode.memoizedState</code>属性.</li>
<li><code>useEffect</code> 也是以链表的形式挂载在 <code>FiberNode.updateQueue</code> 属性中。</li>
</ul>
<pre><code class="language-js">// react-reconciler/src/ReactFiberHooks.js
export type Hook = {
  memoizedState: any, // 最新的状态值
  baseState: any, // 初始状态值，如`useState(0)`，则初始值为0
  baseUpdate: Update&lt;any, any&gt; | null,
  queue: UpdateQueue&lt;any, any&gt; | null, // 临时保存对状态值的操作，更准确来说是一个链表数据结构中的一个指针
  next: Hook | null,  // 指向下一个链表节点
};

 const effect: Effect = {
    tag, // 用来标识依赖项有没有变动
    create, // 用户使用useEffect传入的函数体
    destroy, // 上述函数体执行后生成的用来清除副作用的函数
    deps, // 依赖项列表
    next: (null: any),
};</code></pre>
<p>想更详细的理解，请点击：<br><a href="https://juejin.im/post/5bebd1bbe51d4561ce39a23b" target="_blank" rel="noopener">React Hooks 揭秘</a><br><a href="https://segmentfault.com/a/1190000023041842" target="_blank" rel="noopener">React Hooks 原理剖析</a></p>
<h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>需要开发者遵从许多规则。理解并合理运用这些规则，能写出优雅的，可读性高的，性能好的代码。反之，很容易出现死循环，数据重复请求等问题。最让人担心的是性能，很多时候业务功能实现了，但是其实存在很多不必要的开销。</p>
<hr>
<p><strong>参考资料</strong><br><a href="http://react.html.cn/docs/hooks-intro.html" target="_blank" rel="noopener">官网-Hooks</a><br><a href="https://www.robinwieruch.de/react-hooks" target="_blank" rel="noopener">What Are React Hooks</a><br><a href="https://juejin.im/post/5dbbdbd5f265da4d4b5fe57d#heading-17" target="_blank" rel="noopener">React Hooks 详解 + 项目实战</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/11/%E5%85%B3%E4%BA%8Efetch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/%E5%85%B3%E4%BA%8Efetch/" itemprop="url">关于fetch</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T17:44:03+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>Fetch</code> 作为浏览器提供的原生 <code>AJAX</code> 接口。还是值得我们去探究一下的。这里有一篇关于<code>Fetch</code>应用特别好的博文，所以，我啥也不说了👇<br><a href="https://github.com/camsong/blog/issues/2" target="_blank" rel="noopener">传统 Ajax 已死，Fetch 永生</a></p>
<hr>
<p>你可能会说，我们用axios就好了，它也基于<code>promiss</code>。其实我也是，目前项目中都是用<code>axios</code>，还没有应用过<code>Fetch</code>。但是它们直接的区别还是应该了解一下的。发现一篇非常全面的好文，所以，我啥也不说了👇<br><a href="https://juejin.im/post/5d5e673ff265da03d2114646" target="_blank" rel="noopener">Ajax,jQuery ajax,axios和fetch介绍、区别以及优缺点</a></p>
<hr>
<p>有人吐槽Fetch:</p>
<pre><code class="language-javascript">function addUser(details) {
  return fetch(&#39;https://api.example.com/user&#39;, {
    mode: &#39;cors&#39;, //fetch 默认不启用 CORS
    method: &#39;POST&#39;,
    credentials: &#39;include&#39;, // fetch 默认情况下不会发送 cookie
    body: JSON.stringify(details), //JSON 必须先转换成字符串
    headers: {
      //必须设置 &#39;Content-Type&#39; 头部，指出实体的类型是 JSON，否则服务器会把它当做普通的字符串处理
      &#39;Content-Type&#39;: &#39;application/json&#39;,
      &#39;Accept&#39;: &#39;application/json&#39;,
      // 用于防御xsrf攻击的 X-XSRF-TOKEN 头部 必须手动添加
      &#39;X-XSRF-TOKEN&#39;: getCookieValue(&#39;XSRF-TOKEN&#39;)
    }
  }).then(response =&gt; {
    return response.json().then(data =&gt; {
      // 只会在网络错误的情况下reject 错误状态码（比如404 500 ）依然resove
      if (response.ok) {
        return data;
      } else {
        return Promise.reject({status: response.status, data});
      }
    });
  });
}</code></pre>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/28206325" target="_blank" rel="noopener">吐槽帖</a></p>
</blockquote>
<hr>
<p>个人觉得，Fetch作为原生API，<strong>纯粹</strong>是非常正确的。实际应用场景千差万别，你不能保证你默认增加的配置适应任何场景。我们只需要在实际项目做一些<strong>本土化</strong>的封装，这样所有配置均可见。即便我们用<code>axios</code>，我们也经常这么做。</p>
<hr>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noopener">官方API文档</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/11/shim%E5%92%8Cpolyfill/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/shim%E5%92%8Cpolyfill/" itemprop="url">shim和polyfill</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T16:40:47+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">工程化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在前端的世界里,<code>shim</code>和<code>polyfill</code>经常被提到。它们指的都是什么, 又有什么区别呢。我的理解是</p>
<h1 id="shim"><a href="#shim" class="headerlink" title="shim"></a>shim</h1><p>中文翻译为<strong>楔子</strong>，<strong>垫子</strong>。指一些做兼容性的库，用来弥补旧浏览器对新特性支持的不足，仅靠旧浏览器已有的API实现一些新特性，一般都会预先加载，这样新旧浏览器可以使用同一套包含新特性的代码。比如<code>es5-shim</code>是一个<code>shim</code>,它在<code>ECMAScript 3</code>的引擎上实现了<code>ECMAScript 5</code>的新特性, 而且在Node.js上和在浏览器上有完全相同的表现。</p>
<h1 id="polyfill"><a href="#polyfill" class="headerlink" title="polyfill"></a>polyfill</h1><p>中文翻译为<strong>填充物</strong>，国内称为<strong>腻子</strong>。把旧的浏览器想象成一面有了裂缝的墙，<code>polyfills</code>会帮助我们把这面墙的裂缝抹平。<code>polyfill</code>可以理解为一个用在浏览器API上的<code>shim</code>。我们通常的做法是先检查当前浏览器是否支持某个API,如果不支持的话就加载对应的<code>polyfill</code>。<br>作为前端，我们理解和使用<code>polyfill</code>其实就可以了。</p>
<blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.html.cn/archives/8339" target="_blank" rel="noopener">https://www.html.cn/archives/8339</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/11/js%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/js%E6%8E%A7%E5%88%B6%E9%A1%B5%E9%9D%A2%E6%BB%9A%E5%8A%A8/" itemprop="url">JS控制页面滚动</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T15:30:57+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%BC%E5%AE%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">兼容性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近解决一个 <code>wkwebview</code> 的兼容性问题，需要<code>JS</code>控制页面的滚动，踩了不少坑。</p>
<p>通常我们控制页面滚动用到下面几个<code>api</code>。</p>
<ul>
<li><code>window.scrollTo(x,y)</code> </li>
<li><code>window.scrollX/window.scrollY</code></li>
<li><code>window.pageYOffset/window.pageXOffset</code></li>
<li><code>document.documentElement.scrollTop</code></li>
<li><code>document.body.scrollTop</code></li>
</ul>
<h1 id="window-scrollTo-x-y"><a href="#window-scrollTo-x-y" class="headerlink" title="window.scrollTo(x,y)"></a>window.scrollTo(x,y)</h1><p>设置页面滚动。<code>IE9+ 、firefox、chrome，opera</code>均支持该方式获取页面滚动高度值，忽略Doctype规则。</p>
<h1 id="window-scrollX-Y"><a href="#window-scrollX-Y" class="headerlink" title="window.scrollX/Y"></a>window.scrollX/Y</h1><p>只读属性 <code>firefox、chrome，opera</code>支持，<code>IE</code>不支持，忽略Doctype规则</p>
<h1 id="window-pageXOffset"><a href="#window-pageXOffset" class="headerlink" title="window.pageXOffset"></a>window.pageXOffset</h1><p>只读属性 <code>IE9+ 、firefox、chrome，opera</code>均支持，忽略Doctype规则</p>
<h1 id="document-documentElement-和-document-body（划重点）"><a href="#document-documentElement-和-document-body（划重点）" class="headerlink" title="document.documentElement 和 document.body（划重点）"></a>document.documentElement 和 document.body（划重点）</h1><p>网上清一色：使用DTD定义文档时（<code>&lt;!DOCTYPE ...&gt;</code>），使用<code>document.documentElement</code>，否则 使用<code>document.body</code>。除此之外，无其他兼容问题。<br>发现问题：公司ios移动端使用wkwebview，h5页面均定义DTD<code>&lt;!DOCTYPE html&gt;</code>，所以使用了<code>document.documentElement.scrollTop</code>。结果发现部分ios手机不兼容，比如：<code>iphone xs 12.4.1</code>使用<code>document.body</code>才可以。</p>
<p><strong>至少得出结论</strong>：关于<code>document.documentElement</code> 和 <code>document.body</code>,<code>safari</code>内核不符合DTD规则，某些版本仅支持<code>document.body</code>控制滚动</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><pre><code class="language-javascript">  document.scrollingElement.scrollTop = 200 
  // 等价于
  document.documentElement.scrollTop = 200 
  document.body.scrollTop = 200 </code></pre>
<p><code>Document.scrollingElement</code>可以解决上述safari不兼容性问题, 而且更清爽。虽然这个API<code>IE</code>从<code>ie12-Edge</code>才兼容，但是移动端使用不存在兼容性问题。</p>
<h1 id="通用兼容性方案（支持桌面-移动端-IE等）"><a href="#通用兼容性方案（支持桌面-移动端-IE等）" class="headerlink" title="通用兼容性方案（支持桌面 移动端 IE等）"></a>通用兼容性方案（支持桌面 移动端 IE等）</h1><p>移动端建议使用<code>Document.scrollingElement</code>即可，想全端兼容，大而全的写法如下：</p>
<pre><code class="language-javascript">//以获取scrolltop以及设置scrolltop为例
    function getScrollTop() {
        return window.pageYOffset
           ||  document.documentElement.scrollTop  
             ||  document.body.scrollTop;
    }

    function setScrollTop(height) {
        document.documentElement.scrollTop = height;
        document.body.scrollTop = height;
        window.pageYOffset = height;
    }</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/11/GitLab-CI-CD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/11/GitLab-CI-CD/" itemprop="url">GitLab-CI/CD 基础教程(转)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-11T10:20:22+08:00">
                2020-03-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">工程化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>最近听朋友公司在使用 <code>GitLab CI/CD</code> 平台，<code>K8s</code>集群，对我来说还是很新鲜的东东。虽然是偏后端的内容，前端也很有必要了解和学习一下的。这里转载几遍专业后端经过实践总结的文章。</p>
<blockquote>
<p><a href="https://blog.stdioa.com/2018/06/gitlab-cicd-fundmental/" target="_blank" rel="noopener">基础教程（一）: 基本概率，配置流程</a><br><a href="https://blog.stdioa.com/2018/06/gitlab-cicd-deploy/" target="_blank" rel="noopener">基础教程（二）: GitLab Runner以及在Docker/k8s中部署</a><br><a href="https://blog.stdioa.com/2018/06/gitlab-cicd-usage/" target="_blank" rel="noopener">基础教程（三）: 与日常开发部署流程结合</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/03/03/Git-Hooks-Husky/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/03/Git-Hooks-Husky/" itemprop="url">Git Hooks & Husky</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-03T16:05:26+08:00">
                2020-03-03
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url" rel="index">
                    <span itemprop="name">工程化</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>众所周知，<code>javascript</code>一开始就是一种非常灵活的语言，随着新特性不断增加，框架层出不穷，加之个人的编程风格。前端代码的可维护性问题越来越突出。做一个有工程素养的前端的开发，我们要注重编码规范。做为架构或者团队的<code>leader</code>，更应该考虑编码规范的约束机制。所以做好<strong>代码风格检查（Code Linting，简称 Lint）</strong>已经成为前端团队必修课，是保障代码规范一致性的重要手段。 做好link可以有效的减少bug，提升开发效率和代码的可读性。其中，提交前<code>lint</code>更有效率。 如何着手呢？自然是从我们的代码管理工具。</p>
<h1 id="Git-hooks"><a href="#Git-hooks" class="headerlink" title="Git hooks"></a>Git hooks</h1><p>现在最流行的版本管理工具非<strong>Git</strong>莫属，<code>Git</code>本身也增加了一些<strong>hooks（钩子）</strong>，在<code>git</code>命令前置执行来阻止一些不规范的操作。</p>
<pre><code class="language-bash">$ cd .git/hooks
$ ls -a</code></pre>
<ul>
<li><code>git hooks</code>是在<code>.git/hooks</code>目录下的一些脚本文件，用于控制<code>git</code>工作的流程。</li>
<li>内置的脚本示例都是<code>shell</code>脚本，其中一些还混杂了<code>Perl</code>代码，不过，任何正确命名的可执行脚本都可以正常使用 —— 你可以用<code>Ruby</code>或<code>Python</code>，当然我们前端也可以用<code>Node</code>来编写。</li>
<li>钩子分为<strong>客户端钩子</strong>和<strong>服务端钩子</strong>。</li>
<li>客户端钩子：<code>pre-commit、prepare-commit-msg、commit-msg、post-commit</code>等，主要用于控制客户端git的提交工作流。</li>
<li>服务端钩子：<code>pre-receive、post-receive、update</code>，主要在服务端接收提交对象时、推送到服务器之前调用。</li>
<li>钩子都是以<code>.sample</code>结尾的文件名。注意这些示例脚本是不会执行的，只有重命名去掉<code>.sample</code>后才会生效。</li>
</ul>
<p>但是直接使用<code>git hooks</code>不方便在团队内推广。需要有工具自动把脚本安装到每个人的本地项目上才能生效。所以我们需要借助一些其他工具库。</p>
<h1 id="Husky"><a href="#Husky" class="headerlink" title="Husky"></a>Husky</h1><p>前端常用的<code>git hooks</code>工具有 <code>pre-commit</code> 和 <code>Husky</code>。这里我只介绍 <code>Husky</code>（更全面一些）。</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>husky</code>利用 <code>git hooks</code>会在相关命令执行前执行的特性，<strong>取而代之</strong>。</p>
<pre><code class="language-javascript">#!/bin/sh
# husky
export HUSKY_GIT_PARAMS=&quot;$*&quot;
node_modules/run-node/run-node ./node_modules/husky/lib/runner/bin `basename &quot;$0&quot;`
...
</code></pre>
<ul>
<li><p><code>husky</code> 使用了自定义的安装过程：<code>node lib/installer/bin install</code>（在<code>node_modules/husky/package.json</code>里）。执行的时会在项目的<code>.git/hooks</code> 目录生成所有 <code>hook</code> 的脚本（你自定义的<code>hook</code>脚本，<code>husky</code>不会覆盖）。</p>
</li>
<li><p>每个<code>hoo</code>k脚本都是一样的, 关键的部分是 <code>bashname &quot;$0&quot;</code>，这样可以拿到当前的 <code>hook</code>名，如<code>pre-commit</code>、<code>pre-push</code>。</p>
</li>
<li><p>最后根据<code>package.json</code>的配置，执行我们定义的，相对应的<code>hook</code>脚本（我们可以用<code>node</code>写）。</p>
</li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre><code class="language-javascript">npm install husky --save-dev
// 或者
yarn add husky --dev</code></pre>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre><code class="language-javascript">//package.json文件
&quot;husky&quot;: {
  &quot;hooks&quot;: {
    &quot;pre-commit&quot;: &quot;eslint&quot;,
    &quot;commit-msg&quot;: &quot;node preCommit.js&quot;  // 可以集成到自己框架的的cli中，比如：luna preCommit
  }
}</code></pre>
<ul>
<li>当你<code>git commit</code>的时候，会触发<code>hook（pre-commit）</code>，<code>husky</code>将会执行对应配置<code>(pre-commit)</code>里的<code>eslint</code>命令，没有问题才提交。</li>
<li>当你<code>git commit</code>的时候，会触发<code>hook (commit-msg)</code>，<code>husky</code>将会执行对应配置<code>(commit-msg)</code>里的<code>preCommit.js</code>脚本，没有问题才提交。</li>
</ul>
<h2 id="实际应用场景一：Commit-message格式校验"><a href="#实际应用场景一：Commit-message格式校验" class="headerlink" title="实际应用场景一：Commit message格式校验"></a>实际应用场景一：Commit message格式校验</h2><p>上面配置中的<code>preCommit.js</code>文件是按公司要求，校验提交的<code>message</code>必须符合规定格式的脚本，代码如下：</p>
<pre><code class="language-javascript">/*
* 功能： git commit时，自动验证提交信息是否符合规范
* 提交规范： 范式 {ir_key}:  {subject_content}.例如：&quot;STY-ABCD-TY-76379:某个功能开发&quot;
* 主要是读取 .git/COMMIT_EDITMSG 这个文件，文件记录了当前commit之后的信息
*/
const fs = require(&#39;fs&#39;);
const chalk = require(&#39;chalk&#39;);

const warning = chalk.keyword(&#39;red&#39;);
const msg = chalk.keyword(&#39;yellow&#39;);
// const link = chalk.hex(&#39;#00bfff&#39;);

const pattern = /^((STY|DTK)-ABCD-TY-)\d{5}:[^]/;
const commitMsg = fs.readFileSync(process.env.HUSKY_GIT_PARAMS, &#39;utf-8&#39;).trim();

if (!pattern.test(commitMsg.toUpperCase())) {
  console.log(msg(`\nYour commit message: ${commitMsg}\n`));
  console.log(warning(&#39;-----------------------Git提交Message不符合规范------------------------------\n&#39;));
  console.log(msg(&#39;范式：{ir_key}: {subject_content}。“ir_key”不区分大小写，“冒号”必须半角英文\n&#39;));
  console.log(msg(&#39;示例1：DTK-ABCD-TY-76379: 某个bug fix\n&#39;));
  console.log(msg(&#39;示例2：STY-ABCD-TY-76379: 某个功能开发\n&#39;));
  console.log(warning(&#39;-----------------------------------------------------------------------------\n&#39;));
  process.exit(1);
}
process.exit(0);
</code></pre>
<h2 id="实际应用场景二：Commit-msg自动格式化"><a href="#实际应用场景二：Commit-msg自动格式化" class="headerlink" title="实际应用场景二：Commit msg自动格式化"></a>实际应用场景二：Commit msg自动格式化</h2><p>我们公司<code>commit msg</code>要求范式：<code>{ir_key}: {subject_content}</code>。即具体信息前面要加<code>ir_key:</code>(需求号)。那我们如何自动在msg前面添加<code>{ir_key}:</code>。只需解决两个问题：</p>
<ul>
<li>如何修改<code>commit msg</code></li>
<li><code>ir_key</code>从哪里读取</li>
</ul>
<h3 id="解决思路："><a href="#解决思路：" class="headerlink" title="解决思路："></a>解决思路：</h3><ul>
<li>从场景一代码了解到，当前<code>commit</code>的<code>msg</code>是通过<code>git/COMMIT_EDITMSG</code> 这个文件获取。那我们可以通过<code>hooks</code>修改这个文件的内容，便可以修改<code>msg</code>。</li>
<li>同样，我们可以参考以上<code>git</code>的策略，我们只要把<code>ir_key</code>存在一个本地文件中，<code>commit</code>的时候读取即可。</li>
</ul>
<h3 id="具体方案："><a href="#具体方案：" class="headerlink" title="具体方案："></a>具体方案：</h3><p>我在项目的公共工具库项目新增了两个<code>cli</code>命令。</p>
<ul>
<li><code>irk &lt;ir_key&gt;</code>: 独立使用。后面带参数，且参数符合msg规范，则存入本地数据文件<code>.git/msg</code>(这样不会提交到远程，也无需再加.gitignore)；无参数，则读取<code>.git/msg</code>，打印<strong>当前分支</strong>的<code>ir_key</code>存储情况。数据文件中<code>ir_key</code>是按分支存储的。</li>
<li><code>commit-msg-init</code>: 配合hook<code>commit-msg</code>使用。首先校验当前msg是否合规，如果不合规，且存在<strong>当前分支</strong>的<code>ir_key</code>缓存数据，则在当前<code>msg</code>前拼接<code>ir_key</code>, 存入<code>git/COMMIT_EDITMSG</code>文件。<br>使用效果如下：<img src="/2020/03/03/Git-Hooks-Husky/irk1.png" class="" title="irk">
<img src="/2020/03/03/Git-Hooks-Husky/irk2.png" class="" title="commit">

</li>
</ul>
<p><code>irk</code>核心代码如下：</p>
<pre><code class="language-javascript">  try {
    // 获取当前分支号
    const branchName = getBranchName()
    // 读取本地数据缓存文件: .git/msg
    let dataObj = getFileObj(tempFilePath);
    // ir_key 需符合格式
    const pattern = /^((STY|DTK|BUG)-ABCD-(TY|GJ)-)\d{5}/;
    // 读取参数
    const param = process.argv[2];
    // 有参数set，无参数get
    if ( param ) {    
      if (!pattern.test(param.toUpperCase())) {
        // 不符合格式报错
        console.log(warning(&#39;Wrong irk, Need to match:/^((STY|DTK|BUG)-ABCD-(TY|GJ)-)\d{5}/\n&#39;))
      } else {
        // 写入或复写
        dataObj[branchName] = param;
        setIrk(dataObj)
      }
    } else {
      //读取显示
      if (dataObj[branchName]) {
        console.log(msg(`irk: ${dataObj[branchName]} \n`))
      } else {
        console.log(msg(&quot;No irk for current branch&quot;))
      }
    }
  } catch (err) {
    console.log(warning(&#39;Process err: &#39; + err))
  }</code></pre>
<p><code>commit-msg-init</code>核心代码如下：</p>
<pre><code class="language-javascript">const fs = require(&#39;fs&#39;);
const chalk = require(&#39;chalk&#39;);
const { getBranchName, getFileObj, printMsgRuleLog } = require(&#39;../utils/utils&#39;)
const { tempFilePath } = require(&#39;../config/config&#39;)
// msg格式
const pattern = /^((STY|DTK|BUG)-ABCD-(TY|GJ)-)\d{5}:[^]/;
// 当前commit msg
const commitMsg = fs.readFileSync(process.env.HUSKY_GIT_PARAMS, &#39;utf-8&#39;);
// 获取当前分支号
const branchName = getBranchName()
// 如果当前msg不符合规范
if (!pattern.test(commitMsg.toUpperCase())) {
  // 读取本地数据缓存文件: .git/msg
  const fileObj = getFileObj(tempFilePath);
  // 如果文件有数据，并且存在当前分支的数据
  if ( fileObj &amp;&amp; fileObj[branchName] ) {
    // 拼接
    const newCommitMsg = `${fileObj[branchName]}:${commitMsg}`
    // 保险起见，二级校验拼接好的msg
    if (pattern.test(newCommitMsg.toUpperCase())){
      // 新msg写入文件
      fs.writeFileSync(process.env.HUSKY_GIT_PARAMS,newCommitMsg)
      console.log(chalk.green(`\n Formatted Message：${newCommitMsg}\n`))
      process.exit(0);
    } else {
      //打印规范日志
      printMsgRuleLog(commitMsg); 
      process.exit(1);
    }
  } else {
    printMsgRuleLog(commitMsg);
    process.exit(1);
  }
} 
process.exit(0);</code></pre>
<h2 id="实际应用场景三：Commit-文件校验"><a href="#实际应用场景三：Commit-文件校验" class="headerlink" title="实际应用场景三：Commit 文件校验"></a>实际应用场景三：Commit 文件校验</h2><p>比如限制某些类型文件，某个特定目录的文件不允许修改，删除。</p>
<blockquote>
<p>以下代码来自：<a href="https://github.com/y8n/git-hooks-node/blob/master/xgfe-ma/pre-commit.js#L45-L73" target="_blank" rel="noopener">https://github.com/y8n/git-hooks-node/blob/master/xgfe-ma/pre-commit.js#L45-L73</a> </p>
</blockquote>
<pre><code class="language-javascript">var child_process = require(&#39;child_process&#39;);
var execSync = child_process.execSync;
var spawnSync = child_process.spawnSync;
var path = require(&#39;path&#39;);

var files = getDiffFiles();
if (!files.length) {
    quit();
}
var libFiles = files.filter(function (file) {
    return isLibFiles(file.subpath) &amp;&amp; ~[&#39;d&#39;, &#39;m&#39;, &#39;c&#39;, &#39;r&#39;].indexOf(file.status);
});
if (libFiles.length) {
    console.log(&#39;[WARNING] You cannot delete/modify/copy/rename any file in lib directory！！\n&#39; +
        &#39;Listed below are thus files:&#39;);
    var libFilePaths = libFiles.map(function (file) {
        return file.subpath;
    }).join(&#39;\n&#39;);
    console.log(libFilePaths + &#39;\n&#39;);
    quit(1);
}
// 待检查的文件相对路径
var lintFiles = files.filter(function (file) {
    return !isLibFiles(file.subpath)
        &amp;&amp; !isDistFiles(file.subpath)
        &amp;&amp; ~[&#39;a&#39;, &#39;m&#39;, &#39;c&#39;, &#39;r&#39;].indexOf(file.status);
}).map(function (file) {
    return file.subpath;
});
if (!lintFiles.length) {
    quit();
}

var argv = [&#39;lint&#39;];
argv = argv.concat(lintFiles);
argv = argv.concat([&#39;-c&#39;, &#39;./.lintrc&#39;]);
var result = spawnSync(&#39;xg&#39;, argv, {stdio: &#39;inherit&#39;});
quit(result.status);

/**
 * 获取所有变动的文件,包括增(A)删(D)改(M)重命名(R)复制(C)等
 * @param [type] {string} - 文件变动类型
 * @returns {Array}
 */
function getDiffFiles(type) {
    var DIFF_COMMAND = &#39;git diff --cached --name-status HEAD&#39;;
    var root = process.cwd();
    var files = execSync(DIFF_COMMAND).toString().split(&#39;\n&#39;);
    var result = [];
    type = type || &#39;admrc&#39;;
    var types = type.split(&#39;&#39;).map(function (t) {
        return t.toLowerCase();
    });
    files.forEach(function (file) {
        if (!file) {
            return;
        }
        var temp = file.split(/[\n\t]/);
        var status = temp[0].toLowerCase();
        var filepath = root + &#39;/&#39; + temp[1];
        var extName = path.extname(filepath).slice(1);

        if (types.length &amp;&amp; ~types.indexOf(status)) {
            result.push({
                status: status, // 文件变更状态-AMDRC
                path: filepath, // 文件绝对路径
                subpath: temp[1], // 文件相对路径
                extName: extName // 文件后缀名
            });
        }
    });
    return result;
}
/**
 * 是否是lib目录下的文件
 */
function isLibFiles(subpath) {
    return subpath.match(/^src\/lib\/.*/i);
}
/**
 * 是否是dist目录下的文件
 */
function isDistFiles(subpath) {
    return subpath.match(/^dist\/.*/i);
}
/**
 * 退出
 * @param errorCode
 */
function quit(errorCode) {
    if (errorCode) {
        console.log(&#39;Commit aborted.&#39;);
    }
    process.exit(errorCode || 0);
}</code></pre>
<h1 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h1><p><strong>ESLint</strong>是一个用来识别 ECMAScript 并且按照规则给出报告的代码检测工具，使用它可以避免低级错误和统一代码的风格。它附带有大量的规则.<br>运行 <code>eslint --init</code> 之后，<code>.eslintrc</code> 文件会在你的文件夹中自动创建。你只要在文件的<code>rules</code>属性中配置你想要的规则，利用pre-commit钩子触发校验即可。它主要的特点是：</p>
<ul>
<li>使用 Espree 解析 JavaScript。</li>
<li>使用 AST 去分析代码中的模式。</li>
<li>完全插件化的。每一个规则都是一个插件并且你可以在运行时添加更多的规则。<br><a href="https://cn.eslint.org/docs/user-guide/getting-started" target="_blank" rel="noopener">eslint中文网</a></li>
</ul>
<h1 id="Lint-staged"><a href="#Lint-staged" class="headerlink" title="Lint-staged"></a>Lint-staged</h1><p>直接触发eslint进行代码检测有一个问题：引入初期，你只改了文件 A，但是文件 B、C、D …中也有大量错误。你基本上没有时间和勇气去fix所有lint错误。这个时候，很多同学（包括我）选择 <code>git commit -m &quot;fix bug&quot; --no-verify</code>来逃避。只是‘很负责任’的把文件A的错误解决。<br>如果每次提交只检查本次提交所修改的文件，上面的痛点就解决了。<code>lint-staged</code>的开发者就是基于这个想法，其中 <code>staged</code> 是<code>Git</code>里面的概念，指<strong>待提交区</strong>，使用 <code>git commit -a</code>，或者先 <code>git add</code> 然后 <code>git commit</code> 的时候，你的修改代码都会经过待提交区。<br>安装依赖：</p>
<pre><code class="language-javascript">npm install lint-staged --save-dev
// 或者
yarn add lint-staged --dev</code></pre>
<p>引入<code>Lint-staged</code>之后, 之前的<code>husky</code>配置升级如下：</p>
<pre><code class="language-javascript">//package.json文件
&quot;husky&quot;: {
  &quot;hooks&quot;: {
    &quot;pre-commit&quot;: &quot;lint-staged&quot;,  // 看这里
    &quot;commit-msg&quot;: &quot;node preCommit.js&quot; 
  }
},
&quot;lint-staged&quot;: {                  // 和这里
  &quot;src/**/*.js&quot;: &quot;eslint&quot;
}</code></pre>
<h1 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h1><p><code>prettier</code> 是业界主流的代码风格<strong>格式化</strong>工具。虽然用<code>eslint —fix</code>也可以进行代码格式化，但是eslint已经配置繁多。我们还是用eslint检查代码，用<code>prettier</code>来格式化代码。<strong>术业有专攻</strong>。</p>
<ul>
<li>你可以在vscode安装<code>Prettier- Code formatter</code>插件。默认快捷键是<code>alt + shift + f</code>。安装成功后，编辑器的配置<code>setting.json</code>会出现<code>prettier</code>插件的相关配置节点，同时也能看到一些默认的配置信息。</li>
<li>实际项目中<strong>推荐</strong>在根目录创建<code>.prettierrc</code>文件配置（比配置在<code>Package.json</code>更独立）来使用，这样配置可以集成到脚手架，保证所有项目规则统一。</li>
</ul>
<p>常用配置如下：</p>
<pre><code class="language-javascript">module.exports = {
  &quot;printWidth&quot;: 80, //一行的字符数，如果超过会进行换行，默认为80
  &quot;tabWidth&quot;: 2, //一个tab代表几个空格数，默认为80
  &quot;useTabs&quot;: false, //是否使用tab进行缩进，默认为false，表示用空格进行缩减
  &quot;singleQuote&quot;: false, //字符串是否使用单引号，默认为false，使用双引号
  &quot;semi&quot;: true, //行位是否使用分号，默认为true
  &quot;trailingComma&quot;: &quot;none&quot;, //是否使用尾逗号，有三个可选值&quot;&lt;none|es5|all&gt;&quot;
  &quot;bracketSpacing&quot;: true, //对象大括号直接是否有空格，默认为true，效果：{ foo: bar }
  &quot;parser&quot;: &quot;babylon&quot; //代码的解析引擎，默认为babylon，与babel相同。
}</code></pre>
<p>更多配置，可以参考官网：<a href="https://prettier.io/docs/en/index.html" target="_blank" rel="noopener"> prettier 官网</a></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.ctolib.com/docs-Git-Chinese-Course-c-index.html" target="_blank" rel="noopener">Git hooks文档</a><br><a href="https://segmentfault.com/a/1190000007820338" target="_blank" rel="noopener">用 Node.js 写前端自己的 Git-hooks</a><br><a href="https://www.ruanyifeng.com/blog/2015/05/command-line-with-node.html" target="_blank" rel="noopener">阮一峰-Node.js 命令行程序开发教程</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/02/25/%E5%85%BC%E5%AE%B9%E7%AC%94%E8%AE%B02/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/%E5%85%BC%E5%AE%B9%E7%AC%94%E8%AE%B02/" itemprop="url">兼容问题笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T18:42:35+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%85%BC%E5%AE%B9%E6%80%A7/" itemprop="url" rel="index">
                    <span itemprop="name">兼容性</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本文是记录一些自己在工作中实际遇到和解决的一些兼容性问题。</p>
<h1 id="【safari】window-open无效"><a href="#【safari】window-open无效" class="headerlink" title="【safari】window.open无效"></a>【safari】window.open无效</h1><p>window.open被广告商滥用，严重影响用户的使用，Safari安全机制将其默认拦截。</p>
<h3 id="nbsp-nbsp-解决方案"><a href="#nbsp-nbsp-解决方案" class="headerlink" title="&nbsp;&nbsp;解决方案"></a>&nbsp;&nbsp;解决方案</h3><ul>
<li><strong>window.location.assign()</strong> 新开页面（add一个 history）</li>
<li><strong>window.location.replace（或改变 href）</strong> 替换当前页</li>
</ul>
<hr>
<h1 id="【Android】物理返回键-H5监听拦截"><a href="#【Android】物理返回键-H5监听拦截" class="headerlink" title="【Android】物理返回键 H5监听拦截"></a>【Android】物理返回键 H5监听拦截</h1><h3 id="拦截场景"><a href="#拦截场景" class="headerlink" title="拦截场景"></a>拦截场景</h3><p>网页本身有返回按钮，有特殊返回逻辑。<br>用户为了方便，会使用安卓手机自带的物理返回键，页面就会按照你浏览器<strong>history</strong>栈存储的路径来一层层返回。<br>网页本身设计期望的返回逻辑没有执行，被破坏。</p>
<h3 id="pushState方法"><a href="#pushState方法" class="headerlink" title="pushState方法"></a>pushState方法</h3><p>  <strong>window.history.back()</strong>：移动到上一个访问页面，等同于浏览器的后退键。<br>  <strong>window.history.forward()</strong>：移动到下一个访问页面，等同于浏览器的前进键。<br>  <strong>window.history.go(num)</strong>：接受一个整数作为参数，移动到该整数指定的页面，比如go(1)相当于forward()，go(-1)相当于back()。<br>  <strong>window.history.pushState()</strong>：HTML5新增，在页面中创建一个 history 实体。直接添加到历史记录中。<br>  <strong>window.history.replaceState()</strong>：HTML5新增，用来在浏览历史中修改记录。</p>
<p>  <strong>window.history.pushState(state, title, utl)</strong><br>    <strong>state</strong>：一个与指定网址相关的状态对象，popstate事件触发时，该对象会传入回调函数。如果不需要这个对象，此处可以填null。<br>    <strong>title</strong>：新页面的标题，但是所有浏览器目前都忽略这个值，因此这里可以填null。<br>    <strong>url</strong>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。<br>    <strong><em>注：pushState方法不会触发页面刷新，只是导致history对象发生变化，地址栏会有反应。</em></strong></p>
<h3 id="popstate事件"><a href="#popstate事件" class="headerlink" title="popstate事件"></a>popstate事件</h3><ol>
<li>当活动历史记录条目更改时，将触发<strong>popstate</strong>事件。</li>
<li>调用<strong>history.pushState()</strong>或<strong>history.replaceState()</strong>不会触发<strong>popstate</strong>事件。只有在做出浏览器动作时，才会触发该事件，如用户点击浏览器的回退按钮（或者在JS代码中调用<strong>history.back()</strong>或者<strong>history.forward()</strong>方法）。</li>
<li>不同的浏览器在加载页面时处理<strong>popstate</strong>事件的形式存在差异。页面加载时<strong>Chrome</strong>和<strong>Safari</strong>通常会触发(emit)<strong>popstate</strong>事件，但<strong>Firefox</strong>则不会。</li>
</ol>
<h3 id="拦截原理："><a href="#拦截原理：" class="headerlink" title="拦截原理："></a>拦截原理：</h3><p>利用<strong>pushState</strong>方法和他不会触发<strong>popstate</strong>事件的特点<em>（安卓物理返回键会）</em>。</p>
<ol>
<li><strong>页面A</strong>，先调用<strong>pushState()</strong>，创建一个历史<strong>（B1）</strong>，页面不会刷新。</li>
<li>监听<strong>popstate</strong>事件。</li>
<li>物理返回，回到A（拦截目的达到）。再次返回就会到A的上一个页面，所以需要4如下。</li>
<li>此时触发<strong>popstate</strong>事件，再处理方法中再次调用<strong>pushState()</strong>，创建一个历史<strong>（B2）</strong>。</li>
<li>下次物理返回，总是在<strong>A</strong>页面，如此循环</li>
</ol>
<pre><code class="language-javascript">  window.history.pushState(null, null, &quot;#&quot;);
  window.addEventListener(&quot;popstate&quot;, function(e) {
    window.history.pushState(null, null, &quot;#&quot;);
    // 拦截了物理返回 ，同时也拦截了浏览器返回，history（back forward go）返回
  })</code></pre>
<h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ol>
<li>如果项目本身使用了<strong>pushState</strong>，则历史记录会有瑕疵（多了一个历史）</li>
<li>浏览器的后退按钮点击以及调用<strong>history.back()</strong>也会被当成按下了返回键</li>
</ol>
<hr>
<h1 id="【iOS】页面返回不刷新"><a href="#【iOS】页面返回不刷新" class="headerlink" title="【iOS】页面返回不刷新"></a>【iOS】页面返回不刷新</h1><h3 id="场景-转盘抽奖"><a href="#场景-转盘抽奖" class="headerlink" title="场景-转盘抽奖"></a>场景-转盘抽奖</h3><ol>
<li>页面<strong>A</strong>点击抽奖，转盘转动，同时调用抽奖接口。</li>
<li>接口返回401，跳页面<strong>B</strong>登录，登录成功，或点击返回按钮，返回页面<strong>A</strong>。</li>
<li>页面<strong>A</strong>转盘依然在转动,期望是已经停止转动。</li>
</ol>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>页面在<strong>非激活状态（hidden）</strong>的时候，触发<strong>visibilitychange</strong>事件，注入停转逻辑。</p>
<pre><code class="language-javascript">  const hiddenProperty = &#39;hidden&#39; in document ? &#39;hidden&#39; :    
      &#39;webkitHidden&#39; in document ? &#39;webkitHidden&#39; :    
      &#39;mozHidden&#39; in document ? &#39;mozHidden&#39; :    
      null;
  const visibilityChangeEvent = hiddenProperty.replace(/hidden/i, &#39;visibilitychange&#39;);
  const onVisibilityChange = function(){
    if (document[hiddenProperty]) {    
      console.log(&#39;页面非激活&#39;);
      // 转盘停止
      if (that.turning) {
        that.stopTurning()
      }
    }
  }
  document.addEventListener(visibilityChangeEvent, onVisibilityChange);</code></pre>
<h3 id="解决方案二（来自网友，未亲自验证）"><a href="#解决方案二（来自网友，未亲自验证）" class="headerlink" title="解决方案二（来自网友，未亲自验证）"></a>解决方案二（来自网友，未亲自验证）</h3><p><strong>window.onpageshow事件</strong> ：在每次加载页面时都会触发，类似于 <strong>onload</strong> 事件，但是<strong>onload</strong> 事件在页面第一次加载时触发，在页面从浏览器缓存中读取时不触发。</p>
<pre><code class="language-javascript">...
isIOS &amp;&amp;
window.onpageshow = function(event) {
  if (event.persisted) {
      window.location.reload()
  }
};</code></pre>
<hr>
<h1 id="【Wkwebview】虚拟键盘将页面顶出视窗，收起后页面未下移"><a href="#【Wkwebview】虚拟键盘将页面顶出视窗，收起后页面未下移" class="headerlink" title="【Wkwebview】虚拟键盘将页面顶出视窗，收起后页面未下移"></a>【Wkwebview】虚拟键盘将页面顶出视窗，收起后页面未下移</h1><ul>
<li>页面无滚动条的情况存在该问题，有滚动条正常</li>
<li>input/textarea触发软键盘，输入完成失焦后出现</li>
</ul>
<p>解决方案：基类或者AppContainer中监听全局<strong>blur</strong>事件</p>
<pre><code class="language-javascript">isIOS &amp;&amp; 
document.addEventListener(&#39;blur&#39;, event =&gt; {
  // 当页面没出现滚动条时才执行，因为有滚动条时，不会出现这问题
  // input textarea 标签才执行，因为 a 等标签也会触发 blur 事件
  if (
    document.documentElement.offsetHeight &lt;= document.documentElement.clientHeight 
    &amp;&amp; [&#39;input&#39;, &#39;textarea&#39;].includes(event.target.localName)
  ) {
    document.body.scrollIntoView 
    ? document.body.scrollIntoView() 
    : window.scrollTo(0,0) // 回顶部
  }
}, true ) // blur事件不冒泡，切记在捕获阶段执行</code></pre>
<hr>
<h1 id="【Wkwebview】软键盘遮挡input"><a href="#【Wkwebview】软键盘遮挡input" class="headerlink" title="【Wkwebview】软键盘遮挡input"></a>【Wkwebview】软键盘遮挡input</h1><h3 id="出现场景"><a href="#出现场景" class="headerlink" title="出现场景"></a>出现场景</h3><p>弹出Dialog（fixed在页面底部），input密码输入框自动聚焦，调出软键盘，Dialog未上移被软件盘遮挡。<br>历史代码，UIwebview正常。APP升级WKwebview出现的兼容性问题。</p>
<img src="/2020/02/25/%E5%85%BC%E5%AE%B9%E7%AC%94%E8%AE%B02/wkWebview1.png" class="" title="表现">

<p>Dialog 核心精简代码：</p>
<pre><code class="language-jsx">  // 封装的滑入动画ui组件，css3（animation transform）
  import Transform from &#39;../Transform/Transform&#39;
  import Mask from &#39;../Mask/Mask&#39; // 遮罩蒙层ui组件
  ...
  return (
    &lt;div
      className={classNames(&#39;ActionDialog&#39;, className)}
    &gt;
      &lt;Mask className={this.state.maskStatus} /&gt;
      &lt;Transform {...this.props}&gt;
        &lt;div className=&#39;body&#39;&gt;
          &lt;div className=&#39;title line-bottom&#39;&gt;
            &lt;i className=&#39;iconfont iconClose stat_closeTransform&#39; onClick={this.onClose} /&gt;
            {title}
          &lt;/div&gt;
          &lt;div className=&#39;content&#39;&gt;
            &lt;NumberInput
              labelName=&quot;please input password &quot;
              showBotton={true}
              className=&quot;password-input&quot;
              inputChangeCallback={(text, flag) =&gt; {
                ...
              }}
            /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
      &lt;/Transform&gt;
    &lt;/div&gt;
  )</code></pre>
<p>NumberInput 核心精简代码：</p>
<pre><code class="language-jsx">  ...
  componentDidMount() {
    this.tradingPwdHideInput.focus()
  }
  onFocus() {
    this.setState({
      focus: true
    })  
  }
  onBlur() {
    this.setState({
      focus: false
    })
  }
  ...
  render() {
    const { focus } = this.state
    const { labelName, errMsg } = this.props
    let arryDigits = [...&#39;123456&#39;]

    return (
      &lt;div className=&#39;NumberInput&#39;&gt;
        {labelName}
        &lt;input
          type=&#39;tel&#39;
          id=&#39;tradingPwdHideInput&#39;
          ref={ref =&gt; {
            this.tradingPwdHideInput = ref
          }}
          onClick={() =&gt; {
            this.tradingPwdHideInput.focus()
          }}
          onChange={this.tradingPwdChange.bind(this)}
          onBlur={() =&gt; {
            this.onBlur()
          }}
          onFocus={() =&gt; {
            this.onFocus()
          }}
        /&gt;
        &lt;ul className={classNames(&#39;numberbox&#39;, focus ? &#39;focus&#39; : null)}&gt;
          {arryDigits.map((value, index) =&gt; {
            return (
              &lt;li className={classNames({ border: focus })} key={index}&gt;
                &lt;i className=&#39;passWord&#39;&gt;{this.tradingpwd.charAt(index)}&lt;/i&gt; 
              &lt;/li&gt;
            )
          })}
        &lt;/ul&gt;
        &lt;div className=&quot;input-bottom&quot;&gt;
          &lt;div className=&quot;err-msg&quot;&gt;{errMsg}&lt;/div&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  }</code></pre>
<p>主要css：</p>
<pre><code class="language-css">/*--------ActionDialog--------------*/
.ActionDialog {
  position: fixed;
  top: 0;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100vw; 
  height: 100vh; /*注意这里*/
  z-index: 11;

  .animationEnd{
    position: absolute;
    width: 100%;
    bottom: 0;
    height: 60%;
    z-index: 12;
  }
  .content {
    width: 100%;
    height: 100%;
  }
  .body {
    position: absolute;
    z-index: 99;
    width: 100%;
    height: 100%;
  }
}
/*--------Transform--------------*/
@keyframes down-in {
  from {transform: translateY(-100%);}
  to {transform: translateY(0%);}
}
@keyframes down-out {
  from {transform: translateY(0%);}
  to {transform: translateY(100%);}
}
.down-in {
   animation:down-in .4s
}
.down-out {
   animation:down-out .4s;
}
/*---------------Mask--------------------*/
.Mask {
  position: fixed;
  z-index: 11;
  width: 100%;
  height: 100%;
  top: 0;
  left: 0;
}
/*---------------NumberInput--------------------*/
.NumberInput {
  overflow: hidden;
  position: relative;
  padding-top: 40px;
  padding-bottom: 1px; /*no*/
  width: 100%;
  background: #fff;

  input {
    position: absolute;
    left: 0; /*no*/
    z-index: 1;
    width: 80%;
    display: block;
    overflow: hidden;
    padding: 0 !important;
    background-clip: padding-box;
    font-family: Courier, monospace;
    opacity: 0.01;
    border: 0 none !important;
    box-sizing: content-box !important;
    outline: none;
    -webkit-appearance: none;
    /*解决ios光标问题 */
    color: transparent;
    text-indent: -100px;
    -webkit-transform: scale(2);
  }
  .numberbox {
    display: -webkit-box !important;
    display: -ms-flexbox !important;
    display: flex !important;
    padding: 0 !important;
    box-sizing: border-box;
    display: block;
    width: 100%; /*no*/
    height: 50px;/*no*/
    font-size: 24px; /*no*/
    border: 1px solid $color-input-border; /*no*/
    background-color: $color-bg;
    background-clip: padding-box;
    overflow: hidden;
    li {
      -webkit-box-flex: 1;
      -ms-flex: 1;
      box-flex: 1;
      position: relative;
      width: 17%;
      line-height: 50px;/*no*/
      margin-right: -1px; /*no*/
      border-right: 1px solid $color-input-border; /*no*/
      overflow: hidden;
      text-align: center;
    }
    .tradingInputshow {
      visibility: visible;
    }
    .tradingInputhide {
      visibility: hidden;
    }
    .numberboxItem {
      display: inline-block;
      width: 14px; /*no*/
      line-height: 50px;/*no*/
      font-style: normal;
      text-align: center;
      overflow: hidden;
    }
    .passWord {
      line-height: 44px; /*no*/
      font-style: normal;
    }
    .numberboxItem:empty {
      width: 12px; /*no*/
      height: 12px; /*no*/
      border-radius: 12px; /*no*/
      background-clip: padding-box;
      background-color: $color-input-text;
    }
  }
  .focus {
    border: 1px solid $color-input-border-focus; /*no*/
  }
  .border {
    border-right: 1px solid $color-input-border-focus !important;/*no*/
  }
}</code></pre>
<p>开始怀疑是Dialog弹出后自动聚焦，虚拟键盘弹出，由于Dialog有一个CSS3滑入动画（0.4s）导致。但发现手动点击input触发也有同样的问题，此时Dialog已经完全展示。<br>后续解决办法如下：</p>
<h3 id="解决办法一"><a href="#解决办法一" class="headerlink" title="解决办法一"></a>解决办法一</h3><ul>
<li><code>Iphone7 iOS 13.1.2</code> 表现为<code>Dialog</code>不上移被遮挡</li>
<li><code>Iphone8 iOS 11.1.0</code>  <code>iphone xs 12.4.1</code> 表现为<code>Dialog</code>上移250+，超出可视区域。<pre><code class="language-javascript">onFocus() {
  if (Platform.getOS().name === &#39;iOS&#39;) {
    // 200其实是虚拟键盘的高度，网上建议用ScrollHeight,但是Dialog上移会太厉害
    document.scrollingElement.scrollTop = 200;
  }
  ...
}
onBlur() {
  if (Platform.getOS().name === &#39;iOS&#39;) {
    // 失焦以后必须设为0，否则input会停留在上移以后的位置下不来
    // 副作用：Dialog关闭以后，页面也回到顶部
    // 如果要保留原来滚动位置，需要在Dialog前后增加scrollTop存储赋值逻辑
    document.scrollingElement.scrollTop = 0;
  }
  ...
}</code></pre>
<a href="">why scrollingElement</a></li>
</ul>
<h3 id="解决办法二（iphoneX-ios11-1-1）"><a href="#解决办法二（iphoneX-ios11-1-1）" class="headerlink" title="解决办法二（iphoneX ios11.1.1）"></a>解决办法二（iphoneX ios11.1.1）</h3><ol>
<li><strong>iphoneX ios11.1.1</strong>机器，上述解决办法一无效，发现根本无法设置<strong>document.documentElement.scrollTop</strong></li>
<li>发现原来的Dialog顶层DIV设置了 <strong>height：100vh</strong> 样式， 删除后正常。</li>
</ol>
<hr>
<h1 id="IOS-页面重定向-哈希丢失"><a href="#IOS-页面重定向-哈希丢失" class="headerlink" title="[IOS] 页面重定向 哈希丢失"></a>[IOS] 页面重定向 哈希丢失</h1><ul>
<li>场景：iOS手机( 包括微信，safari浏览器.chrome浏览器) 都出现。安卓手机都正常。</li>
<li>表象：访问公司短链，重定向到对应页面的长链的时候，丢失哈希。应该到详情页，结果到列表页（默认路由）。</li>
<li>原因：生成短链的长链URl使用了http，短链是https。页面重定向的时候会出现二次重定向（短链 &gt; http 长链 &gt; https 长链）。第二次重定向，哈希会丢失。</li>
<li>解决办法：<code>长链URl</code>使用<code>https</code>重新生成短链。网上看到别人解决该办法是通过哈希前面加<code>/</code>。自己测试，不成功。</li>
<li>根本原因：<code>ios</code>的<code>HSTS</code>安全机制？</li>
</ul>
<img src="/2020/02/25/%E5%85%BC%E5%AE%B9%E7%AC%94%E8%AE%B02/redirect.png" class="" title="二次重定向">

<pre><code class="language-javascript">http://{domain}/path/knowledge/#/detail?id=101 🔴 
http://{domain}/path/knowledge?locale=en_us/#/detail?id=101 🔴 
https://{domain}/path/knowledge?locale=en_us#/detail?id=101 ✅ </code></pre>
<p><a href="https://www.jianshu.com/p/ac1c192f91ff" target="_blank" rel="noopener">参考资料，上述场景验证无效</a></p>
<h1 id="Wkwebview-a链接无法跳转"><a href="#Wkwebview-a链接无法跳转" class="headerlink" title="[Wkwebview] a链接无法跳转"></a>[Wkwebview] a链接无法跳转</h1><ul>
<li>原因：<code>target=&#39;_blank&#39;</code></li>
<li>解决：删除 <code>target</code></li>
<li><code>window.open(url)</code> 同样无法跳转，改用 <code>window.location.assign(url)</code></li>
</ul>
<p><a href="https://www.jianshu.com/p/ac8ec4a0c424" target="_blank" rel="noopener">参考资料</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/02/25/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/25/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" itemprop="url">常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-25T18:30:51+08:00">
                2020-02-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%B7%A5%E5%85%B7/" itemprop="url" rel="index">
                    <span itemprop="name">工具</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="系统MAC-Linux"><a href="#系统MAC-Linux" class="headerlink" title="系统MAC/Linux"></a>系统MAC/Linux</h1><pre><code class="language-bash">$ cd
$ Pwd
$ Mkdir
$ Rm -rf
$ Ls -a
$ Chmod 777 *    // 文件/文件夹权限修改为 777 （可读可写可执行）
$ Sudo           // 使用管理员权限执行
$ alias          // 别名情况
$ curl -v &lt;url&gt;  // 模拟get请求
$ lsof           // 查看所有端口
$ lsof -i:&lt;端口&gt;  // 端口使用情况
$ kill -9 &lt;PID&gt;  // 杀进程

Control + Command + D // mac 自带词典取词翻译快捷键</code></pre>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><pre><code class="language-bash">// 生成ssh key
$ ssh-keygen
$ cat ~/.ssh/id_rsa.pub

$ Git clone 
$ Git status
$ Git branch &lt; -a &gt;
$ Git checkout &lt; branch &gt;
$ Git pull &lt; origin  branch&gt;
$ Git push &lt; origin  branch&gt;
$ Git tag &lt; tag &gt;
$ Git tag|grep 2020 // 根据2020关键字搜索tag
$ Git stash  // 备份暂存当前分支修改
$ Git log
$ Git rebase // 修改commit信息，对多个 commit 进行合并处理等
$ Git revert // 替换某次提交
$ Git reset // 撤销 某次操作
$ Git rm &lt;file&gt;  // ignore已经add的文件  </code></pre>
<h1 id="Npm"><a href="#Npm" class="headerlink" title="Npm"></a>Npm</h1><pre><code class="language-bash">$ npm init
$ npm install &lt;package&gt;
$ npm config list
$ npm config set registry  &lt;镜像地址&gt;
$ npm install -g cpm —registry=https://registry.npm.taobao.org  // 安装cnpm
&amp; cnpm sync packageName // cnpm 特有 同步包的最新版本
&amp; npm info packageName // 包信息
$ npm link
$ npm login // 同 adduser, add-user
$ npm whoami
$ npm publish
$ npm owner ls &lt;projectName&gt;  // 已经在项目目录下 可省略projectName 下面一样
$ npm owner add &lt;userName&gt; demo
$ npm owner rm &lt;userName&gt; demo
$ npm version patch | minor | major 更改版本号
$ npm view &lt;package&gt; version 查看包所有版本</code></pre>
<h1 id="Yarn"><a href="#Yarn" class="headerlink" title="Yarn"></a>Yarn</h1><pre><code class="language-bash">$ Yarn &lt; install &gt;
$ Yarn add
$ Yarn global add
$ Yarn install -- force // 重新拉取所有包 无需删除node_modules
$ yarn install  -- no-lockfile // 不读取或生成yarn.lock文件
$ yarn link
$ Yarn config get registry
$ Yarn cache dir
$ Yarn cache clean
$ yarn cache list —pattern vue
$ yarn login
$ yarn publish</code></pre>
<h1 id="tree"><a href="#tree" class="headerlink" title="tree"></a>tree</h1><pre><code class="language-bash">$ brew install tree 安装tree

$ tree --help
$ $ tree -a        # 显示所有
$ tree -d        # 只显示文件夹
$ tree -L n    # 按层级显示项目数，n表示层级
$ tree -I file    # 用于过滤不想要显示的文档或文件夹
$ tree &gt; xxx.md     # 将目录树输出到 xxx.md 这个文档</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/02/09/webpack%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/09/webpack%E5%9F%BA%E7%A1%80%E5%AE%9E%E8%B7%B5/" itemprop="url">webpack基础实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-09T18:36:05+08:00">
                2020-02-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr>
<ul>
<li><code>webpack</code> 是一个用于现代 <code>JavaScript</code> 应用程序的<strong>静态模块打包工具</strong>。用于前端代码的<strong>工程化</strong>。</li>
<li><code>webpack</code> 处理应用程序时，它会在内部构建一个 依赖图(<code>dependency graph</code>)，此依赖图对应映射到项目所需的每个模块，并生成一个或多个 <code>bundle</code>。</li>
<li><code>webpack + loader</code> 可以支持多种语言和预处理器语法编写的模块。<code>loader</code> 向 <code>webpack</code> 描述了如何处理非原生模块，并将相关依赖引入到你的 bundles中。</li>
<li><code>webpack</code> 还支持可自由扩展的插件( <code>plugin</code>)体系。这是 <code>webpack</code> 的 支柱 功能。插件目的在于解决 <code>loader</code> 无法实现的其他功能。</li>
<li><code>webpack</code> 天生支持如下模块类型：<code>ECMAScript</code> <code>CommonJS</code> <code>AMD</code> <code>Assets``WebAssembly</code>.</li>
</ul>
<p>接下来，我们以一个 <code>React + SASS</code> 的简单<code>web</code>项目，来学习<code>webpack</code>的基础配置。</p>
<blockquote>
<p>以下配置都是基于 <code>webpack 4.30.0</code> 。</p>
</blockquote>
<h1 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h1><hr>
<p>首先，我们要安装<code>webpack</code>系列<code>npm</code>包 (这些 <code>loader</code> 和 <code>plugins</code>，后面会逐步介绍):</p>
<pre><code class="language-js">// package.json
{
  &quot;devDependencies&quot;: {
    /** webpack **/
    &quot;webpack&quot;: &quot;4.30.0&quot;,  
    &quot;webpack-cli&quot;: &quot;3.3.12&quot;,
    &quot;webpack-dev-server&quot;: &quot;^3.7.2&quot;, // 本地调试用
    /** loader **/
    &quot;css-loader&quot;: &quot;2.1.1&quot;,
    &quot;style-loader&quot;: &quot;^2.0.0&quot;,
    &quot;file-loader&quot;: &quot;^6.2.0&quot;,
    &quot;node-sass&quot;: &quot;^4.0.0&quot;,
    &quot;sass-loader&quot;: &quot;^7.1.0&quot;,
    &quot;@babel/preset-env&quot;: &quot;7.4.3&quot;,
    &quot;@babel/preset-react&quot;: &quot;7.0.0&quot;,
    /** plugins **/
    &quot;html-webpack-plugin&quot;: &quot;4.0.0&quot;,
    &quot;mini-css-extract-plugin&quot;: &quot;^0.6.0&quot;,
    &quot;webpack-bundle-analyzer&quot;: &quot;^4.4.0&quot;
  }
}</code></pre>
<p><code>webpack</code>打包，需要做一系列的配置，而且 本地调试 和 生产打包 的配置是有一些差异的。一般情况下，我们在项目的根目录下设置两个配置文件：</p>
<pre><code class="language-js">|
|- webpack.config.js  # 生产打包
|- webpack.config.dev.js # 本地调试

// package.json
{
  //...
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;webpack-dev-server --config webpack.config.dev.js&quot;,
    &quot;build&quot;: &quot;webpack-cli&quot;
  }
  //...
}
</code></pre>
<p><code>webpack</code>配置文件可以直接返回一个<code>json</code>对象，或者一个返回<code>json</code>对象的函数。</p>
<pre><code class="language-js">// webpack.config.js
export default {
  //...
}

//or

export default () =&gt; {
  return {
    //...
  }
}
</code></pre>
<p>接下来，我们开始具体配置：</p>
<h2 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h2><p><code>web</code>项目中，我们一直有<code>主JS</code>，或者<code>入口JS</code>的概念。<code>webpack</code>要打包，构建依赖图谱。肯定也需要一个入口文件。<br><code>webpack</code> 通过 <code>entry</code> 来配置一个（或多个）入口。默认值是 <code>./src/index.js</code>。</p>
<pre><code class="language-js">const path = require(&#39;path&#39;)

module.exports = {
  entry: &#39;./src/pages/app.js&#39;
}</code></pre>
<p>或者对象，可以标示入口文件<code>name</code>（一般用于多个）</p>
<pre><code class="language-js">module.exports = {
  entry: {
    app: &#39;./src/pages/app.js&#39;
  }
}</code></pre>
<h2 id="output"><a href="#output" class="headerlink" title="output"></a>output</h2><p>有打包输入(<code>entry</code>)，就有打包输出。<br><code>webpack</code>通过 <code>output</code> 来配置输出文件信息。默认值是 <code>./dist/main.js</code>，其他生成文件默认放置在 <code>./dist</code> 文件夹中。</p>
<pre><code class="language-js">module.exports = {
  output: {
    path: path.resolve(__dirname, &#39;build&#39;),  // 指定输出目录
    filename: &#39;[name].js&#39;, // 指定输出文件名称；  [name] 动态使用entry指定的名称，对应上面是:app
  }
}</code></pre>
<p><strong>高阶配置</strong> </p>
<p>实际项目中，我们静态资源会使用<code>CDN</code>，或者通过其他特有目录引入。<br>这个时候，我们需要通过 <code>publicPath</code>来配置.</p>
<p>编译时指定：</p>
<pre><code class="language-js">module.exports = {
  output: {
    path: path.resolve(__dirname, &#39;build&#39;), 
    filename: &#39;[name].js&#39;,
    publicPath: &#39;/my-project/static/resource/&#39;,
  }
}</code></pre>
<p>运行时指定：</p>
<pre><code class="language-js">module.exports = {
  output: {
    path: path.resolve(__dirname, &#39;build&#39;), 
    filename: &#39;[name].js&#39;,
    publicPath: &#39;./&#39;, // 可随意填写，运行时会覆盖为 __webpack_public_path__ 
  }
}
// 重点在这里：
__webpack_public_path__ = window.global_info.staticCDN; 
// 如果项目在一个Java/Node容器，staticCDN 的值一般是服务端路由中读取环境变量赋予。
// 如果项目是纯前端，staticCDN的值一般是通过 域名+规则 判断确定。
</code></pre>
<h2 id="Loaders"><a href="#Loaders" class="headerlink" title="Loaders"></a>Loaders</h2><ul>
<li>面向现代<code>JS</code>，我们大都不是通过直接编写原生<code>JS</code>来开发项目，而是运用各种框架（<code>React</code>，<code>Vue</code> ……），各种<code>JS+</code>语言（<code>TS</code>，<code>JSX</code> ……），<code>ES5+</code> 语法糖等。</li>
<li>但是我们的浏览器只识别原生<code>JS</code>，虽然主流浏览器也开始兼容绝大多数<code>ES5+</code>语法，但是我们也得考虑兼容性问题。</li>
<li>所以，<code>webpack</code> 提供了 <code>loaders</code> 机制，我们可以通过使用 <code>loader</code> 用于对模块的源代码进行转换。</li>
<li>不同的模块类型，应用不同的 <code>loaders</code>。</li>
<li><code>loaders</code> 是通过 <code>module</code> 对象下的 <code>rules</code> 数组来配置。</li>
</ul>
<p><strong>简单示例：</strong></p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      { test: /\.css$/, use: &#39;css-loader&#39; }, // 对每个 .css 使用 css-loader
      { test: /\.ts$/, use: &#39;ts-loader&#39; }  // 对所有 .ts 文件使用 ts-loader
    ]
  }
}; 
</code></pre>
<ul>
<li><code>test</code>： <code>RegExp</code>，用来匹配需要处理的文件类型。</li>
<li><code>use</code>：<code>String | Object | Array</code>，指定具体的 <code>loader</code>。上述示例，使用 单个默认配置的 <code>loader</code>，可以使用<code>String</code>类型指定即可。</li>
</ul>
<p>** <code>loader</code> 可以通过 <code>options</code> 对象配置更多参数。带参数配置的单个<code>loader</code>示例：**</p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
       // 图片资源处理
      {
        test: /\.(png|jpg|jpeg|gif)$/,
        use: [
          {
            loader: require.resolve(&#39;file-loader&#39;),
            options: {   // loader参数配置
              esModule: false,
              name: &#39;./image/[name].[hash:8].[ext]&#39;
            }
          }
        ]
      }
    ]
  }
}
</code></pre>
<p>负责图片处理的 <code>loader</code> 有两种, 一般一起使用：</p>
<ul>
<li><p><code>file-loader</code> 可以把<code>js</code>和<code>css</code>中导入的图片替换成正确的地址，并把图片文件输出到对应的位置。文件名是根据文件内容计算出的<code>hash</code>值。</p>
</li>
<li><p><code>url-loader</code> 可以把文件通过 <code>base64</code> 编码后注入到<code>JS</code> 或者 <code>css</code>中去。图片的数据量太大，会导致<code>JS</code>和<code>CSS</code>文件变大，一般利用<code>url-loader</code>把页面需要的小图片注入到代码中去，以减少加载次数。<code>url-loader</code> 通过  <code>limit</code> 参数来控制，小于 <code>limit</code>的图片才会处理。</p>
</li>
</ul>
<p><strong>多个 <code>loader</code> 配置，将按照相反的顺序执行。以支持 <code>scss</code> 为例：</strong></p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      // 处理sass样式文件
      {
        test: /\.(css|scss)$/,
        // 使用多个 loaders；都使用默认配置；
        use: [&quot;style-loader&quot;, &quot;css-loader&quot;,&quot;sass-loader&quot;]  
      } 
    ]
  }
}
</code></pre>
<ul>
<li><code>sass-loader</code> 负责把<code>Scss</code>源码转换为<code>CSS</code>代码，再交给<code>css-loader</code>处理。</li>
<li><code>css-loader</code> 会找出 <code>@import</code> 和 <code>URL()</code> 这样的导入语句，告诉<code>webpack</code>依赖这些资源。同时还支持<code>css modules</code>，压缩<code>css</code>等功能。</li>
<li><code>style-loader</code> 会把<code>css</code>代码转换成字符串，然后注入到<code>JS</code>代码中。通过<code>JS</code>给<code>DOM</code>增加样式。也可以通过<code>plugin</code>（ <code>MiniCssExtractPlugin</code> ）把<code>css</code>提取到单独的文件中。</li>
</ul>
<p><strong>插件 (<code>plugin</code>) 可以为 <code>loader</code> 带来更多特性:</strong></p>
<pre><code class="language-js">module.exports = {
  module: {
    rules: [
      {
        test:  /\.(js|jsx)$/,
        exclude: /(node_modules)/, // 正则表达式，设置该loader需要忽略/排除的目录/文件
        use: {
          loader: &#39;babel-loader&#39;,
          options: {
            presets: [&#39;@babel/preset-env&#39;,&#39;@babel/preset-react&#39;],
            cacheDirectory: true,
            plugins: [&#39;@babel/plugin-transform-runtime&#39;,&#39;@babel/plugin-proposal-class-properties&#39;]
          }
        }
      }
    ]
  }
}</code></pre>
<ul>
<li><p><code>@babel/runtime和@babel/plugin-transform-runtime</code>：<code>babel</code> 编译时只转换语法，几乎可以编译所有时新的 <code>JavaScript</code> 语法，但并不会转化<code>BOM（浏览器）</code>里面不兼容的<code>API</code>。比如 <code>Promise</code>,<code>Set</code>,<code>Symbol</code>,<code>Array.from</code>,<code>async</code> 等等的一些API。这2个包就是来搞定这些<code>api</code>的。</p>
</li>
<li><p><code>@babel/plugin-proposal-class-properties</code>：用来解析类的属性的。</p>
</li>
<li><p>在<code>babel</code>执行编译的过程中，会从项目的根目录下的 <code>.balelrc</code> 文件中读取配置。<code>.balelrc</code>是一个<code>json</code>格式的文件，当<code>babel loader</code>配置项很多的时候可以使用。</p>
</li>
</ul>
<p>由此可见， <code>plugins</code> 可以在 <code>loader</code> 配置中配合使用。当然，也可以单独配置使用。下面，我们来详解了解一下<code>plugins</code>。</p>
<blockquote>
<p><a href="https://webpack.docschina.org/loaders/" target="_blank" rel="noopener">点击这里查看常用 Loader List</a></p>
</blockquote>
<h2 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h2><ul>
<li><p>功能： 用于解决 <code>loader</code> 无法实现的其他事，进行功能扩展。</p>
</li>
<li><p>原理：<code>webpack plugins</code> 是一个具有 <code>apply</code> 方法的 <code>JavaScript</code> 对象。<code>apply</code> 方法会被 <code>webpack compiler</code> 调用，并且在整个编译生命周期都可以访问 <code>compiler</code> 对象。你可以基于次编写自定义插件。</p>
</li>
<li><p>用法： 可以通过在 <code>webpack.config.js</code> 增加<code>Plugins</code>配置使用。也可以通过 <code>NodeAPI</code> 的形式使用。</p>
</li>
</ul>
<p>下面，我们通过几个常用的 <code>plugin</code> 来了解如何配置使用：</p>
<pre><code class="language-js">// 该插件将为你生成一个 HTML5 文件， 在 body 中使用 script 标签引入你所有 webpack 生成的 bundle。 
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)

// 一般，plugins都是通过 new 一个自身的实例来使用
// 支持option对象参数配置
module.exports = {
  plugins: [
    new HtmlWebpackPlugin({
      template: &#39;./temp.html&#39;,  // 可以自定义用于生成Html的模版文件，非必填
      filename: &#39;home.html&#39;  //  指定html文件名称；默认为 index.html
    })
  ]
}</code></pre>
<p>** 使用默认配置生成的 <code>html</code> 文件如下：**</p>
<pre><code class="language-html">&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;webpack App&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;script src=&quot;index_bundle.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;
&lt;/html&gt;</code></pre>
<blockquote>
<p>多个 <code>entry</code>，对应多个 <code>script</code> 标签。</p>
</blockquote>
<p>前面有提到，有的 <code>plugins</code> 可作为有些 <code>loader</code> 的 <code>option</code> 配置项使用。</p>
<p>还有一些插件需要在<code>Plugins</code>和<code>Loader</code>中都需要增加配置：</p>
<pre><code class="language-js">// 本插件会将 CSS 提取到单独的文件中
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

module.exports = {
  module: {
    rules: [
      {
        test: /\.(css|scss)$/,
        use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,&quot;sass-loader&quot;]
      },
    ]
  },
  plugins: [
    new MiniCssExtractPlugin({ filename: &#39;[name].css&#39;})
  ]
}</code></pre>
<blockquote>
<p>使用<code>MiniCssExtractPlugin</code> 生成的<code>css</code>文件会在生成的<code>Html</code>文件中通过<code>&lt;link&gt;</code>引入。所以不再需要使用 <code>style-loader</code>。<br><code>style-loader</code>: 将模块导出的内容作为样式并添加到 <code>DOM</code> 中。</p>
</blockquote>
<h2 id="mode"><a href="#mode" class="headerlink" title="mode"></a>mode</h2><ul>
<li><code>production</code> or <code>development</code>.用来指定是生产模式还是开发模式。</li>
<li>在代码中可以通过<code>process.env.NODE_ENV</code>获取，用来做两种模式的兼容处理。</li>
</ul>
<p>到此，我们这个简单项目的完整<code>webpack.config.js</code>配置如下：</p>
<pre><code class="language-js">const path = require(&#39;path&#39;)
const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)
const MiniCssExtractPlugin = require(&#39;mini-css-extract-plugin&#39;);

module.exports = () =&gt; {
  return {
    mode: &#39;production&#39;,
    entry: {
      app: path.resolve(__dirname, &#39;src/pages/app.js&#39;),
    },
    output: {
      path: path.resolve(__dirname, &#39;build&#39;),
      publicPath: &#39;/my-project/static/resource/&#39;,
      filename: &#39;[name].js&#39;,
    },
    resolve: {
      extensions: [&#39;.js&#39;, &#39;.jsx&#39;, &#39;.ts&#39;],
    },
    module: {
      rules: [
        {
          test: /\.(css|scss)$/,
          use: [MiniCssExtractPlugin.loader, &quot;css-loader&quot;,&quot;sass-loader&quot;]
        },
        {
          test:  /\.(js|jsx)$/,
          exclude: /(node_modules)/,
          use: {
            loader: &#39;babel-loader&#39;,
            options: {
              presets: [&#39;@babel/preset-env&#39;,&#39;@babel/preset-react&#39;],
              cacheDirectory: true,
              plugins: [&#39;@babel/plugin-transform-runtime&#39;,&#39;@babel/plugin-proposal-class-properties&#39;]
            }
          }
        },
        {
          test: /\.(png|jpg|jpeg|gif)$/,
          use: [
            {
              loader: require.resolve(&#39;file-loader&#39;),
              options: {
                esModule: false,
                name: &#39;./image/[name].[hash:8].[ext]&#39;
              }
            }
          ]
        }  
      ]
    },
    plugins: [
      new HtmlWebpackPlugin({template: &#39;./temp.html&#39;, filename: &#39;home.html&#39;}),
      new MiniCssExtractPlugin({ filename: &#39;[name].css&#39;})
    ],
    optimization: {
      splitChunks: {
        cacheGroups: {
          default: {
            name: &#39;common&#39;,
            chunks: &#39;initial&#39;
          }
        }
      }
    }
  }
}
</code></pre>
<blockquote>
<p><code>resolve.extensions</code> : 如果文件引入的时候没有后缀名，将自动按配置的文件名匹配查找。<br><code>optimization</code>: 用于提取公共<code>js</code>配置。</p>
</blockquote>
<h1 id="开发模式"><a href="#开发模式" class="headerlink" title="开发模式"></a>开发模式</h1><hr>
<p>我们在本地调试的时候，<code>webpack</code> 配置和生产会有一些差异。比如：</p>
<ul>
<li>生产可能配置特殊的<code>publicPath</code>，本地则不能配置。</li>
<li>本地调试专用的 <code>devServer</code> 配置。</li>
<li>开发模式专用的一些<code>plugins</code>。</li>
</ul>
<p>我们可以设置单独的配置文件（如 <code>webpack.config.dev.js</code>）：</p>
<pre><code class="language-js">// 下面只展示差异点配置
// new plugin 用来做打包后文件的成分分析，以做某些优化。
const BundleAnalyzerPlugin = require(&#39;webpack-bundle-analyzer&#39;).BundleAnalyzerPlugin 

module.exports = () =&gt; {
  return {
    mode: &#39;development&#39;, // 指定为开发环境
    // 下无 publicPath配置
    output: {
      path: path.resolve(__dirname, &#39;pcDist&#39;),
      filename: &#39;[name].js&#39;,
    },
    // 专用plugin
    plugins: [
      new BundleAnalyzerPlugin()
    ],
    // 本地调试专用配置
    devServer: {
      contentBase: path.join(__dirname, &#39;pcDist&#39;),
      port: 8009,
      hot:true,
      open: true
    }
  }
}
</code></pre>
<p><code>DevServer</code> 其实是一个方便开发的小型<code>http</code>服务器，是基于<code>webpack-dev-middleware</code> 和 <code>Express</code> 实现的。<code>webpack-dev-middleware</code> 会导出一个函数。该函数接收一个 <code>webpack</code> 的 <code>Compiler</code> 实例作为参数，导出一个 <code>Express</code> 中间件。该中间件具有以下功能：</p>
<ul>
<li>接收 <code>Compiler</code> 实例输出的文件，但不会存在硬盘，而是放入内存。</li>
<li>往 <code>Express</code> <code>app</code> 上注册路由，拦截<code>http</code>请求，根据请求路径响应对应的文件。</li>
</ul>
<blockquote>
<p>明显，开发和生产配置大部分还是通用。所以在实际项目中我们使用一个通用配置文件，然后在自有的cli工具库中去抽象，处理，复用。</p>
</blockquote>
<h1 id="module-chunk-bundle理解"><a href="#module-chunk-bundle理解" class="headerlink" title="module,chunk,bundle理解"></a>module,chunk,bundle理解</h1><ul>
<li><code>moule</code> 是模块，<code>webpack</code>中一切皆模块，所以 <code>module</code> 就是我们编写的一个个文件。</li>
<li><code>chunk</code> 是指 <code>webpack</code> 根据文件引用关系生成的 <code>chunk</code> 文件。一般来说，一个 <code>entry</code> 对应一个 <code>chunk</code> 文件。</li>
<li><code>bundle</code> 是指 <code>webpack</code> 最终生成的浏览器可以直接运行的 <code>bundle</code> 文件。一般来说，一个 <code>chunk</code> 对应一个 <code>bundle</code> 文件。但是也有例外，比如我们使用 <code>MiniCssExtractPlugin</code> 插件会从一个 <code>chunk</code> 中抽取出单独的 <code>css bundle</code>文件。</li>
</ul>
<h1 id="webpack-异步加载"><a href="#webpack-异步加载" class="headerlink" title="webpack 异步加载"></a>webpack 异步加载</h1><hr>
<p>在使用 <code>webpack</code> 打包的应用中，我们可以使用 <code>require.ensure</code> 进行异步加载，也有人称为代码切割。他其实就是将指定的 <code>js</code> 模块独立导出一个<code>.js</code> 文件，然后使用这个模块的时候，再创建一个 <code>script</code> 对象，加入到 <code>document.head</code> 对象中，浏览器会自动帮我们发起请求，去请求这个 <code>js</code> 文件，然后写个回调函数，让请求到的 <code>js</code> 文件做一些业务操作。</p>
<p><code>require.ensure</code> 这个函数是一个代码分离的分割线，表示回调里面的 <code>require</code> 是我们想要进行分割出去的，<code>webpack</code> 会打包成单独 <code>js</code> 文件。它的语法如下：</p>
<pre><code class="language-js">// 语法如下：
`require.ensure(dependencies: String[], callback: function(require), chunkName: String)`</code></pre>
<h2 id="按需加载"><a href="#按需加载" class="headerlink" title="按需加载"></a>按需加载</h2><p><code>webpack4</code> 官方文档提供了模块按需切割加载，配合 <code>es6</code> 的按需加载 <code>import()</code> 方法，可以做到减少首页包体积，加快首页的请求速度，只有其他模块，只有当需要的时候才会加载对应 <code>js</code>。</p>
<p><code>import()</code>的语法十分简单。该函数只接受一个参数，就是引用包的地址，并且使用了 <code>promise</code> 式的回调，获取加载的包。在代码中所有被 <code>import()</code>的模块，都将打成一个单独的包，放在 <code>chunk</code> 存储的目录下。在浏览器运行到这一行代码时，就会自动请求这个资源，实现异步加载。</p>
<h1 id="常用的优化手段"><a href="#常用的优化手段" class="headerlink" title="常用的优化手段"></a>常用的优化手段</h1><ul>
<li><p>优化<code>loader</code>配置： 通过 <code>include</code> 等配置，不需要处理的文件尽量不处理。</p>
</li>
<li><p>异步按需加载:（上面有专门提到）。</p>
</li>
<li><p>分包：提取公共的一些模块 + 缓存提高性能。</p>
<ul>
<li><code>SplitChunksPlugin</code>: 提取公共模块，问题是业务模块依赖改变也会影响公共包，哈希会改变，缓存会失效。</li>
<li><code>Dllplugin &amp; DllReferencePlugin</code>: 将指定的公共模块打包成动态链接库形式的js文件。其他模块引用到这些指定的公共模块会直接在公共js文件中加载，不会打包在业务模块中。问题是这些动态链接库文件要独立先行打包，并提前引入。</li>
</ul>
</li>
<li><p><code>Tree Shaking</code>: webpack依赖静态的 ES6 模块化语法，分析出都要哪些功能被用到了，然后剔除没有的代码。可以在启动 <code>Webpack</code> 时带上 <code>--optimize-minimize</code> 参数，快速接入 <code>Tree Shaking</code>；也可以使用 <code>UglifyJSPlugin</code> 来处理。</p>
</li>
<li><p><code>Scope Hoisting</code>（作用域提升）: 分析出模块之间的依赖关系，尽可能的把打散的模块合并到一个函数中去，但前提是不能造成代码冗余。因此只有那些被引用了一次的模块才能被合并。</p>
<ul>
<li>使用内置的 <code>ModuleConcatenationPlugin()</code> 即可开启。</li>
</ul>
</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><hr>
<ul>
<li><a href="https://webpack.js.org/concepts/" target="_blank" rel="noopener">webpack官网</a></li>
<li><a href="https://webpack.docschina.org/concepts/" target="_blank" rel="noopener">webpack中文网</a></li>
<li><a href="https://webpack.wuhaolin.cn" target="_blank" rel="noopener">深入浅出webpack</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1551693" target="_blank" rel="noopener">轻松理解webpack热更新原理</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/01/19/micro-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/19/micro-service/" itemprop="url">微前端入门Micro-frontends</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-19T16:59:37+08:00">
                2020-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="微前端资料"><a href="#微前端资料" class="headerlink" title="微前端资料"></a>微前端资料</h2><p>我认为比较好的<strong>微前端</strong>思想技术体系文献资料:<br>参考资料：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/micro-frontends-1.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/micro-frontends-1.md</a><br>原文资料：<a href="https://martinfowler.com/articles/micro-frontends.html" target="_blank" rel="noopener">https://martinfowler.com/articles/micro-frontends.html</a><br>文章大量引用了上述文献资料的第一部分，对许多翻译生硬的地方加以润色，难理解的点增加注释，并穿插加入一些个人观点。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知，前端的世界瞬息万变。新的语言，框架库，思想层出不穷，让人应接不暇。其中许多了解一下即可，但是对去现在比较火热的“微前端（MircroFrontends）”,还是值得去了解和研究一下的。大家对于前端的不断探索研究甚至创造，我觉得无非两个目的。一是尝试拓展前端的边界（创造更多可能）；二是前端已有领域的不断优化（效率，维护性，质量，管理成本）。很明显，微前端是后者。那接下来，我们了解一下什么是微前端，探讨一下它如何解决和优化前端领域一些问题的。</p>
<h2 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h2><p>微前端首先是一种（管理）思想。将前端整体<strong>分解</strong>为小而简单模块的一种模式。这些块可以独立开发、测试和部署。<br>与此同时，我们仍然需要把模块<strong>聚合</strong>为一个产品出现在客户面前。我们将这种技术也称为微前端。<br>所以微前端是一种管理思想和集成技术结合的产物，我们将其定义为：</p>
<blockquote>
<p>一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格</p>
</blockquote>
<p>简而言之，微前端都是将巨大的东西分成更小、更易于管理的小部分，然后明确它们之间的依赖关系。我们的技术选择、代码库、团队以及发布流程都应该能够彼此独立地运行和开发，不需要过多的协调。我认为好的微前端要做好两件事情（微前端也分两步）：</p>
<ul>
<li>分解（业务层面）：保证业务的合理拆分，并理清它们直接的依赖交互关系。</li>
<li>聚合（技术层面）：架构层面，要在技术上做到很好的聚合，保证彼此独立，不相互污染，又能合理通信。</li>
</ul>
<p>使用场景主要有：</p>
<ul>
<li>拆分巨型应用，使应用变得更加可维护。</li>
<li>兼容历史应用，实现增量开发。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>体积小、易拼合且易于维护的代码库</li>
<li>更具扩展性的互相解耦且独立的团队</li>
<li>和以前相比能采用增量的方式，更易于对前端的某些部分进行升级、更新甚至重写</li>
</ul>
<h3 id="增量升级，逐步翻新。"><a href="#增量升级，逐步翻新。" class="headerlink" title="增量升级，逐步翻新。"></a>增量升级，逐步翻新。</h3><p>  很多公司都普遍存在一个历史问题：过时的技术栈，赶工完成的代码质量，五花八门的代码风格。随着员工的更迭，新功能的不断堆积，后人维<br>护起来，看不懂，改不动，只想重写的情况日益严重。这个时候，你才明白，长江后浪推前浪，前浪原来是被后浪咒死在沙滩上的。如果这个时候，你发现这居然还是一个巨石应用……后浪也想在沙滩上自杀了。<br>  当然了，喜欢折腾的前端没那么脆弱，当然还是要解决这个问题。我相信，这个时候就已经诞生了微前端，或者说应用了微前端的管理思想-细<br>分：随着新的功能，将业务逐步在多个新应用中重构翻新。当然，也有在原应用中或者在一个新应用中想办法逐步翻新，这基本上是重蹈覆辙。</p>
<h3 id="简单、解耦的代码库"><a href="#简单、解耦的代码库" class="headerlink" title="简单、解耦的代码库"></a>简单、解耦的代码库</h3><p>每个单独的微前端项目的源代码库，会远远小于一个单体前端项目的源代码库。这些小的代码库将会更易于开发。更值得一提的是，我们避免了不相关联的组件之间无意造成的不适当的耦合。通过增强应用程序的<a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">边界</a>来减少这种意外耦合的情况的出现（领域驱动设计(DDD)中抽象的限界上下文（BoundedContext）概念，不懂也不用太纠结）。</p>
<p>当然了，一个独立的、高级的架构方式（例如微前端），不是用来取代规范整洁的优秀老代码的。我们不是想要逃避代码优化和代码质量提升。相反，我们降低做出错误决策的可能，增加正确决策的几率，从而使我们Falling Into The Pit of Success<a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/" target="_blank" rel="noopener">进入成功之坑</a>（该思想大致的意思是说设计者要通过精心设计的系统或者API，让用户做正确的事变的容易，而不过于为容易犯错而苦恼。用户犯错，那就是设计者的错）。微前端会促使您明确并慎重地了解数据和事件如何在应用程序的不同部分之间传递（跨应用通信），这本是我们（微前端架构设计师）早就应该开始做的事情！</p>
<h3 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h3><p>与微服务一样，微前端的独立可部署性是关键。它减少了部署的范围，从而降低了相关风险。无论您的前端代码在何处托管，每个微前端都应该有自己的连续交付通道，该通道可以构建、测试并将其一直部署到生产环境中。我们应当能够在不考虑其他代码库或者是通道的情况下来部署每个微服务。<br>做到即使原来的单体项目是固定的按照季度手动发布版本，或者其他团队提交了未完成的或者是有问题的代码到他们的主分支上，也不会对当前项目产生影响。如果一个微前端项目已准备好投入生产，它应该具备这种能力，而决定权就在构建并且维护它的团队手中。</p>
<p><img src="https://martinfowler.com/articles/micro-frontends/deployment.png" alt="图示：三个彼此独立的应用从源代码控制开始，经过构建、测试直至部署到生产环境"></p>
<p>图 2 : 每个微前端都独立的部署到生产环境上</p>
<h3 id="自主的团队"><a href="#自主的团队" class="headerlink" title="自主的团队"></a>自主的团队</h3><p>将我们的代码库和发布周期分离的更高阶的好处，是使我们拥有了完全独立的团队，可以参与到自己产品的构思、生产及后续的过程。每个团队都拥有为客户提供价值所需的全部资源，这就使得他们可以快速且有效地行动。为了达到这个目的，我们的团队需要<strong>根据业务功能纵向地划分，而不是根据技术种类</strong>。一种简单的方法是根据最终用户将看到的内容来分割产品，因此每个微前端都封装了应用程序的单个页面，并由一个团队全权负责。与根据技术种类或“横向”关注点（如样式、表单或验证）来组成团队相比，这会使得团队工作更有凝聚力。</p>
<p><img src="https://martinfowler.com/articles/micro-frontends/horizontal.png" alt="图示：根据三个应用构成三个团队，提醒大家不要根据“样式”分队"></p>
<p>图 3：每个应用都由一个团队负责</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="负载体积"><a href="#负载体积" class="headerlink" title="负载体积"></a>负载体积</h3><p>独立构建，会造成公共依赖的重复，增加了用户所需下载依赖的体积。<br>一种解决方案是将我们编译后代码的常见依赖外置(如下代码)。一旦我们沿着这条路走下去，我们将重新引入一些微前端之间构建过程的耦合。现在它们之间有着一个隐含的合约：“我们都必须使用这些依赖的明确版本”。如果其中一个依赖产生重大改动，我们可能最终需要一个大的协调升级工作以及一次性的同步发版。这是我们使用微前端最初想要避免的一切。</p>
<p>但并不全是坏消息。首先，即便我们对于重复的依赖不采取任何措施，每个单独页面仍可能比我们构建整个前端更快地加载。原因是通过独立编译每个页面，我们有效地以我们自己的形式实现了代码分割。在传统的前端中，应用中的任何页面加载完成时，我们通常会一次性下载所有页面的源码和依赖。通过独立构建，任何单独的页面加载将只会下载那个页面的源码和依赖。这可能导致更快的首页加载，但随后的导航速度会变慢，因为用户必须在每个页面上重新下载相同的依赖。如果我们严格地不用不必要的依赖使我们的微前端膨胀，或者我们知道用户在应用中通常访问的一两个页面，即便有重复依赖，我们也很可能在性能方面达到净增益。</p>
<p>在前一段有很多“可能”和“也许”，表明了每个应用通常都有它们自己独特的性能特征。如果你想确切地知道特定的变化会造成什么性能影响，只能靠实际测量，而且最好是在生产环境中。我们见过很多团队仅仅为了下载数兆大小的高清图像或者对一个运行非常慢的数据库进行昂贵的查询额外多写几千字节的 JavaScript 代码。因此，尽管考虑每个架构决策的性能影响很重要，但请确保你知道真正的瓶颈在哪里。</p>
<pre><code class="language-javascript">  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;%REACT_APP_CONTENT_HOST%/react.prod-16.8.6.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;%REACT_APP_CONTENT_HOST%/react-dom.prod-16.8.6.min.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;</code></pre>
<h3 id="环境差异"><a href="#环境差异" class="headerlink" title="环境差异"></a>环境差异</h3><p>我们应该能够开发一个单一的微前端，而无需考虑其他团队正在开发的所有其它微前端。我们可能甚至应该在“独立”模式下，在空白页面上运行我们的微前端，而不是运行在将在生产环境中承载微前端的容器应用内部。这可以使开发变得更加简单，特别是当真正的容器是一个复杂的遗留代码库的时候，而通常情况下我们使用微前端来逐步从旧世界迁移到新世界。但是，在与生产环境完全不同的环境中开发存在风险。如果我们的开发时容器与生产容器的行为不同，那么我们可能会发现我们的微前端被破坏，或者在我们部署到生产环境时表现不同。特别值得关注的是可能由容器或其他微前端带来的全局样式。</p>
<p>这里的解决方案与我们不得不担心环境差异的任何其他情况没有什么不同。如果我们在一个与生产环境不同的本地环境开发，我们需要<strong>确保定期将我们的微前端集成和部署到像生产环境的环境中，并且我们应该在这些环境中进行测试（手动以及自动化）以尽早发现集成问题</strong>。这不会完全解决问题，但最终这是一个取舍：简化开发环境的生产力提升是否值得冒集成出问题的风险？答案取决于项目！</p>
<h3 id="运维复杂度"><a href="#运维复杂度" class="headerlink" title="运维复杂度"></a>运维复杂度</h3><p>最后的缺点是与微服务直接平行的缺点。作为一个更加分散的架构，微前端将不可避免地导致需要管理更多的东西 —— 更多的存储库，更多的工具，更多的构建/部署管道，更多的服务器，更多的域等等。因此，在采用这样的架构之前，你应该考虑几个问题：</p>
<ul>
<li>你是否有足够的自动化可行地提供以及管理额外所需的基础设施？</li>
<li>你的前端开发、测试和发布进程是否会扩展到许多应用中？</li>
<li>你是否对围绕工具和开发的实践变得更加分散且不易控制的决策感到满意？</li>
<li>你将如何确保你的多个独立前端代码库中的最低代码质量，一致性或代码管理？<br>我们可能会另写一篇文章讨论这些主题。我们希望提出的主要观点是，当你选择微前端时，根据定义，你选择创建许多小东西而不是一个整体。你应该考虑你是否有采用这种方法所需的技术和组织成熟度，从而不造成混乱。</li>
</ul>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><img src="/2020/01/19/micro-service/%E5%BE%AE%E5%89%8D%E7%AB%AF.png" class="" title="微前端技术栈">

<p>主要难点在于<strong>集成方式</strong>（公共依赖）和<strong>跨应用通信</strong>。有兴趣可以研读文章开始的参考资料2-4章节。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/08/09/React-Hoc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/React-Hoc/" itemprop="url">React 高阶组件（HOC）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T11:28:34+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><hr>
<p>如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。</p>
<pre><code class="language-jsx">// ES5 
function isSearched(searchTerm) { 
  return function(item) { 
    return item.title.toLowerCase().includes(searchTerm.toLowerCase()); 
  } 
} 

// ES6 
const isSearched = searchTerm =&gt; item =&gt; 
  item.title.toLowerCase().includes(searchTerm.toLowerCase());</code></pre>
<h1 id="React-HOC"><a href="#React-HOC" class="headerlink" title="React HOC"></a>React HOC</h1><hr>
<p>在实际项目中，组件总是趋于复杂，会包含很多逻辑。当发现在很多组件都需要处理相同逻辑的时候，就应该想办法抽象复用。在React中，具有复用功能的方式主要有：</p>
<ul>
<li>公共组件库</li>
<li>公共方法库</li>
<li>类组件：<code>HOC</code> / <code>Render Props</code></li>
<li>函数组件：<code>Hooks</code></li>
</ul>
<p>当你没法把组件中的重复逻辑抽象成公共组件或者公共方法的情况下，在类组件中，就可以考虑引入<code>HOC</code>。<a href="/2020/04/23/React-Render-Props/index.html">Render Props看这里</a>。</p>
<p>和高阶函数类似，<code>React HOC</code>就是把组件（也可增加一些可选参数）作为输入，然后输出一个新的组件，新组件内部处理一些通用逻辑，并使用输入的组件进行渲染。你可以将其视为参数化容器组件。</p>
<blockquote>
<p>我们知道，在React中函数组件本质上就是一个函数。所以高阶函数组件就是一个<code>HOC</code>。</p>
</blockquote>
<h1 id="高阶组件应用"><a href="#高阶组件应用" class="headerlink" title="高阶组件应用"></a>高阶组件应用</h1><hr>
<p>首先，我们先创建<code>HOC</code>容器：</p>
<pre><code class="language-jsx">// 无状态函数组件
function HigherOrderComponent(WrappedComponent) {
    return props =&gt; &lt;WrappedComponent {...props} /&gt;;
}
// or
// 类组件
function HigherOrderComponent(WrappedComponent) {
    return class extends React.Component {
        render() {
            return &lt;WrappedComponent {...this.props} /&gt;;
        }
    };
}
// 类组件特有的通过继承的方式使用
// 也叫 反向继承（Inheritance Inversion）
function HigherOrderComponent(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            return super.render();
        }
    };
}</code></pre>
<blockquote>
<p>通过继承输入组件形式实现的<code>HOC</code>又称为 <strong>反向继承（Inheritance Inversion）</strong></p>
</blockquote>
<p>以上<code>HOC</code>只是一个容器，和直接使用 <code>WrappedComponent</code> 组件无二。那么，我们可以在<code>HOC</code>中做点什么来达到共享复用的目的呢？主要通过以下三种方式：</p>
<ul>
<li>操作参数（props / state）</li>
<li>条件渲染</li>
<li>组件包装</li>
</ul>
<h2 id="操作参数"><a href="#操作参数" class="headerlink" title="操作参数"></a>操作参数</h2><p>我们可以通过<code>HOC</code>对一个通用组件的 <code>props</code> 做一些操作达到复用的目的，而不用去修改这个通用组件。</p>
<p>举个简单的例子，一个列表展示组件，在新需求中的某些场景只希望展示列表中 <code>status === &#39;1&#39;</code> 的数据，那我们可以封装一个<code>HOC</code>在这些场景使用，其他场景直接使用。</p>
<pre><code class="language-jsx">
function HigherOrderComponent(WrappedComponent) {
    return props =&gt; {
      let newProps =  props || []
      if (newProps.length &gt; 0){
        newProps = newProps.filter((item) =&gt; item.status === &#39;1&#39;)
      }
      return &lt;WrappedComponent {...newProps} /&gt;
    };
}</code></pre>
<p>当然，你也可以通过修改这个通用组件来适配新场景。但是一直通过修改通用组件来适配所有场景，一方面存在兼容风险，另一方面适配逻辑太多，组件会变得臃肿，很难维护。</p>
<p>在举一个常见的应用：很多页面初始化的时候，都需要通过一个接口获取一些初始化数据。我们也可以通过<code>HOC</code>封装，统一获取，然后作为扩展参数传递给页面组件。</p>
<pre><code class="language-jsx"> function HigherOrderComponent(WrappedComponent) {
    return props =&gt; {
      const fetchData = async () =&gt; {
        const result = await axios(
          &#39;https://hn.algolia.com/api/v1/search?query=redux&#39;,
        );
        return result.data;
      };
      const newProps = fetchData();
      return &lt;WrappedComponent {...props} {...newProps} /&gt;
    };
}</code></pre>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>在实际<code>React</code>项目中，大多采用前端渲染模式。组件的渲染依赖<code>Ajax</code>请求的数据。所以，我们经常会看到（我自己也写过）如下代码：</p>
<pre><code class="language-javascript">class BadComp extends React.Component {
    state = {
      isDateReady: false,
      dataA: null,
      dataB: null,
    }
    //...
    render() {
      if (!isDateReady) return false
      const { isDateReady, hasDataA, hasDataB }= this.state
      return (
        &lt;&gt;
          { dataA &amp;&amp; &lt;A {...dataA}/&gt; }
          { dataB &amp;&amp; &lt;B {...dataB}/&gt; }
        &lt;/&gt;
      );
    }
};
</code></pre>
<p>上述代码并不是一无是处，至少是严谨的，规避了无数据或者数据异常导致页面奔溃的情况。但是上述组件有两个问题：</p>
<ul>
<li>通过 <code>isDateReady</code> 阻断页面渲染，接口返回慢的话，白屏时间会很长。</li>
<li>页面充斥着太多类似 <code>{ dataB &amp;&amp; &lt;B {...dataB}/&gt; }</code> 这种逻辑，不优雅，影响可读性。</li>
</ul>
<p>解决上述问题，我们一般是通过增加 <code>loading</code> 和 <code>占位</code> 来优化。在页面主接口返回数据之前，增加 <code>loading</code> 效果。需要数据才能渲染的组件模块可以先显示 <code>占位框</code>（<code>css</code>），取得数据以后再重新渲染。很明显，这个解决方案比较通用，最好做成可复用的。这个时候，我们就可以通过<code>HOC</code>的条件渲染来实现：</p>
<p>页面<code>loading</code>效果的高阶组件，通过 <strong>反向继承 + 条件渲染</strong> 实现：</p>
<pre><code class="language-jsx">
const withLoadingComponent = (WrappedComponent) =&gt; {
  return (props) =&gt;  {
    render() {
        if(this.state.isLoading) {
          return &lt;Loading /&gt;;
        } else {
          return super.render();
        }
    }
  };
}
</code></pre>
<p>组件占位效果的<code>HOC</code>。额外的 <code>options</code> 参数可以决定占位组件 <code>Placeholder</code> 的高度等信息。</p>
<pre><code class="language-jsx">const withPlaceholderComponent = (WrappedComponent, options) =&gt; {
  return (props) =&gt;  {
    return props ? &lt;WrappedComponent {...props}&gt; : &lt;Placeholder {...options}&gt;
  };
}</code></pre>
<h2 id="组件包装"><a href="#组件包装" class="headerlink" title="组件包装"></a>组件包装</h2><p>如果你总是和相同的元素包裹使用一个通用组件，那么你可以通过抽象一个<code>HOC</code>来复用。比如下面的<code>HOC</code>在组件外面包裹一层背景色为 <code>#fafafa</code> 的 <code>div</code> 元素：</p>
<pre><code class="language-jsx">const withOtherComponent = (WrappedComponent) =&gt; {
  return (props) =&gt;  {
    return (
      &lt;div style={{ backgroundColor: '#fafafa' }}&gt;
          &lt;WrappedComponent {...this.props} {...newProps} /&gt;
      &lt;/div&gt;
    )
  };
}</code></pre>
<p>这里只是举了一个简单的例子，实际项目中，也可以通过其他组件来包裹，或是组合使用。</p>
<h1 id="Recompose-库"><a href="#Recompose-库" class="headerlink" title="Recompose 库"></a>Recompose 库</h1><hr>
<p><code>Recompose</code> 是一个为函数式组件和高阶组件开发的 <code>React</code> 工具库。可以看作是 <code>React</code> 的 <code>Lodash</code>。</p>
<p>复杂场景下，会存在多个 <code>HOC</code> 层层嵌套的情况：</p>
<pre><code class="language-jsx">const TodoListWithConditionalRendering = withLoadingIndicator(
  withTodosNull(
    withTodosEmpty(TodoList)
  )
);</code></pre>
<p>可以使用 <code>recompose</code> 库的 <code>compost</code> 方法优化：</p>
<pre><code class="language-jsx">import { compose } from &#39;recompose&#39;;
const withTodosNull = (Component) =&gt; (props) =&gt;
  ...
const withTodosEmpty = (Component) =&gt; (props) =&gt;
  ...
const withLoadingIndicator = (Component) =&gt; ({ isLoadingTodos, ...others }) =&gt;
  ...
function TodoList({ todos }) {
  ...
}
const withConditionalRenderings = compose(
  withLoadingIndicator,
  withTodosNull,
  withTodosEmpty
);
const TodoListWithConditionalRendering = withConditionalRenderings(TodoList);
function App(props) {
  return (
    &lt;TodoListWithConditionalRendering
      todos={props.todos}
      isLoadingTodos={props.isLoadingTodos}
    /&gt;
  );
}</code></pre>
<p><code>compose</code> 方法用于组合多个高阶组件。注意， props 流向是自上而下的。</p>
<p>另外，<code>recompose</code> 库的 <code>pure</code> 高阶组件，用于控制只在需要的时候重新呈现组件，即除非 <code>props</code> 发生了更改才重新重现组件。 <code>withStateHandler</code>高阶组件，用于将组件状态和组件本身隔离开来……<a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener">了解更多</a></p>
<h1 id="Hoc问题"><a href="#Hoc问题" class="headerlink" title="Hoc问题"></a>Hoc问题</h1><hr>
<h2 id="抽象地狱"><a href="#抽象地狱" class="headerlink" title="抽象地狱"></a>抽象地狱</h2><p>也叫包装地狱。过多使用<code>HOC</code>层层嵌套，会导致层级冗余，逻辑难追踪，很难维护。所以要避免Hoc滥用，充分考虑引入<code>HOC</code>的必要性，尤其<code>HOC</code>多层封装的情况。对于复杂的嵌套结构，最好增加充分的注释。</p>
<h2 id="不要在render中使用-HOC。"><a href="#不要在render中使用-HOC。" class="headerlink" title="不要在render中使用 HOC。"></a>不要在<code>render</code>中使用 <code>HOC</code>。</h2><p>每次<code>render</code>渲染都会创建新的 <code>HOC</code>。diff算法会对新旧子树进行 <code>====</code> 比较。如果不相等，子树会进行卸载，和重新挂载的操作。而每次重新渲染创建的 <code>HOC</code> 前后是 <code>!==</code> 的。</p>
<pre><code class="language-jsx">render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return &lt;EnhancedComponent /&gt;;
}</code></pre>
<h2 id="Refs-不会被传递。"><a href="#Refs-不会被传递。" class="headerlink" title="Refs 不会被传递。"></a><code>Refs</code> 不会被传递。</h2><p>虽然<code>HOC</code>的约定是将所有 <code>props</code> 传递给被包装组件，但这对于 <code>refs</code> 并不适用。那是因为 <code>ref</code> 实际上并不是一个 <code>prop</code>- 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>
<p>这个问题的解决方案是通过使用 <code>React.forwardRef</code>（<code>React 16.3</code> 中引入）。想要了解更多，可以阅览我的另一篇博文<a href="/2020/03/30/拥抱React-Hooks（二）-Refs/index.html">拥抱React-Hooks（二）-Refs</a></p>
<h2 id="静态方法丢失。"><a href="#静态方法丢失。" class="headerlink" title="静态方法丢失。"></a>静态方法丢失。</h2><p>因为原始组件被包裹在一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>
<pre><code class="language-jsx">function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // 必须准确知道应该拷贝哪些方法 :(
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}</code></pre>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">官网-HOC</a><br><a href="https://www.robinwieruch.de/react-higher-order-components" target="_blank" rel="noopener">React Higher-order Component</a><br><a href="https://juejin.im/post/5c72b97de51d4545c66f75d5" target="_blank" rel="noopener">React 中的高阶组件及其应用场景</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sgj.jpeg"
                alt="祁连" />
            
              <p class="site-author-name" itemprop="name">祁连</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                大牛👇
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://overreacted.io/zh-hans/" title="Dan Abramov" target="_blank">Dan Abramov</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qianduan.group/" title="寸志" target="_blank">寸志</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.robinwieruch.de/blog" title="Robin Wieruch" target="_blank">Robin Wieruch</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">祁连</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<script src="/js/prism/prism.js" async></script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
