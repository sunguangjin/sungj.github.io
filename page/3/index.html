<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Live and learn">
<meta property="og:url" content="http://www.mala520.life/page/3/index.html">
<meta property="og:site_name" content="Live and learn">
<meta property="article:author" content="祁连">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mala520.life/page/3/"/>





<link rel="stylesheet" href="/js/prism/prism.css">

  <title>Live and learn</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Live and learn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/06/13/%E5%85%B3%E4%BA%8Esuper-props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/%E5%85%B3%E4%BA%8Esuper-props/" itemprop="url">关于React中的super(props)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-13T17:15:38+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>读书笔记<br><a href="https://overreacted.io/why-do-we-write-super-props/" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<hr>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>在 JavaScript 中，<code>super</code> 指的是父类（即超类）的构造函数。在下面的例子中，它指向了 <code>React.Component</code> 的实现。<code>super</code>只能用在子类的构造函数之中。</p>
<pre><code class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}</code></pre>
<p>值得注意的是，在调用父类的构造函数之前，你是不能在 <code>constructor</code> 中使用 <code>this</code> 关键字的。JavaScript 不允许这个行为。这是一种<strong>成功陷阱机制</strong>。</p>
<pre><code class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    // 🔴  还不能使用 `this`
    super(props);
    // ✅  现在可以了
    this.state = { isOn: true };
  }
  // ...
}</code></pre>
<hr>
<h1 id="为什么要传入props👇"><a href="#为什么要传入props👇" class="headerlink" title="为什么要传入props👇"></a>为什么要传入props👇</h1><p>为了让 <code>React.Component</code> 构造函数能够初始化 <code>this.props</code>，将 <code>props</code> 传入 <code>super</code> 是必须的。</p>
<p>看 <code>React</code> 源码 :</p>
<pre><code class="language-jsx">/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};</code></pre>
<hr>
<h1 id="为什么不传props，依然能访问到-this-props👇"><a href="#为什么不传props，依然能访问到-this-props👇" class="headerlink" title="为什么不传props，依然能访问到 this.props👇"></a>为什么不传<code>props</code>，依然能访问到 <code>this.props</code>👇</h1><p>这当然不是<code>javascript</code>内置的默认逻辑，而是 <code>React</code> 内部做的手脚，在调用构造函数后也立即将 <code>props</code> 赋值到了实例上：</p>
<pre><code class="language-jsx">const instance = new YourComponent(props);
instance.props = props;</code></pre>
<hr>
<h1 id="super-能代替-super-props-？-👇"><a href="#super-能代替-super-props-？-👇" class="headerlink" title="super() 能代替 super(props) ？ 👇"></a>super() 能代替 super(props) ？ 👇</h1><p><strong>最好不要</strong>，虽然 <code>React</code> 会在构造函数执行完毕之后给 <code>this.props</code> 赋值。但在构造函数中 <code>this.props</code> 一直是 <code>undefined</code>。</p>
<pre><code class="language-jsx">// React 內部
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}

// 你的程式碼內部
class Button extends React.Component {
  constructor(props) {
    super(); // 😬 我们忘了传入 props
    console.log(props);      // ✅ {}
    console.log(this.props); // 😬 未定义
  }
  // ...
}</code></pre>
<p>如果在构造函数中调用了其他的内部方法，方法链中用到了<code>this.props</code>，就麻烦了。这是 React 作者建议开发者一定执行 <code>super(props)</code> 的原因。 所以，我们还是乖乖的秉承规范：</p>
<pre><code class="language-jsx">class Button extends React.Component {
  constructor(props) {
    super(props); // ✅ 传入 props
    console.log(props);      // ✅ {}
    console.log(this.props); // ✅ {}
  }
  // ...
}</code></pre>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/05/28/H5%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/H5%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86/" itemprop="url">H5拍照上传处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T15:42:37+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>很多公司业务中，会存在上传资料图片，以供审核的需求。那我们用<code>H5</code>如何实现，并达到好的效果呢</p>
<p>涉及技术点：</p>
<ul>
<li><code>html media capture</code></li>
<li><code>FileReader</code> || <code>ULR.createObjectURL()</code></li>
<li><code>canvas</code></li>
<li><code>EXIF</code> &amp; <code>orientation</code></li>
</ul>
<h1 id="调用相机"><a href="#调用相机" class="headerlink" title="调用相机"></a>调用相机</h1><p><a href="https://www.w3.org/TR/html-media-capture/" target="_blank" rel="noopener">html media capture</a></p>
<pre><code class="language-html">&lt;input type=&#39;file&#39; accept=&#39;image/*&#39; capture=&quot;camera&quot;/&gt;</code></pre>
<h1 id="获取图片信息"><a href="#获取图片信息" class="headerlink" title="获取图片信息"></a>获取图片信息</h1><hr>
<p>以下两种方式皆可：</p>
<ul>
<li><strong>new FileReader().readAsDataURL(file)</strong> 异步/data:base64</li>
<li><strong>ULR.createObjectURL(file)</strong> 同步/内存url</li>
</ul>
<h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><hr>
<ul>
<li>限制最大宽度，对宽高做处理</li>
<li>等比例压缩</li>
</ul>
<pre><code class="language-javascript">  const canvas = document.createElement(&#39;canvas&#39;);
  const ctx = canvas.getContext(&#39;2d&#39;);
  canvas.width = Math.min(image.naturalWidth, option.maxWidth)
  // 高度通过宽度压缩比处理，保证等比例压缩
  const ratio = canvas.width / image.naturalWidth
  canvas.height = image.naturalHeight * ratio
  ...
  // 二次压缩（比如90%）
  canvas.toDataURL(fileType, 0.9); // fileType: image/jpeg</code></pre>
<h1 id="旋转处理"><a href="#旋转处理" class="headerlink" title="旋转处理"></a>旋转处理</h1><hr>
<p>手机相机（基本上都是Iphone）拍照，你会发现有时候照片会自动旋转，有时候并不是我们期望的显示效果。<br>不过手机拍照获取的图片，有<strong>EXIF</strong>（Exchangeable image file format），会默认设置一个<strong>orientation</strong> tag（jpeg格式才有）。<strong>orientation</strong>标示了图片旋转信息。</p>
<img src="/2019/05/28/H5%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86/exif.png" class="" title="orientation图示">
<p>首先，我们可以用<a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">Exifjs</a>获取orientation。<strong>Exif.js</strong>提供了js读取图像的原始数据的功能扩展（拍照方向、相机设备型号、拍摄时间、ISO感光度、GPS地理位置等数据）.</p>
<pre><code class="language-javascript">import EXIF from &#39;exif-js&#39;;
...

EXIF.getData(file, function () {
  const orientation = EXIF.getTag(this, &#39;Orientation&#39;);
  console.log(`orientation: ${orientation}`);
});</code></pre>
<p>然后，我们用canvas对图片做一些旋转处理即可( 亲测只存在1，3，6，8四种情况):</p>
<pre><code class="language-javascript">  // 判断图片方向，重置 canvas 大小，确定旋转角度，iphone 默认的是 home 键在右方的横屏拍摄方式
  switch (orientation) {
      // 1 不需要旋转
      case 1: {
          ctx.drawImage(img, 0, 0, width, height);
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          break;
      }
      // iphone 横屏拍摄，此时 home 键在左侧 旋转180度
      case 3: {
          ctx.clearRect(0, 0, width, height);
          ctx.translate(0, 0);
          ctx.rotate(Math.PI);
          ctx.drawImage(img, -width, -height, width, height);
          break;
      }
      // iphone 竖屏拍摄，此时 home 键在下方(正常拿手机的方向) 旋转90度
      case 6: {
          ctx.clearRect(0, 0, width, height);
          ctx.translate(0, 0);
          ctx.rotate(90 * Math.PI / 180);
          ctx.drawImage(img, 0, -height, width, height);
          break;
      }
      // iphone 竖屏拍摄，此时 home 键在上方 旋转270度
      case 8: {
          ctx.clearRect(0, 0, width, height);
          ctx.translate(0, 0);
          ctx.rotate(-90 * Math.PI / 180);
          ctx.drawImage(img, -width, 0, width, height);
          break;
      }
      default: {
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          break;
      }
  }
</code></pre>
<p>最后，我们上传处理完的图片。</p>
<hr>
<p><a href="https://juejin.im/post/5bd705abf265da0a8d36dbdc#heading-5" target="_blank" rel="noopener">参考资料</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/04/23/React-Render-Props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/React-Render-Props/" itemprop="url">React - Render Props</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T14:29:49+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可组合组件"><a href="#可组合组件" class="headerlink" title="可组合组件"></a>可组合组件</h1><p>我们先回顾一下<strong>可组合组件</strong>。在 <code>props</code> 对象中有一个常用的 <code>children</code> 属性。通过它你可以将元素从上层传递到你的组件中，这些元素对你的组件来说是未知的，但是却为组件相互组合提供了可能性。<code>children</code> 非常灵活，可以是字符串，组件，甚至他们的集合，就像写<code>html</code>一样：</p>
<pre><code class="language-jsx">const A= ({ children }) =&gt; (
  &lt;div&gt;
    &lt;p&gt; A logic&lt;/p&gt;
    { children }
  &lt;/div&gt;
)
const App = () =&gt; (
  &lt;&gt;
    &lt;p&gt; children 示例：&lt;/p&gt;
    &lt;A&gt;
      组件B：&lt;B /&gt;
      组件C：&lt;C /&gt;
    &lt;/A&gt;
  &lt;/&gt;
);</code></pre>
<p>上面的组件<code>A</code>就是一个可组合组件。</p>
<h1 id="可共享的可组合组件"><a href="#可共享的可组合组件" class="headerlink" title="可共享的可组合组件"></a>可共享的可组合组件</h1><p>上面示例中 <code>children</code> 是最基本的使用方式，只是在组合层面，还没到达共享层面。如果 <code>B</code> <code>C</code> 组件要使用 <code>A</code> 组件的属性，即 <code>A</code> 组件要共享自己的属性给<code>B C</code> 使用。通过 通过<code>callBack</code> 实现 <code>A &gt; APP &gt; B&amp;C</code> 这种传递显然太low。这里就有一个技巧：把 <code>children</code> 函数化 这样便可以通过传递实现数据共享。<br>我们来看一个实例：一个检测浏览器在线/离线状态的共享组件，很多组件都需要通过这个组件获取浏览器是否在线：</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;

// 共享组件
class BrowserIfOnline extends React.Component {
  state = {
    isOnline: window.navigator.onLine
  };
  onOffline = () =&gt; {
    this.setState({ isOnline: false });
  };
  onOnline = () =&gt; {
    this.setState({ isOnline: true });
  };
  componentDidMount() {
    // 事件监听
    window.addEventListener(&quot;offline&quot;, this.onOffline);
    window.addEventListener(&quot;online&quot;, this.onOnline);
  }
  componentWillUnmount() {
    window.removeEventListener(&quot;offline&quot;, this.onOffline);
    window.removeEventListener(&quot;online&quot;, this.onOnline);
  }

  render() {
    return (
      &lt;&gt;
        {this.state.isOnline ? (
          &lt;div&gt;网断已连接 ...&lt;/div&gt;
        ) : (
          &lt;div&gt;网络已断开 ...&lt;/div&gt;
        )}
        {this.props.children(this.state.isOnline)}
      &lt;/&gt;
    );
  }
}
// 子组件
const B = ({ isOnline }) =&gt; &lt;p&gt;组件B：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;
const C = ({ isOnline }) =&gt; &lt;p&gt;组件C：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;

// 通过 函数化的 children 使用共享组件
class A extends React.Component {
  render() {
    return (
      &lt;BrowserIfOnline&gt;
        {isOnline =&gt; (
          &lt;&gt;
            &lt;B isOnline={isOnline} /&gt;
            &lt;C isOnline={isOnline} /&gt;
          &lt;/&gt;
        )}
      &lt;/BrowserIfOnline&gt;
    );
  }
}
export default A</code></pre>
<h1 id="Render-props-技巧"><a href="#Render-props-技巧" class="headerlink" title="Render props 技巧"></a>Render props 技巧</h1><p><code>render props</code> 是 <code>React</code> 的 一个高级特性。指一种在 <code>React</code> 组件之间使用一个值为函数的 <code>prop</code> <strong>共享代码/逻辑</strong>的简单技术。是一个用于告知组件需要渲染什么内容的函数。</p>
<p>上述<strong>可共享的可组合组件</strong>的实现，使用的便是 <code>children</code> + <code>render props</code> 技巧。在官方文档中介绍的 <code>render props</code> 使用的是另一种方式：把一个函数作为<code>render</code> 属性传递，而非 <code>children</code>：</p>
<pre><code class="language-jsx">// 共享组件 
// 通过props.render 渲染其他组件，并共享数据
class BrowserIfOnline extends React.Component {

  // ......
  // 这里省略其他逻辑 同上
  // ......

  render() {
    return (
      &lt;&gt;
        {this.state.isOnline ? (
          &lt;div&gt;网断已连接 ...&lt;/div&gt;
        ) : (
          &lt;div&gt;网络已断开 ...&lt;/div&gt;
        )}
        {this.props.render(this.state.isOnline)}
      &lt;/&gt;
    );
  }
}
//通过`render props` 的 属性（render）方式使用共享组件
class A extends React.Component {
  render() {
    return (
      &lt;BrowserIfOnline
        render={isOnline =&gt; (
          &lt;&gt;
            &lt;B isOnline={isOnline} /&gt;
            &lt;C isOnline={isOnline} /&gt;
          &lt;/&gt;
        )}
      /&gt;
    );
  }
}</code></pre>
<p><code>render</code> 属性是国际惯例，你也可以自定义，但最好不要。复杂场景下，你可能需要多个 <code>render</code> 函数。这个时候必须要重命名了，但依然建议加<code>render</code>前缀，比如<code>renderOne renderTwo</code>。</p>
<h1 id="render-props-优势"><a href="#render-props-优势" class="headerlink" title="render props 优势"></a><code>render props</code> 优势</h1><p>很多时候，<code>React Hoc</code> 可替代 <code>render props</code> 来实现逻辑共享。比如上面的功能用<code>React Hoc</code> 实现如下：</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
// 把BrowserIfOnline组件封装成一个高阶组件 withBrowserIfOnline
const withBrowserIfOnline = comps =&gt;
  class BrowserIfOnline extends React.Component {
    state = {
      isOnline: window.navigator.onLine
    };
    onOffline = () =&gt; {
      this.setState({ isOnline: false });
    };
    onOnline = () =&gt; {
      this.setState({ isOnline: true });
    };
    componentDidMount() {
      // 事件监听
      window.addEventListener(&quot;offline&quot;, this.onOffline);
      window.addEventListener(&quot;online&quot;, this.onOnline);
    }
    componentWillUnmount() {
      window.removeEventListener(&quot;offline&quot;, this.onOffline);
      window.removeEventListener(&quot;online&quot;, this.onOnline);
    }

    render() {
      return (
        &lt;&gt;
          {this.state.isOnline ? (
            &lt;div&gt;网断已连接 ...&lt;/div&gt;
          ) : (
            &lt;div&gt;网络已断开 ...&lt;/div&gt;
          )}
          {comps.map((Comp) =&gt; &lt;Comp isOnline={this.state.isOnline}/&gt;)}
        &lt;/&gt;
      );
    }
  }
const B = ({ isOnline }) =&gt; &lt;p&gt;组件B：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;
const C = ({ isOnline }) =&gt; &lt;p&gt;组件C：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;

const D = withBrowserIfOnline([B, C]);
export default class A extends React.Component {
  render() {
    return (
      &lt;D/&gt;
    );
  }
}
</code></pre>
<p>我们使用 <code>render props</code> 的优点主要体现在它的灵活性。比如上述示例，我们是可以在组件 <code>B</code>  <code>C</code> 前后增加一些零碎的代码逻辑，而<code>React Hoc</code>就没那么便利。</p>
<pre><code class="language-jsx">class A extends React.Component {
  render() {
    return (
      &lt;BrowserIfOnline
        render={isOnline =&gt; (
          &lt;&gt;
            &lt;p&gt;组件B：&lt;/p&gt;
            &lt;B isOnline={isOnline} /&gt;
            &lt;p&gt;组件C：&lt;/p&gt;
            &lt;C isOnline={isOnline} /&gt;
            &lt;p&gt;其他信息&lt;/p&gt;
          &lt;/&gt;
        )}
      /&gt;
    );
  }
}
</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh-hans.reactjs.org/docs/render-props.html" target="_blank" rel="noopener">官网 - Render Props</a><br><a href="https://www.robinwieruch.de/react-render-props" target="_blank" rel="noopener">React Render Props</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/04/09/React-%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/React-%E6%B5%8B%E8%AF%95/" itemprop="url">React 单元测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T11:27:57+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Jest-快照测试"><a href="#Jest-快照测试" class="headerlink" title="Jest 快照测试"></a>Jest 快照测试</h1><ul>
<li>Jest 是一个在 Facebook 使用的测试框架。在 React 社区，它被用来做 React 的组件测试。</li>
<li>Jest 赋予你写快照测试的能力。</li>
</ul>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
// 写快照之前，需要额外安装一个工具库：
import renderer from &#39;react-test-renderer&#39;;
import App, { Table } from &#39;./App&#39;;

...
// “describe”块中来定义一个测试套件。可包含一系列关于特定组件的“it”块。
describe(&#39;Search&#39;, () =&gt; {
  // mock 一些测试数据 ，非常重要
  const props={ 
    list:[
      { title: &#39;1&#39;, author: &#39;1&#39;, num_comments: 1, points: 2, objectID: &#39;y&#39; },
      { title: &#39;2&#39;, author: &#39;2&#39;, num_comments: 1, points: 2, objectID: &#39;z&#39; },
    ] 
  }
  // “it”块描述了一个测试用例。
  it(&#39;renders without crashing&#39;, () =&gt; {
    const div = document.createElement(&#39;div&#39;);
    ReactDOM.render(&lt;Table { ...props } /&gt;, div);
  });
  // “test”块来实现一个快照测试
  test(&#39;has a valid snapshot&#39;, () =&gt; {
    const component = renderer.create(
      &lt;Table { ...props } /&gt;
    );
    let tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });
});
</code></pre>
<h1 id="Enzyme-单元测试"><a href="#Enzyme-单元测试" class="headerlink" title="Enzyme 单元测试"></a>Enzyme 单元测试</h1><p>Enzyme 可以用来断言、操作、遍历 React 组件。你可以用它来管理单元测试，在 React 测试中与快照测试互补。</p>
<p>安装（还需要安装一个扩展库）：</p>
<pre><code class="language-bash">npm install --save-dev enzyme react-addons-test-utils enzyme-adapter-react-16</code></pre>
<p>适配器初始化：</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import renderer from &#39;react-test-renderer&#39;;
import Enzyme from &#39;enzyme&#39;;
import Adapter from &#39;enzyme-adapter-react-16&#39;;
import App, { Search, Button, Table } from &#39;./App&#39;;
Enzyme.configure({ adapter: new Adapter() });</code></pre>
<p>写一个单元测试：使用 shallow() 方 法渲染你的Table组件，并且断言 Table 有两个子项，因为你传入了两个列表项。断言仅仅检查这个元素两个带有类名叫 table-row 的元素:</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import renderer from &#39;react-test-renderer&#39;;
import Enzyme, { shallow } from &#39;enzyme&#39;;
import Adapter from &#39;enzyme-adapter-react-16&#39;;
import App, { Search, Button, Table } from &#39;./App&#39;;
...
describe(&#39;Table&#39;, () =&gt; {
  const props = {
    list: [
      { title: &#39;1&#39;, author: &#39;1&#39;, num_comments: 1, points: 2, objectID: &#39;y&#39; },
      { title: &#39;2&#39;, author: &#39;2&#39;, num_comments: 1, points: 2, objectID: &#39;z&#39; },
    ],
  };
...
  it(&#39;shows two items in list&#39;, () =&gt; {
      const element = shallow(&lt;Table { ...props } /&gt;
    );
    expect(element.find(&#39;.table-row&#39;).length).toBe(2);
  });
});
</code></pre>
<p>Enzyme API 中总共有三种渲染机制。 浅渲染 shallow() 外，这里还有 mount() 和render() 方法。这两种方式都会初始化父组件和所有的子组件。此外 mount() 还给予你调用组件生命周期的方法。但是什时候该使用哪种渲染机制呢？这里有一些建议：</p>
<ul>
<li>不论怎样都优先尝试使用浅渲染（shallow()），不会渲染子组件。</li>
<li>如果需要测试 componentDidMount() 或 componentDidUpdate()，使用 mount()。</li>
<li>如果你想测试组件的生命周期和子组件的行为，使用 mount()。</li>
<li>如果你想测试一个组件的子组件的渲染，并且不关心生命周期方法和减少些渲染的花销的话，使用 render()。</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2016/02/react-testing-tutorial.html" target="_blank" rel="noopener">React 测试入门教程-阮一峰</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/03/12/%E5%89%8D%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/12/%E5%89%8D%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/" itemprop="url">前端同构渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T13:43:14+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见渲染方式"><a href="#常见渲染方式" class="headerlink" title="常见渲染方式"></a>常见渲染方式</h1><ul>
<li>CSR (Client Side Rendering)：SPA单页应用常用，客户端 异步获取数据渲染页面的方式。</li>
<li>SSR (Server Side Rendering)：在服务端获取数据生成html返回客户端的方式，html也可包含js文件，加载后获取数据二次渲染。</li>
<li>SSG (Static Site Generation)：静态网站生成类似于服务器端渲染，不同之处在于您在构建时而不是在请求时渲染页面。</li>
<li>CSR with Pre-rendering：预渲染原理是：一般在构建阶段的最后，在本地启动一个 Puppeteer 服务，访问配置了预渲染的路由，然后将 Puppeteer 中渲染的页面输出到 HTML 文件中打包，并建立路由对应的目录。</li>
</ul>
<p>以此， 达到预渲染的目的。</p>
<h1 id="什么是同构渲染"><a href="#什么是同构渲染" class="headerlink" title="什么是同构渲染"></a>什么是<strong>同构渲染</strong></h1><p>同构渲染是为了解决当下客户端渲染为主的组件式卡法模式下性能，白屏问题而提出的一种解决方案。强调服务端跟客户端公用一套代码。服务端负责渲染，客户端来负责交互。当然服务端渲染挂了，客户端也是可以渲染的。</p>
<h1 id="客户端渲染-还是-同构渲染"><a href="#客户端渲染-还是-同构渲染" class="headerlink" title="客户端渲染 还是 同构渲染"></a>客户端渲染 还是 同构渲染</h1><p>可阅读文章： <a href="https://github.com/camsong/blog/issues/8" target="_blank" rel="noopener">精读前后端渲染之争</a></p>
<p> 作者通过精读<a href="https://www.freecodecamp.org/news/heres-why-client-side-rendering-won-46a349fadb52/" target="_blank" rel="noopener">Here’s Why Client-side Rendering Won</a>这篇文章，并收集近10位同仁的意见，对于同构渲染进行了总结并发表了自己的看法。</p>
<p> 主要阐述了同构渲染在优化体验的同时也会带来一系列问题，并没有想象中的美好。作者认为还是应该选择客户端渲染的方案为主流，可以通过其他方式优化，或部分同构的方式来解决客户端渲染的性能问题。</p>
<h1 id="同构渲染架构如何实现？"><a href="#同构渲染架构如何实现？" class="headerlink" title="同构渲染架构如何实现？"></a>同构渲染架构如何实现？</h1><p>可阅读文章：<a href="https://juejin.im/post/5d7deef6e51d453bb13b66cd#heading-4" target="_blank" rel="noopener">一文吃透React SSR服务端渲染和同构原理</a>。</p>
<p>作者为我们详细解答了：</p>
<ul>
<li>为什么需要同构渲染？</li>
<li>实现同构渲染的核心原理是什么？</li>
<li>实现同构渲染有哪些技术难题？如何设计对应的解决方案和具体实现（ 在 React 提供的 SSR 能力的几个API的基础上）。</li>
</ul>
<p>可行性和是否成熟先不谈，作者解决各种问题的思路值得学习。</p>
<h1 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h1><p>同构渲染固然是一种非常好的解决问题的思路，但是需要解决的技术难题非常多。推崇同构渲染的同仁可能会说，有问题解决问题便可，比如上述文章基本上给出了各种技术问题的解决方案。我个人也相对保守，崇尚kiss原则，我觉得在形成一套成熟的同构渲染技术方案（非常困难）的情况下，不宜推广全栈同构，可以部分同构。</p>
<p>我认为的成熟的同构方案至少满足以下两点：</p>
<ul>
<li>解决同构渲染的各种技术难题，稳定且不存在很大的性能，兼容性等问题。</li>
<li>不能使得普通开发者的开发成本和维护成本大大增加。性能虽然重要，开发质量，可维护性也是相当重要的。</li>
</ul>
<blockquote>
<p>软件开发中遇到的所有问题，都可以通过增加一层抽象而得以解决。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/03/05/React%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/React%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/" itemprop="url">React技术体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T17:29:27+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul>
<li>Virtual DOM（Diff算法）</li>
<li>Jsx 语法</li>
<li>Flux Data Flow（单向数据流）</li>
<li>类组件&amp;生命周期</li>
<li>函数组件-无状态组件<a href="https://www.jackfranklin.co.uk/blog/functional-stateless-components-react/" target="_blank" rel="noopener">FSC</a></li>
<li>高阶特性 <code>Hoc</code> <code>Render Props</code> <code>Context</code> 等</li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>在挂载过程中有四个生命周期方法，它们的调用顺序是这样的：</p>
<ul>
<li><code>constructor()</code>   组件初始化时被调用，用于初始化状态</li>
<li><code>componentWillMount()</code> 在 <code>render()</code> 之前被调用。可用于设置一些组件本地状态，不过还是推荐在 <code>constructor()</code> 中去初始化状态。</li>
<li><code>render()</code> 它返回作为组件输出的元素。这个方法应该是一个纯函数，因此不应该在这个方法中修改组件的状态。</li>
<li><code>componentDidMount()</code> 它仅在组件挂载后执行一次。一般用于处理<code>Ajax</code>请求等副作用。</li>
</ul>
<p>共有5个生命周期方法用于组件更新周期，调用顺序如下：</p>
<ul>
<li><code>componentWillReceiveProps(nextProps)</code> 新的属性会作为它的输入。因此你可以利用 <code>this.props</code> 来对比之后的属性和之前的属性，基于对比的结果去实现不同的行为。此外，你可以基于新的属性来设置组件的状态。</li>
<li><code>shouldComponentUpdate((nextProps, nextState)</code> 每次组件因为状态或者属性更改而更新时，它都会被调用。组件及其子组件将根据该方法返回的布尔值来决定是否重新渲染，从而避免不必要的渲染。用于性能优化。</li>
<li><code>componentWillUpdate((nextProps, nextState)</code>  - 这个方法是 <code>render()</code> 执行之前的最后一个方法。你已经拥有下一个属性和状态，它们可以在这个方法中任由你处置。你可以利用这个方法在渲染之前进行最后的准备。注意在这个生命周期方法中你不能再触发 <code>setState()</code>。如果你想基于新的属性计算状态，你必须利用<code>componentWillReceiveProps()</code>。</li>
<li><code>render()</code> 同上。</li>
<li><code>componentDidUpdate()</code>  这个方法在 <code>render()</code> 之后立即调用。你可以用它当成操作 <code>DOM</code> 或者执行更多异步请求的机会。</li>
</ul>
<p>组件卸载也有生命周期。只有一个：</p>
<ul>
<li><code>componentWillUnmount()</code>。它会在组件销毁之前被调用。你可以利用这个生命周期方法去执行任何清理任务。</li>
</ul>
<blockquote>
<p><code>componentDidCatch()</code> 。它在 <code>React 16</code> 中引入，用来捕获组件的错误。</p>
</blockquote>
<h1 id="setState-异步"><a href="#setState-异步" class="headerlink" title="setState() 异步?"></a>setState() <code>异步?</code></h1><ul>
<li><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</li>
<li><code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的<code>callback</code>拿到更新后的结果。</li>
<li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和<code>setTimeout</code> 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</li>
</ul>
<h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><p><code>Hook</code> 是 <code>React 16.8</code> 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。</p>
<ul>
<li>基础 Hook : <code>useState</code>  <code>useEffect</code> <code>useContext</code></li>
<li>其他 Hook : <code>useReducer</code> <code>useCallback</code> <code>useMemo</code> <code>useRef</code> <code>useImperativeHandle</code> <code>useLayoutEffect</code> <code>useDebugValue</code></li>
</ul>
<h1 id="React-SSR"><a href="#React-SSR" class="headerlink" title="React SSR"></a>React SSR</h1><ul>
<li>CSR 客户端渲染</li>
<li>SSR 服务端渲染</li>
<li>SPA 单页应用</li>
</ul>
<p><code>SSR</code>其实属于古老的技术了，早期的前端页面都是<code>SSR</code>渲染的，<code>node + ejs（模版引擎)，java + （velocity模版引擎），php，jsp</code>等都可以实现。但是只实现<code>SSR</code>其实没啥意义，技术上没有任何发展和进步，否则 <code>SPA</code> 技术就不会出现。<br>但是单纯的 <code>SPA</code>又不够完美，所以最好的方案就是这两种体验和技术的结合，第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 <code>SPA</code> 的效果和体验，还不影响<code>SEO</code> 效果，这就有点完美了。关于<code>React SSR</code>，主要有下面几个框架：</p>
<h2 id="Nextjs"><a href="#Nextjs" class="headerlink" title="Nextjs"></a>Nextjs</h2><p><code>React</code>轻量级后端渲染框架，<strong>同构渲染</strong>利器。</p>
<h2 id="Umijs"><a href="#Umijs" class="headerlink" title="Umijs"></a>Umijs</h2><p><code>Umi</code>，中文可发音为<strong>乌米</strong>，是可扩展的企业级前端应用框架，参考 <code>next.js</code> 做的。要说有哪些地方不如<code>Umi</code>，我觉得可能是不够贴近业务，不够接地气。比如 <code>antd、dva</code> 的深度整合，比如国际化、权限、数据流、配置式路由、补丁方案、自动化 external 方面等等一线开发者才会遇到的问题。</p>
<h2 id="Bigfish-阿里内部，非开源"><a href="#Bigfish-阿里内部，非开源" class="headerlink" title="Bigfish(阿里内部，非开源)"></a>Bigfish(阿里内部，非开源)</h2><ul>
<li><code>Umi</code> 和 <code>Bigfish</code>，前者是从无线业务中长出来的，后者是从中台业务中长出来的。</li>
<li>后来统一技术栈，<code>Bigfish</code> 后来改造成 <code>umi + umi 插件集</code>的一个架构。这样一个对外开源，一个对内服务。类似的还有 <code>eggjs</code> 和 <code>chair</code>。<br>既然是阿里内部框架，这里为啥提及：<strong><code>这是一种很好的方式，开源和业务两不误</code></strong></li>
</ul>
<h2 id="Eggjs"><a href="#Eggjs" class="headerlink" title="Eggjs"></a>Eggjs</h2><p>企业级<code>Node.js</code>框架, 基于 <code>Koa</code> 开发，性能优异,高度可扩展的插件机制,内置多进程管理。<br><strong>有成熟的配合React实现SSR技术解决方案</strong></p>
<hr>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p><code>Redux</code> 是 JavaScript 状态容器，提供可预测化的状态管理。</p>


<p><a href="https://github.com/camsong/redux-in-chinese" target="_blank" rel="noopener">Redux中文文档</a></p>
<h2 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h2><p>异步解决方案，相似仓库还有：</p>
<ul>
<li><code>redux-thunk</code></li>
<li><code>redux-promise</code></li>
</ul>
<h2 id="dav"><a href="#dav" class="headerlink" title="dav"></a>dav</h2><p>基于 <code>redux</code> 和 <code>redux-saga</code> 的数据流方案，额外内置了 <code>react-router</code> 和 <code>fetch</code>，所以也可以理解为一个轻量级的应用框架。</p>
<hr>
<h2 id="好文"><a href="#好文" class="headerlink" title="好文"></a>好文</h2><p><a href="https://juejin.im/post/5def0816f265da33aa6aa7fe" target="_blank" rel="noopener">React SSR详解</a><br><a href="http://ykfe.net/guide/#%E5%88%9D%E8%A1%B7" target="_blank" rel="noopener">Egg + React + SSR 服务端渲染</a><br><a href="https://github.com/sorrycc/blog/issues/85" target="_blank" rel="noopener">蚂蚁金服前端框架和工程化实践</a><br><a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="noopener">React + Redux 最佳实践</a><br><a href="https://github.com/sorrycc/blog/issues/6" target="_blank" rel="noopener">支付宝前端应用架构的发展和选择</a><br><a href="https://juejin.cn/post/6844903636749778958" target="_blank" rel="noopener">你真的理解setState吗？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/08/21/js-%E5%9F%BA%E7%A1%80%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/js-%E5%9F%BA%E7%A1%80%E7%A2%8E%E7%89%87/" itemprop="url">JS 基础知识碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T17:11:51+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="8-种基本数据类型"><a href="#8-种基本数据类型" class="headerlink" title="8 种基本数据类型"></a>8 种基本数据类型</h1><hr>
<ul>
<li><code>Number</code>: 数值类型。范围是<code>±(253-1)</code>；特殊值有<code>Infinity</code>(正无穷，其实是大过最大值), <code>-Infinity</code>（负无穷，其实是小过最小值）和 <code>NaN</code>（非数值）。</li>
<li><code>String</code>: 字符串类型。</li>
<li><code>Object</code>:  对象类型。</li>
<li><code>Boolean</code>: 布尔类型 true or false</li>
<li><code>null</code>: 特殊的对象，表示空，已定义未赋值。</li>
<li><code>undefined</code>: 未定义</li>
<li><code>BigInt</code>: 表示任意长度的整数。通过在数值末尾加 <code>n</code>来定义，比如 <code>const bigInt = 1234567890123456789012345678901234567890n;</code></li>
<li><code>Symbols</code>: 生成唯一标示符。</li>
</ul>
<p><code>typeof</code> 用于检测变量的数据类型：</p>
<ul>
<li>两种使用方式: <code>typeof x</code> or <code>typeof(x)</code>。</li>
<li>返回类型的字符串, 比如 <code>&quot;string&quot;</code>。</li>
<li><code>typeof null</code> 返回 <code>&quot;object&quot;</code> <code>null</code> 被认为是一个 特殊 的对象( 空对象 )。</li>
</ul>
<blockquote>
<p><code>BigInt</code> 注意兼容性： <code>Firefox/Chrome/Edge/Safari</code>都已支持, <code>IE</code>尚不支持。</p>
</blockquote>
<h1 id="作用域（scope）之声明提前（hoisting）"><a href="#作用域（scope）之声明提前（hoisting）" class="headerlink" title="作用域（scope）之声明提前（hoisting）"></a>作用域（scope）之声明提前（hoisting）</h1><ul>
<li><code>js</code> 只有函数作用域，没有块级作用域。</li>
<li><code>js</code> 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。</li>
<li>这意味这变量在函数体内声明之前就已经可用，这个特性被非正式的称为声明提前（<code>hoisting</code>）。</li>
</ul>
<pre><code class="language-javascript">var scope = &quot;global&quot;
function f() {
  console.log(scope);  // 输出 undefined 而非 global
  var scope = &quot;local&quot;;
  console.log(scope);  // 输出 local
}</code></pre>
<p>上述函数相当于</p>
<pre><code class="language-javascript">
function f() {
  var scope;  // 自动的 声明提前
  console.log(scope);
  scope = &quot;local&quot;;
  console.log(scope);
}</code></pre>
<hr>
<h1 id="toString-和-valueOf"><a href="#toString-和-valueOf" class="headerlink" title="toString() 和 valueOf()"></a>toString() 和 valueOf()</h1><ul>
<li>所有的对象继承了两个转换方法：<code>toString()</code> 和 <code>valueOf()</code>。</li>
<li><code>toString()</code> 不同的对象类型表现不同，比如数组返回逗号拼接的字符串，日期类型返回一个可读的日期事件字符串等。</li>
<li><code>valueOf()</code> 如果对象存在原始值，就返回原始值。对象是复合值，大多数时候无法真正表示为一个原始值，就返回其本身。</li>
</ul>
<pre><code class="language-javascript">[1,2,3].toString();  // &quot;1,2,3&quot;
new Date(2010,0,1).toString();  // &quot;Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间)&quot;
new Date(2010,0,1).valueOf();  // 1262275200000</code></pre>
<hr>
<h1 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h1><pre><code class="language-javascript">var obj = { x: 1, y: 2 }
&quot;x&quot; in obj; // =&gt; true
&quot;z&quot; in obj; // =&gt; false
&quot;toString&quot; in obj; // =&gt; true: 所有对象继承了toString()方法</code></pre>
<hr>
<h1 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h1><ul>
<li><code>A instanceof B</code> : 左操作数<code>A</code>为一个对象，右操作数<code>B</code>标示对象的类型。</li>
<li>如果<code>A</code>是<code>B</code>的实例就返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<pre><code class="language-javascript">var d = new Date();
d instanceof Date;     // =&gt; true
d instanceof Object;   // =&gt; true : 所有对象都是 Object 的实例
d instanceof Number;   // =&gt; false
var a = [1, 2, 3];
a instanceof Array;    // =&gt; true
a instanceof Object;   // =&gt; true
function f() { };
f instanceOf Function;  // =&gt; true</code></pre>
<hr>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><ul>
<li><code>对象直接量</code> ：常用方式。</li>
</ul>
<pre><code class="language-javascript">var empty = {};       // 空对象
var point = {x: 0, y: 0};
var book = {
  &quot;main title&quot;: &quot;Javascropt&quot;, // 属性名有空格必须使用字符串表示
  &quot;sub-title&quot;: &quot;The Definitive Guide&quot;,  // 属性名有连字符必须使用字符串表示
  for: &quot;all audiences&quot;
}
</code></pre>
<ul>
<li><code>new</code>：new运算符创建并初始化一个新对象，new后面跟随一个函数调用，这个函数其实是一个构造函数（constructor）。</li>
</ul>
<pre><code class="language-javascript">var empty = new Object();       // 同 {}
var point = new Object({x: 0, y: 0});
var a = new Array(); // 同 []
var b = new Date();</code></pre>
<ul>
<li><code>Object.create(proto, propertiesObject)</code>：<code>ES6</code>定义的方法，它创建一个对象.其中<code>proto</code>（必须参数）是这个对象的原型。<br><code>propertiesObject</code>是可选参数，作用就是给新对象添加新属性以及描述器。具体可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">Object.defineProperties() - mdn</a> 的第二个参数。新添加的属性是新对象自身具有的属性也就是通过<code>hasOwnProperty()</code> 方法可以获取到的属性，</li>
</ul>
<pre><code class="language-javascript">// 创建一个没有原型的对象
var o1 = Object.create(null);  
// 同 {} 和 new Object()
var o2 = Object.create(Object.prototype); 
o2.a = 1;
// o3._propo_ = o2 继承了o2, 也继承了o2的属性a；增加了属性 b=1;
var o3 = Object.create(o2, {b: { vaue: 1, writable: true}}); 
o3; // print {b:1} ：自🈶️属性
o3.a; // print 1: 获取对象的属性，如果自有属性没有，会继续在对象继承的原型链中（o3&gt;o2&gt;Object.prototype）查找。</code></pre>
<p>自己实现一个 <code>Object.create()</code>:</p>
<pre><code class="language-javascript">Object.myCreate = function (obj, properties)  {
  var F = function ()  {}
  F.prototype = obj
  if (properties) {
     Object.defineProperties(F, properties)
  }
  return new F()
}

Object.myCreate({}, {a: {value: 1}})     // {a: 1}</code></pre>
<hr>
<h1 id="对象动态属性"><a href="#对象动态属性" class="headerlink" title="对象动态属性"></a>对象动态属性</h1><pre><code class="language-javascript">// 设置
var selfProp = &#39;other&#39;;
var index = 1;
var book={
  &quot;main title&quot;: &quot;&quot;, // 属性名有空格必须使用字符串表示
  &quot;sub-title&quot;: &quot;&quot;,  // 属性名有连字符必须使用字符串表示
  auther: &quot;&quot;,
  [selfProp + index]: &quot;&quot;   // 动态属性通过 [] 设置。 
}
// 读取 
var auther = book.auther;
var title = book[&quot;main title&quot;]; // 属性名有空格，连字符的属性通过 [] 获取。
var other = book[selfProp + index]; // 动态属性通过 [] 获取。
</code></pre>
<hr>
<h1 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h1><ul>
<li><code>delete</code>只能删除自由属性，无法删除继承属性。</li>
<li><code>delete</code>无法删除通过<code>var</code>定义的全局变量。</li>
</ul>
<pre><code class="language-javascript">delete book.auther;              // true
delete book[&quot;main title&quot;];       // true
var obj = Object.create({x: 1}); 
delete obj.x;                    // true 但是并没有删除继承属性x。
var global1 = 1;                 // 定义全局变量，用var
this.global2 = 2;                // 定义全局变量
delete global1;                  // 无法删除
delete global2;                  // 可删除</code></pre>
<hr>
<h1 id="检测属性的几种方式"><a href="#检测属性的几种方式" class="headerlink" title="检测属性的几种方式"></a>检测属性的几种方式</h1><ul>
<li><code>in</code> 运算符</li>
<li><code>.property !== undefined</code>的形式</li>
<li><code>hasOwnProperty()</code> （ 只能检测自有属性 ）</li>
</ul>
<hr>
<h1 id="枚举对象属性"><a href="#枚举对象属性" class="headerlink" title="枚举对象属性"></a>枚举对象属性</h1><ul>
<li>for/in 运算符: 可枚举自有属性和继承属性</li>
<li>Object.keys(obj)：只能枚举自有属性</li>
</ul>
<hr>
<h1 id="Object对象常用方法"><a href="#Object对象常用方法" class="headerlink" title="Object对象常用方法"></a>Object对象常用方法</h1><ul>
<li>Object.assign();</li>
<li>Object.create();</li>
<li>Object.keys();</li>
<li>Object.values();</li>
<li>Object.defineProperty();</li>
<li>Object.entries();</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">其他-MDN</a></li>
</ul>
<hr>
<h1 id="对象原型判断"><a href="#对象原型判断" class="headerlink" title="对象原型判断"></a>对象原型判断</h1><ul>
<li><code>isPrototypeOf</code>方法(推荐)</li>
<li><code>_proto_</code>属性</li>
</ul>
<pre><code class="language-javascript">var obj = {};
var newObj = Object.create(obj);
obj.isPrototypeOf(newObj);  // true
newObj._proto_ === obj; // true</code></pre>
<hr>
<h1 id="获取对象类属性（class-attribute）"><a href="#获取对象类属性（class-attribute）" class="headerlink" title="获取对象类属性（class attribute）"></a>获取对象类属性（class attribute）</h1><ul>
<li><code>typeof</code> 操作符:</li>
</ul>
<pre><code class="language-javascript">typeof null;         // =&gt; &quot;object&quot;
typeof undefined;    // =&gt; &quot;undefined&quot;
typeof true;         // =&gt; &quot;boolean&quot;
typeof 100;          // =&gt; &quot;number&quot;  NaN也是
typeof &quot;abc&quot;;        // =&gt; &quot;string&quot;
typeof function(){}; // =&gt; &quot;function&quot;
typeof 任意内置对象；  // =&gt; &quot;&quot;object</code></pre>
<ul>
<li>利用<code>Object.prototype.toString()</code> 返回 <code>[object class]</code>的特性，实现一下方法：</li>
</ul>
<pre><code class="language-javascript">function classof(0) {
  if (o === null) return &#39;null&#39;;
  if(o === undefined) return &#39;undefined&#39;;
  return Object.prototype.toString.call(o).slice(8,-1);
}

classof(1); // =&gt; &#39;Number&#39;
classof(&quot;&quot;); // =&gt; &#39;String&#39;
classof(false); // =&gt; &#39;Boolean&#39;
classof({}); // =&gt; &#39;Object&#39;
classof([]); // =&gt; &#39;Array&#39;
classof(/./); // =&gt; &#39;Regexp&#39;
classof(new Date()); // =&gt; &#39;Date&#39;
classof(Window); // =&gt; &#39;Window&#39;
function f() {};
classof(new f()); // =&gt; &#39;Object&#39;</code></pre>
<hr>
<h1 id="数组须知"><a href="#数组须知" class="headerlink" title="数组须知"></a>数组须知</h1><ul>
<li>数组索引必须为非负整数（非负整数的字符串也可以）。使用其他类型来索引数组，只能作为数组的属性。</li>
</ul>
<pre><code class="language-javascript">var a = new Array(10) // =&gt; length = 10 
a[&quot;1000&quot;] = 1; // =&gt; length = 1001  ( [0,1,...1000] )
a[-1] = -1; // =&gt; length 不变，数组多一个“-1”属性</code></pre>
<ul>
<li>数组也是对象，可以使用对象的各种方法和操作。</li>
</ul>
<pre><code class="language-javascript">//eg
var a = new Array(10)
Object.defineproperty(a,&#39;length&#39;,{writable: false}) // 让数组length不可变</code></pre>
<ul>
<li><code>delete</code> 不会改变数组的<code>length</code>，只是让某个 索引位 没有值。</li>
</ul>
<h1 id="Get-Post-请求须知"><a href="#Get-Post-请求须知" class="headerlink" title="Get/Post 请求须知"></a>Get/Post 请求须知</h1><ul>
<li>请求数据大小的限制并不是HTTP协议限制，而是浏览器的限制。</li>
<li>get适合查找数据，post适合添加/修改数据。所以在缓存策略上，get请求可以被缓存，post请求不会被缓存。</li>
</ul>
<h1 id="为什么频繁调用-element-getboundingclientrect-可能引发重绘-回流？"><a href="#为什么频繁调用-element-getboundingclientrect-可能引发重绘-回流？" class="headerlink" title="为什么频繁调用 element.getboundingclientrect() 可能引发重绘/回流？"></a>为什么频繁调用 element.getboundingclientrect() 可能引发重绘/回流？</h1><p>浏览器都会优化重绘和回流的操作。浏览器会把所有会引起回流、重绘的Dom操作放入一个队列中，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p>另外，当我们取一些属性值时（offsetWidth、clientWidth、width）等，只为了取到正确的值，浏览器可能提前执行 flush 队列，即便是队列里的操作不影响所取的值。</p>
<h1 id="ES6-定义对象方法时，还可以省去-function-关键字。"><a href="#ES6-定义对象方法时，还可以省去-function-关键字。" class="headerlink" title="ES6 定义对象方法时，还可以省去 function 关键字。"></a>ES6 定义对象方法时，还可以省去 function 关键字。</h1><pre><code class="language-js">{
  reducers: {
    add() {}  // 等同于 add: function() {}
  },
  effects: {
    *addRemote() {}  // 等同于 addRemote: function*() {}
  },
}</code></pre>
<h1 id="Set集合-amp-Map字典"><a href="#Set集合-amp-Map字典" class="headerlink" title="Set集合 &amp; Map字典"></a>Set集合 &amp; Map字典</h1><p>Set 操作方法：</p>
<ul>
<li>add(value)：新增，相当于 array里的push。</li>
<li>delete(value)：存在即删除集合中value。</li>
<li>has(value)：判断集合中是否存在 value。</li>
<li>clear()：清空集合。</li>
</ul>
<p>Map 操作方法：</p>
<ul>
<li><p>set(key, value)：向字典中添加新元素。</p>
</li>
<li><p>get(key)：通过键查找特定的数值并返回。</p>
</li>
<li><p>has(key)：判断字典中是否存在键key。</p>
</li>
<li><p>delete(key)：通过键 key 从字典中移除对应的数据。</p>
</li>
<li><p>clear()：将这个字典中的所有元素删除。</p>
</li>
<li><p>共同点：集合、字典 可以储存不重复的值。</p>
</li>
<li><p>不同点：集合 是以 <code>[value, value]</code>的形式储存元素，字典 是以 <code>[key, value]</code> 的形式储存</p>
</li>
</ul>
<h1 id="页面加载多个JS的处理过程"><a href="#页面加载多个JS的处理过程" class="headerlink" title="页面加载多个JS的处理过程"></a>页面加载多个JS的处理过程</h1><p>step 1. 读入第一个代码块。</p>
<p>step 2. 做语法分析，有错则报语法错误（比如括号不匹配等），并跳转到step5。</p>
<p>step 3. 对var变量和function定义做“预编译处理”（永远不会报错的，因为只解析正确的声明）。</p>
<p>step 4. 执行代码段，有错则报错（比如变量未定义）。</p>
<p>step 5. 如果还有下一个代码段，则读入下一个代码段，重复step2。</p>
<p>step6. 结束。</p>
<h1 id="HTTPS加密为啥需要CA认证"><a href="#HTTPS加密为啥需要CA认证" class="headerlink" title="HTTPS加密为啥需要CA认证"></a>HTTPS加密为啥需要CA认证</h1><p>方案一：对称加密</p>
<p>加密解密使用同一个密钥。<br>存在密钥协商的问题（客户端和服务器同步密钥的时候很容易被截获）。</p>
<p>方案二：非对称加密</p>
<p>公钥/私钥互为锁和钥匙。如果 公钥 在服务器发送给客户端时被窃取。那么服务器私钥加密的内容会被坏人解密。不过，客户端发送的公钥加密过的数据，坏人没有私钥没法解密。另外，非对称加密性能是很差的，因为支持双向加解密，复杂度和密钥长度都需要很大，否则容易被暴力破解。</p>
<p>方案三：改进方案</p>
<ul>
<li>方案：客户端获取公钥后生成对称密钥，然后用公钥加密后给服务器，服务器用私钥解密得到对称密钥，后续就进行对称加密即可。</li>
<li>问题：如果坏人一开始就窃听了公钥，然后发送假的公钥（当然坏人有对应的私钥）给客户端。那么客户端发给服务器的对称密钥会被第三方解密，然后第三方用真的公钥加密给服务器。这样，后续的通信中，第三方就能获取所有的信息，毕竟得到了对称密钥。</li>
</ul>
<p>为了做到绝对的安全，CA认证（数字证书+数字签名）诞生。具体流程如下：</p>
<ol>
<li><p>服务器需要提交服务器站点的信息如域名、公司名称、公钥等给CA机构去申请和购买数字证书。CA机构就是数字证书颁发的权威机构，负责颁发证书以及验证证书的合法性。</p>
</li>
<li><p>CA机构在给服务器颁发证书的时候，除了<strong>数字证书</strong>，还会根据 <code>数字证书 + hash算法（MD5）</code>计算出<strong>摘要</strong>，CA机构自己的私钥对摘要进行加密形成<strong>数字签名</strong>一并发给服务器。</p>
</li>
<li><p>服务器在与客户端通信的时候，就会将数字证书和数字签名出示给客户端。客户端也能拿到浏览器内置的CA机构的公钥。</p>
</li>
<li><p>客户端使用CA公钥解密数字签名得到摘要，再通过 <code>数字证书 + hash算法</code>计算出摘要。如果两个摘要一致，那就证书有效，否则证书被篡改。因为CA机构的私钥坏人得不到。</p>
</li>
<li><p>客户端生成对称密钥，用从证书拿到服务器的 公钥 加密后发给服务器，服务器用 私钥 解密拿到密钥。因为客户端拿到的肯定是服务器正确的公钥，所以没有方案三存在的问题。</p>
</li>
<li><p>密钥协商完成，对称加密传输数据。</p>
</li>
</ol>
<h1 id="数组解构赋值交换元素"><a href="#数组解构赋值交换元素" class="headerlink" title="数组解构赋值交换元素"></a>数组解构赋值交换元素</h1><p>等号的左右两边模式相同，就会将右边的值赋给左边的变量。</p>
<pre><code class="language-js">[array[index1],array[index2]] = [array[index2],array[index1]];</code></pre>
<h1 id="JSBridge-原理"><a href="#JSBridge-原理" class="headerlink" title="JSBridge 原理"></a>JSBridge 原理</h1><ul>
<li>JavaScript 调用 Native 推荐使用 注入 API 的方式。通过 WebView 提供的接口，Native 向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</li>
<li>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</li>
</ul>
<pre><code class="language-js">//js具体实现：
(function () {
    var id = 0,
        callbacks = {},
        registerFuncs = {};

    window.JSBridge = {
        // 调用 Native
        invoke: function(bridgeName, callback, data) {
            // 判断环境，获取不同的 nativeBridge
            var thisId = id ++; // 获取唯一 id
            callbacks[thisId] = callback; // 存储 Callback
            nativeBridge.postMessage({
                bridgeName: bridgeName,
                data: data || {},
                callbackId: thisId // 传到 Native 端
            });
        },
        receiveMessage: function(msg) {
            var bridgeName = msg.bridgeName,
                data = msg.data || {},
                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回
                responstId = msg.responstId;
            // 具体逻辑
            // bridgeName 和 callbackId 不会同时存在
            if (callbackId) {
                if (callbacks[callbackId]) { // 找到相应句柄
                    callbacks[callbackId](msg.data); // 执行调用
                }
            } elseif (bridgeName) {
                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄
                    var ret = {},
                        flag = false;
                    registerFuncs[bridgeName].forEach(function(callback) =&gt; {
                        callback(data, function(r) {
                            flag = true;
                            ret = Object.assign(ret, r);
                        });
                    });
                    if (flag) {
                        nativeBridge.postMessage({ // 回调 Native
                            responstId: responstId,
                            ret: ret
                        });
                    }
                }
            }
        },
        register: function(bridgeName, callback) {
            if (!registerFuncs[bridgeName])  {
                registerFuncs[bridgeName] = [];
            }
            registerFuncs[bridgeName].push(callback); // 存储回调
        }
    };
})();
//作者：嫖桑 https://juejin.cn/post/6844903585268891662</code></pre>
<h1 id="语音播报"><a href="#语音播报" class="headerlink" title="语音播报"></a>语音播报</h1><pre><code class="language-js">function  voiceAnnouncements(str){
//百度
    var  url = &quot;http://tts.baidu.com/text2audio?lan=zh&amp;ie=UTF-8&amp;text=&quot; + encodeURI(str); // baidu
    var  n = new  Audio(url);
    n.src = url;
    n.play();
}
voiceAnnouncements(&#39;你好，今天吃的什么？&#39;)</code></pre>
<h1 id="静态作用域-和-闭包"><a href="#静态作用域-和-闭包" class="headerlink" title="静态作用域 和 闭包"></a>静态作用域 和 闭包</h1><ul>
<li>因为JavaScript是静态作用域的，所以它内部环境中需要的变量在编译时就确定了，运行时不会改变；</li>
<li>又因为JavaScript中，函数是一等公民，可以被调用，可以作为参数传递，可以赋值给变量，也可以作为函数返回值，所以它的运行时环境很容易变化；</li>
<li>当函数作为另一个函数（外层函数）的返回值返回时，其外层函数中的变量已经从调用栈弹出，但是我们必须让内部函数可以访问到它需要的变量，因此运行时的环境和定义时的作用域之间就产生矛盾；</li>
<li>所以我们把内部环境中需要的变量，打包交给内层函数（闭包函数），它就可以随时访问这些变量了，就形成了闭包。</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/07/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" itemprop="url">跨域问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T18:36:25+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p>作为前端开发，尤其当下前后端分离越来越普遍，<strong>跨域</strong>成为我们工作中经常会遇到的问题。</p>
<p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器对<code>JavaScript</code>实施的安全限制。所谓的同源是指 域名（包括二级域名）、协议、端口均相同。</p>
<blockquote>
<p><code>localhost</code> 调用 <code>127.0.0.1</code> 也属于跨域。</p>
</blockquote>
<p>同源策略限制了以下行为：</p>
<ul>
<li>无法读取 <code>Cookie</code>、<code>LocalStorage</code> 、<code>SessionStorage</code> 和 <code>IndexDB</code> </li>
<li>无法获取 <code>DOM</code> 和 <code>JS</code> 对象</li>
<li>无法发送 <code>Ajax</code> 请求</li>
</ul>
<p>常见跨域场景主有二种：</p>
<ul>
<li>场景一：嵌套第三方页面，并互相通信。</li>
<li>场景二：跨域<code>Ajax</code>请求。</li>
</ul>
<p>场景一主要涉及的前端技术有：</p>
<ul>
<li><code>Iframe</code>…</li>
<li><code>PostMessage</code></li>
<li>代理服务（<code>Nginx</code>）</li>
</ul>
<p>场景二主要涉及的前端技术有：</p>
<ul>
<li><code>JSONP</code></li>
<li>跨域资源共享(<code>Cors</code>)</li>
<li>代理服务（<code>Nginx</code>）</li>
</ul>
<p>接下来，我们分别探讨一下。</p>
<h1 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h1><p><code>Iframe</code> 的应用一直非常广泛，包括当下。用于在你的页面开辟一个子窗体嵌套展示其他页面。主要解决页面级别的复用问题。很多时候，你不仅需要展示子页面，还需要和子页面沟通。由于<code>Iframe</code>同样受同源策略限制，跨域问题就随之而来。</p>
<p>曾经我们主要通过以下2种方式解决<code>iframe</code>跨域问题：</p>
<ul>
<li>设置 <code>domain</code> 解决主域名相同，二级域名不同导致的跨域阻碍。</li>
<li>通过一个<strong>同域</strong>的<strong>中间页</strong>。</li>
</ul>
<p>当下，我们主要通过接下来要介绍的 <code>PostMessage</code>来解决跨域窗口通信问题，以上方式就不具体赘述。</p>
<h1 id="PostMessage"><a href="#PostMessage" class="headerlink" title="PostMessage"></a>PostMessage</h1><p><code>window.postMessage</code>是一个安全的、基于事件的消息<code>API</code>。它允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文档、多窗口、跨域消息传递。<code>IE8+</code>，<code>chrome</code>，<code>firefox</code>等都已经支持。同源窗口通信也可以使用<code>PostMessage</code>，逻辑比较清晰。</p>
<p><code>PostMessage</code>实现通信的方式也很简单，分为两步:</p>
<ul>
<li>发送消息</li>
<li>接受消息</li>
</ul>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>在需要发送消息的源窗口调用<code>targetWindow.postMessage(message,targetOrigin)</code>方法即可发送消息：</p>
<h3 id="targetWindow"><a href="#targetWindow" class="headerlink" title="targetWindow"></a><code>targetWindow</code></h3><p><code>targetWindow</code>是对目标窗体的引用。获得该引用的方法包括：</p>
<ul>
<li><code>Window.open</code> JS打开的窗体</li>
<li><code>Window.opener</code> 打开当前窗体的窗体</li>
<li><code>HTMLIFrameElement.contentWindow</code> iframe窗体</li>
<li><code>Window.parent</code> 当前窗体的父窗体</li>
<li><code>Window.frames[index]</code> 当前窗体的 iframe</li>
</ul>
<h3 id="message-参数"><a href="#message-参数" class="headerlink" title="message 参数"></a><code>message</code> 参数</h3><ul>
<li>作用：要传递的数据。</li>
<li>类型：可以是<code>JS</code>的任意基本类型或可复制的对象。然而部分浏览器只能处理字符串参数，保险起见，推荐使用<code>JSON.stringify()</code>方法对数据序列化。</li>
</ul>
<h3 id="targetOrigin-参数："><a href="#targetOrigin-参数：" class="headerlink" title="targetOrigin 参数："></a><code>targetOrigin</code> 参数：</h3><ul>
<li>类型：<code>string</code></li>
<li>作用：为了安全考虑，指明目标窗口的源，协议+域名+端口号[+path]，path会被忽略，所以可以不写。当然如果愿意也可以设置为<code>&quot;*&quot;</code>，这样可以传递给任意窗口，如果要指定和当前窗口同源的话可设置为<code>&quot;/&quot;</code>。</li>
</ul>
<blockquote>
<p>只有当目标窗口的源与postMessage函数中传入的源参数值匹配时，才能接收到消息。</p>
</blockquote>
<p>举个栗子：</p>
<pre><code class="language-js">// http://www.domainA.com
// 发送消息
var iframe = document.getElementById(&#39;iframe&#39;)
iframe.contentWindow.postMessage(&#39;hi&#39;, &#39;http://www.domainB.com&#39;)</code></pre>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>目标窗体通过监听<code>window</code>的<code>message</code>事件就可以接收任何窗口传递来的消息了。</p>
<p><code>message</code>事件的<code>event</code>对象有三个属性，分别是：</p>
<ul>
<li><code>event.data</code> 表示接收到的消息；</li>
<li><code>event.origin</code> 表示<code>postMessage</code>的发送来源，包括协议，域名和端口；</li>
<li><code>event.source</code> 表示发送消息的窗口对象的引用。我们可以用这个引用来建立两个不同来源的窗口之间的双向通信。</li>
</ul>
<p>举个栗子：</p>
<pre><code class="language-js">// http://www.domainB.com
// 接受消息
function receiveMsg(event) {
  // 打印消息
  console.log(event.data)
  // 双向通信
  event.source.postMessage(&#39;hello&#39;, &#39;http://www.domainA.com&#39;)
  // 如果是父窗口 也可以这么沟通
  window.parent.postMessage(&#39;hello&#39;, &#39;http://www.domainA.com&#39;)
}
// 监听message事件
if (window.addEventListener) {
  window.addEventListener(&#39;message&#39;, receiveMsg, false);
}else {
  window.attachEvent(&#39;message&#39;, receiveMsg);
}</code></pre>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>曾经主流的跨域<code>Ajax</code>请求的主要方式，虽然当下已经有点过时，但还是值得了解以下的。它的原理比较有趣，算是一种“投机取巧”的设计模式吧。</p>
<ul>
<li>原理：利用<code>html</code>页面允许通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的特点，动态的创建<code>script</code>标签，再去请求一个带参（包含一个<strong>回调方法</strong>作为参数）<code>url</code>来实现跨域通信。</li>
<li>缺点：只能够实现 <code>get</code> 请求。</li>
</ul>
<pre><code class="language-js">//原生实现方式
let script = document.createElement(&#39;script&#39;);

script.src = &#39;http://www.nealyang.cn/login?username=Nealyang&amp;callback=callback&#39;;

document.body.appendChild(script);

function callback(res) {
  console.log(res);
}</code></pre>
<h1 id="跨域资源共享-Cors"><a href="#跨域资源共享-Cors" class="headerlink" title="跨域资源共享(Cors)"></a>跨域资源共享(Cors)</h1><hr>
<p><code>CORS</code> 是目前主流的跨域 <code>Ajax</code> 请求解决方案。</p>
<ul>
<li>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。</li>
<li>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。</li>
<li>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，<code>IE</code>浏览器不能低于<code>IE10</code>。</li>
<li>整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。</li>
<li>实现<code>CORS</code>通信的关键是服务器。只要服务器实现了<code>CORS</code>接口，就可以跨源通信。浏览器一旦发现<code>AJAX</code>请求跨源，就会自动添加一些附加的头信息，有时还会多一次附加的请求，但用户不会有感觉。 </li>
</ul>
<p>要理解<code>Cors</code> 需要搞清楚以下几个概念：</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>简单请求需要满足以下几点：</p>
<ul>
<li>请求方式为 HEAD、POST 或者 GET</li>
<li>http头信息不超出以下原始字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type。</li>
<li>Content-Type限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>简单请求之外的其他请求。非简单请求在正式通信之前，浏览器会先发送OPTION请求，进行预检，这一次的请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p>
<h2 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a><code>withCredentials</code> 属性</h2><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<h1 id="代理服务（如-Nginx）"><a href="#代理服务（如-Nginx）" class="headerlink" title="代理服务（如 Nginx）"></a>代理服务（如 Nginx）</h1><ul>
<li>特殊，个别，紧急情况下，可以考虑通过代理服务（如<code>Nginx</code>）配置<code>url</code>地址映射解决跨域等问题。</li>
<li>一般由运维/后端人员负责配置。</li>
<li>不用发布代码，高效，非常有用。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.imooc.com/article/21976" target="_blank" rel="noopener">详解跨域</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰-Cors详解</a><br><a href="https://ningyu1.github.io/site/post/92-cors-ajax/#solution1" target="_blank" rel="noopener">Cors常见问题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/06/28/CSS%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/CSS%E7%A2%8E%E7%89%87/" itemprop="url">CSS碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T19:36:26+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单行-多行文本溢出省略号"><a href="#单行-多行文本溢出省略号" class="headerlink" title="单行/多行文本溢出省略号"></a>单行/多行文本溢出省略号</h1><hr>
<pre><code class="language-css">/* 单行 */
.oneLine {
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap
}

/* 👇 仅适用于WebKit浏览器或移动端的页面 */

.twoLine {
  /* 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 */
  display: -webkit-box; 
  /* 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 */
  -webkit-box-orient: vertical; 
  /* 行数*/
  -webkit-line-clamp: 2; 
  overflow: hidden;
}</code></pre>
<h1 id="毛玻璃模糊遮罩效果"><a href="#毛玻璃模糊遮罩效果" class="headerlink" title="毛玻璃模糊遮罩效果"></a>毛玻璃模糊遮罩效果</h1><hr>
<pre><code class="language-css">/* 
filter: CSS属性将模糊或颜色偏移等图形效果应用于元素。
blur(radius):函数将高斯模糊应用于输入图像。
  radius 定义了高斯函数的标准偏差值，或者屏幕上有多少像素相互融合.
  因此，较大的值将产生更多的模糊。若没有设置值，默认为0。
  该参数可以指定为 CSS 长度，但不接受百分比值。
*/
.Mask {
  filter: blue(2px);
}</code></pre>
<h1 id="position-sticky-实现粘性布局的坑"><a href="#position-sticky-实现粘性布局的坑" class="headerlink" title="position:sticky 实现粘性布局的坑"></a>position:sticky 实现粘性布局的坑</h1><hr>
<p>设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code> 是根据元素是否达到设定了的阈值（<code>top, left,...</code>）决定的。</p>
<pre><code class="language-css">/* 下面元素当滚动到viewPort顶部以后吸顶*/
.Box {
  top:0;
  position: sticky;
}</code></pre>
<ul>
<li>问题：粘性布局突然时效。</li>
<li>原因：其他组件<code>CSS</code> 给页面顶层元素增加 <code>overflow:hidden;</code> 导致。设定为 <code>position:sticky</code> 元素的<strong>任意</strong>父节点的 <code>overflow</code> 属性必须是 <code>visible</code>，否则 <code>position:sticky</code> 不会生效。</li>
<li><a href="https://www.cnblogs.com/coco1s/p/6402723.html" target="_blank" rel="noopener">参考文档</a></li>
</ul>
<p><code>position:sticky</code> 的生效的其他限制：</p>
<ul>
<li>须指定 <code>top, right, bottom</code> 或 <code>left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li>
<li>并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</li>
</ul>
<h1 id="隐藏滚动元素的滚动条"><a href="#隐藏滚动元素的滚动条" class="headerlink" title="隐藏滚动元素的滚动条"></a>隐藏滚动元素的滚动条</h1><hr>
<ul>
<li>背景：显示原生滚动条太丑，自定义滚动条交互样式。</li>
<li>方法：滚动元素包装一个父元素，设置其高度为 滚动元素高度 - 滚动条高度（以X轴为例）。</li>
</ul>
<pre><code class="language-css">/* 滚动元素 */
.scrollDiv {
  height: 5rem;
  overflow-x: auto;
}
/* 滚动元素父元素*/
.scrollDivContainer {
  overflow: hidden;
  height: 4.6rem;
}</code></pre>
<blockquote>
<p>方法2: 增加一个同级 <code>Div</code> 或使用父元素的 伪类 元素；通过 绝对定位 + 同色背景 遮住滚动条。</p>
</blockquote>
<h1 id="css-新特性-contain"><a href="#css-新特性-contain" class="headerlink" title="css 新特性 contain"></a>css 新特性 contain</h1><p>CSS contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图、大小或这四项的组合时，只影响到有限的 DOM 区域，而不是整个页面，可以有效改善性能。</p>
<p>使用参考： <a href="https://juejin.cn/post/6958990366888607757" target="_blank" rel="noopener">CSS新特性contain，控制页面的重绘与重排</a></p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter" target="_blank" rel="noopener">Moz-filter滤镜</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/06/25/web%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/web%E7%A2%8E%E7%89%87/" itemprop="url">web碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T18:33:01+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本地种cookie"><a href="#本地种cookie" class="headerlink" title="本地种cookie"></a>本地种cookie</h1><p><code>document.cookie = &quot;name=value;path=path;domain=domain&quot;</code></p>
<hr>
<h1 id="微信URl自带参数"><a href="#微信URl自带参数" class="headerlink" title="微信URl自带参数"></a>微信URl自带参数</h1><p>原来微信会在原来的网页网址后面加上一个参数，朋友圈、好友分享和微信群的参数各不同：<br>朋友圈   <code>from=timeline&amp;isappinstalled=0</code><br>微信群   <code>from=groupmessage&amp;isappinstalled=0</code><br>好友分享 <code>from=singlemessage&amp;isappinstalled=0</code></p>
<hr>
<h1 id="滚动区域css背景设置"><a href="#滚动区域css背景设置" class="headerlink" title="滚动区域css背景设置"></a>滚动区域css背景设置</h1><p>滚动区域设置background-color，不可见区域没有生效。<br>办法是加float: left</p>
<hr>
<h1 id="object-key"><a href="#object-key" class="headerlink" title="object[key]"></a>object[key]</h1><p>eval(“myValue = myObject.” + myKey + “;”);<br>可以直接写成<br>myValue = myObject[myKey];</p>
<hr>
<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。</p>
<hr>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li>Object.assign({},obj) 只深拷贝第一层！！！！</li>
<li>JSON.parse(JSON.stringfy(obj)) 完全深拷贝 </li>
</ul>
<p>因为在序列化JavaScript对象时，所有函数和原型成员会被有意忽略。用于拷贝的对象中只能是Number, String, Boolean, Array, 扁平对象，即那些能够被 JSON 直接表示的数据结构。JSON.parse(JSON.stringfy(obj)) 缺陷：</p>
<ul>
<li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式。</li>
<li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li>
<li>如果obj里有函数，undefined，file数据流，则序列化的结果会把函数或 undefined丢失；</li>
<li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null；</li>
<li>如果对象中存在循环引用的情况也无法正确实现深拷贝；</li>
</ul>
<blockquote>
<p>参考文档<a href="https://www.cnblogs.com/makai/p/13883544.html" target="_blank" rel="noopener">JSON.stringify深拷贝的缺点</a></p>
</blockquote>
<hr>
<h1 id="获取元素位置的快速方法"><a href="#获取元素位置的快速方法" class="headerlink" title="获取元素位置的快速方法"></a>获取元素位置的快速方法</h1><p>使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。<br>所以，网页元素的相对位置就是：</p>
<pre><code class="language-javascript">  var X= this.getBoundingClientRect().left;
  var Y =this.getBoundingClientRect().top;</code></pre>
<p>再加上滚动距离，就可以得到绝对位置</p>
<pre><code class="language-javascript">  var X= this.getBoundingClientRect().left + document.documentElement.scrollLeft;
  var Y =this.getBoundingClientRect().top + document.documentElement.scrollTop;</code></pre>
<h1 id="IOS-Universal-Links"><a href="#IOS-Universal-Links" class="headerlink" title="IOS Universal Links"></a>IOS Universal Links</h1><p>Universal Links是iOS9推出的一项功能，使你的应用可以通过传统的HTTPS链接来启动APP(如果iOS设备上已经安装了你的app，不管在微信里还是在哪里)， 或者打开网页(iOS设备上没有安装你的app)。<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html" target="_blank" rel="noopener">官网</a>配置如下：<br>Adding support for universal links is easy. There are three steps you need to take:</p>
<ul>
<li><p>Create an apple-app-site-association file that contains JSON data about the URLs that your app can handle.</p>
</li>
<li><p>Upload the apple-app-site-association file to your HTTPS web server. You can place the file at the root of your server or in the .well-known subdirectory.</p>
</li>
<li><p>Prepare your app to handle universal links.</p>
</li>
</ul>
<h1 id="const-定义的数据也可变"><a href="#const-定义的数据也可变" class="headerlink" title="const 定义的数据也可变"></a>const 定义的数据也可变</h1><p>对象这种引用类型可以：</p>
<pre><code class="language-javascript">// allowed
const helloWorld = {
text: &#39;Welcome to the Road to learn React&#39;
};
helloWorld.text = &#39;Bye Bye React&#39;;</code></pre>
<h1 id="箭头函数-this"><a href="#箭头函数-this" class="headerlink" title="箭头函数 this"></a>箭头函数 this</h1><p>一个普通的函数表达式总会定义它自己的 this 对象。this指向函数被调用时候的作用域。<br>但是箭头函数表达式仍然会使用包含它的语境下的 this 对象。this指向函数被定义时候的作用域。</p>
<h1 id="ES6-自动属性名"><a href="#ES6-自动属性名" class="headerlink" title="ES6 自动属性名"></a>ES6 自动属性名</h1><pre><code class="language-javascript">// ES5
var user = {
name: &#39;Robin&#39;,
};
// ES6
const key = &#39;name&#39;;
const user = {
[key]: &#39;Robin&#39;,
};</code></pre>
<h1 id="import-export"><a href="#import-export" class="headerlink" title="import export"></a>import export</h1><p>导入全部变量：</p>
<pre><code class="language-javascript">//file1
const firstname = &#39;robin&#39;;
const lastname = &#39;wieruch&#39;;
export { firstname, lastname };
// file2
import * as person from &#39;./file1.js&#39;;</code></pre>
<p>在导入 default 输出时省略花括号。default 语句，可以被用在一些使用情况下：</p>
<ul>
<li>为了导出和导入单一功能</li>
<li>为了强调一个模块输出 API 中的主要功能</li>
<li>这样可以向后兼容 ES5只有一个导出物的功能</li>
</ul>
<pre><code class="language-javascript">//file1
const firstname = &#39;robin&#39;;
const lastname = &#39;wieruch&#39;;
const person = {
firstname,
lastname,
};
export {
firstname,
lastname,
};
export default person;
// file2
import developer, { firstname as fname, lastname } from &#39;./file1.js&#39;;</code></pre>
<h1 id="chrome-浏览器截取页面"><a href="#chrome-浏览器截取页面" class="headerlink" title="chrome 浏览器截取页面"></a>chrome 浏览器截取页面</h1><ul>
<li>首先按下 ⌘Command + ⌥Option + I（Windows 为 F12）快捷键，召唤出调试界面。</li>
<li>按下 ⌘Command + ⇧Shift + P（Windows 为 Ctrl + Shift + P），输入命令 Capture full size screenshot（只输前几个字母就能找到），敲下回车，Chrome 就会自动截取整个网页内容并保存至本地。</li>
</ul>
<h1 id="axios-fetch-区别"><a href="#axios-fetch-区别" class="headerlink" title="axios fetch 区别"></a>axios fetch 区别</h1><p>Axios是对XMLHttpRequest的封装，而Fetch是一种新的获取资源的接口方式，并不是对XMLHttpRequest的封装。<br>Fetch唯一碾压Axios的一点就是现代浏览器的原生支持，而Axios需要引入Axios库。他们都基于promise。</p>
<h1 id="为什么-Element-getBoundingClientRect-可能引发重绘-回流？"><a href="#为什么-Element-getBoundingClientRect-可能引发重绘-回流？" class="headerlink" title="为什么 Element.getBoundingClientRect() 可能引发重绘/回流？"></a>为什么 Element.getBoundingClientRect() 可能引发重绘/回流？</h1><p>浏览器都会优化重绘和回流的操作。浏览器会把所有会引起回流、重绘的操作放入1个队列中，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。另外，当我们取一些属性值时，类似offsetWidth、clientWidth、width等，只为了取到正确的值，浏览器可能提前执行 flush 队列，即便是队列里的操作不影响所取的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/05/06/hexo-prism-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/hexo-prism-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/" itemprop="url">hexo + prism 代码高亮</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T18:26:28+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么选择-prism"><a href="#为什么选择-prism" class="headerlink" title="为什么选择 prism"></a>为什么选择 prism</h1><p>我使用 hexo + next 搭建的个人博客, <code>NexT</code> 使用 <code>Tomorrow Theme</code> 作为代码高亮, 效果实在差强人意，并存在明显的错误。尤其对<code>jsx</code>的支持很差。在网上去找其他替代方案的时候发现了<code>prism</code>。效果提升明显。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://prismjs.com/download.html" target="_blank" rel="noopener">prism官网</a><br><a href="https://www.zfl9.com/hexo-code.html" target="_blank" rel="noopener">prism配置介绍</a></p>
<blockquote>
<p>注意，项目重新<code>npm install</code>的话，高亮会丢失，你需要重新配置上述文档中的最后一步。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/04/07/React%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/React%E7%A2%8E%E7%89%87/" itemprop="url">React碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T18:13:18+08:00">
                2018-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react-受控组件"><a href="#react-受控组件" class="headerlink" title="react 受控组件"></a>react 受控组件</h1><p>表单元素比如 <input>, <textarea> 和 <select> 会以原生 HTML 的形式保存他们自己的状态。一旦有人从外部做了一些修改，它们就会修改内部的值，在 React 中这被称为不受控组件，因为它们自己处理状态。在 React 中，你应该确保这些元素变为受控组件。<br>你应该怎么做呢？你只需要设置输入框的值属性。</p>
<h1 id="react-可组合组件"><a href="#react-可组合组件" class="headerlink" title="react 可组合组件"></a>react 可组合组件</h1><p>在 <code>props</code> 对象中还有一个小小的属性可供使用: <code>children</code> 属性。通过它你可以将元素从上层传递到你的组件中。</p>
<h1 id="React-事件须知"><a href="#React-事件须知" class="headerlink" title="React 事件须知"></a>React 事件须知</h1><ul>
<li><code>React</code>所有事件都挂载载 <code>document</code> 上</li>
<li>真实 <code>Dom</code> 触发后冒泡到 <code>document</code>后才会对<code>React</code>事件进行处理</li>
<li>所有原生事件先执行</li>
<li>然后执行<code>React</code>合成事件</li>
<li>最后执行真正在<code>document</code>上挂载的事件</li>
<li>原生事件中如果执行了<code>stopPropagation()</code>会导致其他<code>React</code> 事件失效，因为所有事件无法冒泡到<code>document</code>上</li>
</ul>
<h1 id="React-模块热替换-HMR"><a href="#React-模块热替换-HMR" class="headerlink" title="React 模块热替换(HMR)"></a>React 模块热替换(HMR)</h1><p>帮助你在浏览器中重新加载应用的工具，并且无需再让浏览器刷新页面。</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./App&#39;;
import &#39;./index.css&#39;;
ReactDOM.render(
&lt;App /&gt;,
document.getElementById(&#39;root&#39;)
);
// HMR
if (module.hot) {
module.hot.accept();
}</code></pre>
<h1 id="React-列表关键字-Key"><a href="#React-列表关键字-Key" class="headerlink" title="React 列表关键字 Key"></a>React 列表关键字 Key</h1><p><code>React</code> 可以在列表发生变化的时候识别其中成员的添加、更改和删除的状态。你应该确保这个关键字属性是一个稳定的标识符。不要错误地使用列表成员在数组的索引(<code>index</code>)作为关键字。列表成员的索引是完全不稳定的。</p>
<h1 id="React-PorpTypes"><a href="#React-PorpTypes" class="headerlink" title="React PorpTypes"></a>React PorpTypes</h1><p>强烈建议所有子组件声明<code>PorpTypes</code>，尤其UI/业务组件库。</p>
<ul>
<li>支持类型：<code>PropTypes.array</code>，<code>bool</code>，<code>func</code>,<code>number</code>,<code>object</code>,<code>string</code>,（<code>node</code>,<code>element</code> ：可渲染的片段（节点）。比如一段字符串，或者一个 <code>React</code> 元素）</li>
<li>必须参数：必须参数类型后加<code>.isRequired</code>，比如：<code>PropTypes.func.isRequired</code>。</li>
<li>默认值：<code>defaultProps</code>。</li>
<li>你可以将数组 <code>PropTypes</code> 的元素定义的更加明确：</li>
</ul>
<pre><code class="language-javascript">// 类型
Table.propTypes = {
  list: PropTypes.arrayOf(
  PropTypes.shape({
    objectID: PropTypes.string.isRequired,
    author: PropTypes.string,
    url: PropTypes.string,
    num_comments: PropTypes.number,
    points: PropTypes.number,
    })
  ).isRequired,
  onDismiss: PropTypes.func.isRequired,
};
// 默认值
Table.defaultProps = {
  className: &#39;&#39;,
};</code></pre>
<h1 id="props-详解"><a href="#props-详解" class="headerlink" title="props 详解"></a>props 详解</h1><p><a href="https://www.robinwieruch.de/react-pass-props-to-component" target="_blank" rel="noopener">https://www.robinwieruch.de/react-pass-props-to-component</a></p>
<h1 id="子组件状态管理"><a href="#子组件状态管理" class="headerlink" title="子组件状态管理"></a>子组件状态管理</h1><p>子组件初始化状态来自父组件(<code>props</code>)。<code>props</code>改变以后，会触发子组件会重新渲染，但不会执行<code>constructor</code>函数和<code>componentDidMount</code>生命周期。状态管理可总结为两类：</p>
<ul>
<li><p><strong><code>props</code>完全自控</strong>：在<code>constructor</code>函数读取<code>props</code>建立自己的<code>state</code>。<code>onChange</code>的时候<code>setState({})</code>重新渲染自身。同时调用父组件方法更新数据。适用多数组件，比如<code>input</code>使用这种方式比较合理。</p>
</li>
<li><p><strong><code>props</code>非完全自控</strong>： 在<code>render</code>函数直接根据<code>props</code>渲染，<code>onChange</code>的时候调用父组件方法更新父组件的<code>state</code>, 然后父组件重新渲染触发子组件渲染。比如一个<code>list</code>选择组件，<code>initList</code>，<code>checkedValue</code>，来自父组件，<code>value</code>是可控的，可以本地<code>state</code>管理，如果<code>initList</code>是不可控的，取决于父组件，如果在父组件中是可能发生改变的，就没有办法本地管理，所以只能使用这种方式。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/03/27/%E5%BA%95%E5%B1%82API%E5%AE%9E%E7%8E%B0Audio%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/%E5%BA%95%E5%B1%82API%E5%AE%9E%E7%8E%B0Audio%E5%8A%9F%E8%83%BD/" itemprop="url">底层API实现Audio元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T17:43:01+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="公司IOS-APP兼容性问题"><a href="#公司IOS-APP兼容性问题" class="headerlink" title="公司IOS APP兼容性问题"></a>公司IOS APP兼容性问题</h2><p>大家第一反应是，用h5<strong>audio元素</strong>就好了，何须自己实现。原因只有一个：<strong>audio元素</strong>出问题了，在公司IOS APP中出现了兼容性问题：</p>
<pre><code class="language-html">&lt;audio preload=&quot;auto&quot; id=&quot;videoPlay&quot;&gt;
  &lt;source src={declarationUrl}/&gt;
&lt;/audio&gt;</code></pre>
<ul>
<li>列表页 &gt; 详情页 详情页有个人宣言的短音频，点击播放。功能很简单。</li>
<li>到不同的详情页播放，时间久了（无规律）。就会出现播放不了的情况。</li>
<li>卸载重装APP正常，用久了再次出现。</li>
<li>尝试抓包，看上去是缓存了错误的音频（长度为0）。ios排查不出问题，坚称缓存机制没有问题。</li>
<li>压力之下，实在没办法，在小组架构的指导下，才知道还有底层API。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>排查下来，大概率还是 <code>&lt;audio&gt;</code> 自身的缓存策略和我们的 <code>IOS webview</code> 的缓存策略有点冲突。决定自己实现一个<code>&lt;audio&gt;</code>，不采用缓存策略，音频完全下载以后调用底层 <code>API</code> 来实现播放。</p>
<p>组件代码：</p>
<pre><code class="language-jsx">class AudioBuffer {

  constructor(props) {
    this.url = props.url || &#39;&#39;;  // 音频url
    this.playBtn = props.playBtn;  // 播放/暂停 按钮
    this.stopBtn = props.stopBtn;  // 停止 按钮
    this.callback = props.callback; // 回调函数 param：play|pause|stop
    this.sourceNode = null; // BufferSource对象节点
    this.startedAt = 0;  // 播放时间点
    this.pausedAt = 0;  // 暂停时间点
    this.playing = false;  // 播放中
    [&#39;play&#39;, &#39;pause&#39;, &#39;stop&#39;, &#39;update&#39;, &#39;getCurrentTime&#39;, &#39;getDuration&#39;, &#39;init&#39;, &#39;bind&#39;].forEach(method =&gt; {
      this[method] = this[method].bind(this);
    });
    this.init();
  }
  // 播放
  play() {
    let offset = this.pausedAt;
    // 如果已经播放完成，重新播放
    if (offset &gt;= this.getDuration()) {
      offset = 0;
    }
    this.sourceNode = this.context.createBufferSource();
    this.sourceNode.connect(this.context.destination);
    this.sourceNode.buffer = this.buffer;
    this.sourceNode.start(0, offset);
    this.startedAt = this.context.currentTime - offset;
    this.pausedAt = 0;
    this.playing = true;
    if (typeof (this.callback) === &#39;function&#39;) {
      // console.log(&#39;------------callback: play&#39;);
      this.callback(&#39;play&#39;, this);
    }
    this.update();
  }

  update() {
    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
    if (this.getCurrentTime() &lt; this.getDuration()) {
      window.requestAnimationFrame(this.update);
    } else {
      this.stop();
      if (typeof (this.callback) === &#39;function&#39;) {
        // console.log(&#39;------------callback: stop&#39;);
        this.callback(&#39;stop&#39;, this);
      }
    }
  }
  // 暂停
  pause() {
    const elapsed = this.context.currentTime - this.startedAt;
    this.stop();
    this.pausedAt = elapsed;
    if (typeof (this.callback) === &#39;function&#39;) {
       // console.log(&#39;------------callback: pause&#39;);
      this.callback(&#39;pause&#39;, this);
    }
  }
  // 停止
  stop() {
    if (this.sourceNode) {
      this.sourceNode.disconnect();
      this.sourceNode.stop(0);
      this.sourceNode = null;
    }
    this.pausedAt = 0;
    this.startedAt = 0;
    this.playing = false;
    if (typeof (this.callback) === &#39;function&#39;) {
       // console.log(&#39;------------callback: stop&#39;);
      this.callback(&#39;stop&#39;, this);
    }
  }
  // 已播放时间
  getCurrentTime() {
    if (this.pausedAt) {
      return this.pausedAt;
    }
    if (this.startedAt) {
      return this.context.currentTime - this.startedAt;
    }
    return 0;
  }
  // 总时长
  getDuration() {
    return this.buffer.duration;
  }
  // 事件绑定
  bind(buffer) {
    this.buffer = buffer;
    if (this.stopBtn) {
      this.stopBtn.addEventListener(&#39;click&#39;, () =&gt; {
        this.stop();
      });
    }
    this.playBtn.addEventListener(&#39;click&#39;, () =&gt; {
      if (this.playing) {
        this.pause();
      } else {
        this.play();
      }
    });

    // function update() {
    //   window.requestAnimationFrame(update);
    // //   info.innerHTML = sound.getCurrentTime().toFixed(1) + &#39;/&#39; + sound.getDuration().toFixed(1);
    // }
    // update();
  }

  init() {
    window._audioContext = window._audioContext || new (window.AudioContext || window.webkitAudioContext)();
    this.context = window._audioContext;
    const request = new XMLHttpRequest();
    request.open(&#39;GET&#39;, this.url, true);
    request.responseType = &#39;arraybuffer&#39;;
    request.addEventListener(&#39;load&#39;, () =&gt; {
      this.context.decodeAudioData(
        request.response,
        (buffer) =&gt; {
          this.bind(buffer);
        },
        () =&gt; {
        });
    });
    request.send();
  }
}

export default AudioBuffer;
</code></pre>
<p>使用：</p>
<pre><code class="language-jsx">  componentDidMount() {
    const audio = this.refs.videoPlay
    const url = audio.getAttribute(&#39;data-url&#39;)
    if(audio &amp;&amp; url ){  
        this.audio = new AudioBuffer({&#39;url&#39;:url,&#39;playBtn&#39;:this.refs.videoPlay})
      }
    } 
  }</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/03/17/%E8%8B%B1%E8%AF%AD%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/%E8%8B%B1%E8%AF%AD%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/" itemprop="url">英语专业词汇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T10:40:34+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>HTTP</code> HyperText Transfer Protocol，超文本传输协议<br><code>HTTPS</code> Hyper Text Transfer Protocol over SecureSocket Layer，是以安全为目标的 HTTP 通道，HTTPS 在HTTP 的基础下加入SSL 层。<br><code>HSTS</code> 全称 HTTP Strict Transport Security，HTTP严格传输安全，是一个Web安全策略机制。<br><code>DNS</code> Domain Name System 域名解析系统<br><code>CDN</code> Content Delivery Network，即内容分发网络<br><code>function</code> 函数<br><code>functional</code> 函数式<br><code>method</code> 方法。js中指对象中定义的函数，赋值给对象属性的函数。<br><code>programme</code> 编程<br><code>FP</code> Functional Programming 函数式编程<br><code>OOP</code> Object-oriented Programming 面向对象编程<br><code>refactor</code> 代码重构。指对软件代码做任何更动以增加可读性或者简化结构而不影响输出结果。名词是<code>refactorings</code>。<br><code>FSC</code>: functional stateless components 无状态组件，来自React，使用函数定义一个组件。<br><code>lifecycle</code>: 生命周期<br><code>side-effects</code>: 副作用<br><code>Browser</code> 浏览器<br><code>API</code> Application Programming Interface，应用程序编程接口<br><code>Abstraction</code> 抽象<br><code>reusability</code> 复用性<br><code>logic</code> 逻辑<br><code>concept</code> 概念 思想<br><code>feature</code> 特性<br><code>backward compatible</code> 向后兼容<br><code>bloated</code> 臃肿<br><code>solutions</code> 解决方案<br><code>boundary</code> 边界<br><code>syntax</code> 语法，句法<br> <code>destructuring</code>  解构<br> <code>Object destructuring</code> 对象解构<br> <code>prevent</code> 阻止 预防<br> <code>ternary operator</code> 三元操作符 ？：<br> <code>spread operator</code> 展开操作符 …<br> <code>pitfall</code> 陷阱<br> <code>theme</code> 主题<br> <code>producer</code> 生产者<br> <code>consumer</code> 消费者<br> <code>crash</code> 使奔溃  crash your application<br> <code>performance issues</code> 性能问题<br> <code>a pseudo function</code> 伪函数<br> <code>IIFE</code> 立即调用函数表达式(<code>Immediately Invoked function Expression</code>)<br> <code>initially</code> 起初<br> <code>execute</code> 执行<br> <code>plain text</code> 纯文本<br> <code>In this aspect</code> 从这个角度看<br> <code>has no relation to</code> 和……无关<br> <code>embed</code> 嵌入的<br> <code>basics</code> 核心 基本原理<br> <code>QR code</code> 二维码<br> <code>unrealistic</code> 不切实际的<br> <code>contender</code> 竞争者<br> <code>giant</code>  巨头 巨人<br> <code>DCS</code>  Distributed Cache Service, 分布式缓存服务<br> <code>WH</code> Website Hosting, 静态网站托管, 是云开发提供的一项服务<br> <code>Hosting</code> 托管<br> <code>appeal</code> 呼吁<br> <code>maintenance overhead</code> 维护成本<br> <code>reimagine</code> 再定义的<br> <code>specific</code> 特定的 明确的；特性<br> <code>situation</code> 情况;处境<br> <code>make sense</code> 讲得通 言之有理<br> <code>syntactic sugar</code> 语法糖<br> <code>GPU</code>  (=Graphic Processing Unit) 浏览器的图形处理器<br> <code>GUI</code>  (Graphical User Interface) 图形用户接口. 浏览器采用图形方式显示的计算机操作用户界面。<br> <code>AWS</code> 亚马逊云计算服务<br> <code>silver bullet</code> 直译成“银弹”，私以为译成“万金油”（褒义）更接地气一些。<br> <code>reference</code> 引用 参考<br> <code>Flame-graph</code> 火焰图<br> <code>patch</code> 补丁</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2017/04/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/" itemprop="url">浏览器缓存策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-02T15:19:26+08:00">
                2017-04-02
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><hr>
<p><strong>什么是浏览器缓存</strong></p>
<p>我们都知道，<code>web</code>页面显示所需要的各种资源文件（<code>html</code>，<code>css</code>，<code>js</code>，<code>png</code>等）都是通过 <code>HTTP</code>请求从服务端获取的。浏览器缓存便是将这些资源文件保存在浏览器（内存或者硬盘）中，这样同样的资源文件在后续请求中，如果命中缓存，则直接读取浏览器缓存，而无需重新从服务端获取。</p>
<p>浏览器会在内存、硬盘中开辟一个空间用于保存请求资源副本。我们经常调试时在<code>Chrome</code>的 <code>DevTools Network</code> 里看到 <code>Memory Cache</code>（內存缓存）和 <code>Disk Cache</code>（硬盘缓存），指的就是缓存所在的位置。缓存在内存当中，响应速度更快。但是对于大文件，大概率存储在硬盘中；当系统内存使用率高的话，文件优先存储进硬盘。</p>
<p><strong>为什么需要浏览器缓存</strong></p>
<p><code>HTTP</code>请求耗时耗流量，高频的访问服务器也会对服务器形成压力。而且 <code>HTTP</code>请求本身就是浏览器的宝贵资源，并行请求的数量是有限的。所以使用缓存有以下几个好处：</p>
<ul>
<li>减少了无谓的流量消耗和浏览器资源消耗。</li>
<li>增加了网页的响应速度，提升了用户体验。</li>
<li>降低了服务器的压力。</li>
</ul>
<p><strong>为什么需要缓存策略？</strong></p>
<ul>
<li>有些资源文件是高频更新的，不需要也不能被缓存。</li>
<li>有些资源文件是定期更新的，希望被缓存，但是缓存需要有时效性。时效范围内使用缓存，过了失效则从服务器获取。</li>
<li>有些资源文件是不定期更新的，希望被缓存，但是更新后需要重新从服务器获取并更新缓存，不能命中旧缓存。</li>
</ul>
<p>为了满足以上几点，浏览器就需要一套浏览器缓存策略来保证。</p>
<h1 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h1><hr>
<ul>
<li><p><strong>存储策略</strong>：请求后，用于判断是否缓存/更新资源。浏览器会根据服务器响应的报文信息（<code>Response Headers</code>）判断是否缓存/更新该资源。</p>
<ul>
<li>缓存资源发生在首次请求后。</li>
<li>更新资源发生在后续请求后。</li>
</ul>
</li>
<li><p><strong>命中策略</strong>：请求中，用于判断是否使用缓存资源。命中策略的前提是浏览器检索到当前请求资源存在本地缓存。</p>
<ul>
<li>不存在本地缓存： 直接发起<code>HTTP</code>请求，从服务器获取资源文件。</li>
<li>存在本地缓存：根据<code>HTTP</code>请求头中的 <code>缓存标识</code> 判断是否使用缓存，因为缓存可能已过期。</li>
</ul>
</li>
</ul>
<p>根据尝试命中缓存的顺序，可以将 命中策略 分为两个阶段：</p>
<ul>
<li><p><code>强缓存</code>命中阶段: 浏览器每次发起请求时，首先尝试命中 <code>强缓存</code>。</p>
<ul>
<li>如果命中，浏览器会直接读取本地缓存直接响应，不会向服务器发起<code>HTTP</code>请求，请求状态是 <code>200</code> 。</li>
<li>如果没有命中，会向服务器发起<code>HTTP</code>请求，进入 协商缓存 阶段。</li>
</ul>
</li>
<li><p><code>协商缓存</code>命中阶段: <code>强缓存</code> 如果未命中，浏览器会携带参数向服务器发起完整的 <code>HTTP</code> 请求。服务器校验是否命中  <code>协商缓存</code>。</p>
<ul>
<li>如果命中，服务器返回<code>304</code>状态码，通知浏览器直接使用本地缓存资源。</li>
<li>如果没有命中，将从服务端获取资源并返回（状态码 <code>200</code>）。</li>
</ul>
</li>
</ul>
<p>下面，让我们分别详细的了解一下两个阶段具体的 命中策略 和对应的 缓存标识。</p>
<h1 id="强缓存命中策略"><a href="#强缓存命中策略" class="headerlink" title="强缓存命中策略"></a>强缓存命中策略</h1><hr>
<p>控制 强缓存 命中的 <strong>缓存标识</strong> 有两个：</p>
<ul>
<li><code>Expires</code>: <code>Http1.0</code> 就存在，是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求。</li>
<li><code>Cache-Control</code>: <code>Http1.1</code>新增标识。为了解决 <code>Expires</code> 在浏览器时间被手动更改导致缓存判断错误的问题。优先级更高。</li>
</ul>
<h2 id="强缓存-Expires"><a href="#强缓存-Expires" class="headerlink" title="强缓存 - Expires"></a>强缓存 - Expires</h2><ul>
<li><p><strong>来源</strong>：来自 <code>HTTP</code> 请求的服务器响应消息（<code>Response Headers</code>）。</p>
</li>
<li><p><strong>用法</strong>：表示 缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。浏览器在 缓存到期时间 之前再次请求资源即命中，直接使用本地缓存。</p>
</li>
<li><p><strong>优势</strong>：<code>Http 1.0</code>产物，同时兼容 <code>Http 1.0</code> 和 <code>Http 1.1</code> 。简单易用。</p>
</li>
<li><p><strong>劣势</strong></p>
<ul>
<li>时间是由服务器发送的(<code>UTC</code>)，如果服务器时间和客户端时间存在不一致，可能会出现问题。</li>
<li>用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效。</li>
</ul>
</li>
</ul>
<h2 id="强缓存-Cache-control"><a href="#强缓存-Cache-control" class="headerlink" title="强缓存 - Cache-control"></a>强缓存 - Cache-control</h2><ul>
<li><p><strong>来源</strong>：<code>HTTP 1.1</code> 新增，同样来自 <code>HTTP</code> 请求的服务器响应消息（<code>Response Headers</code>）。</p>
</li>
<li><p><strong>用法</strong>：提供了一系列更细致的功能设置。常用值如下：</p>
<ul>
<li><code>private</code>: <strong>默认值</strong>。资源只可以被客户端缓存（代理服务器不能）；后续请求都会直接命中强缓存。</li>
<li><code>public</code>: 资源可以被缓存 (包括客户端和代理服务器，如 CDN边缘缓存服务器)；后续请求都会直接命中强缓存。</li>
<li><code>no-cache</code>: 资源可以被缓存；后续请求不命中 强缓存，但是可以尝试命中协商缓存。</li>
<li><code>no-store</code>: 真正意义上的 “不要缓存”。资源根本不会被缓存，所以也不会执行命中策略，直接请求服务器获取资源。</li>
<li><code>max-age=&lt;seconds&gt;</code>: 缓存存储的最长周期，周期内再次请求都会直接命中强缓存，超过这个周期本地缓存会过期失效。</li>
<li><code>other</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">更多高级用法，参考MDN</a></li>
</ul>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li><code>HTTP 1.1</code> 产物，以时间间隔标识失效时间，解决了<code>Expires</code> 服务器和客户端相对时间的问题。</li>
<li>相比<code>Expires</code>，提供了更多选项设置。</li>
</ul>
</li>
<li><p><strong>劣势</strong>：同样存在客户端本地时间被修改，缓存有效期失真的问题。</p>
</li>
</ul>
<blockquote>
<p><code>Cache-control</code> 的优先级高于 <code>Expires</code>，为了兼容 <code>HTTP/1.0</code> 和 <code>HTTP/1.1</code>，实际项目中两个字段都可以设置。</p>
</blockquote>
<h1 id="协商缓存命中策略"><a href="#协商缓存命中策略" class="headerlink" title="协商缓存命中策略"></a>协商缓存命中策略</h1><hr>
<p>进入协商缓存命中阶段有 两个 前提条件：</p>
<ul>
<li>请求的资源文件，已经在本地缓存当中。</li>
<li>强缓存没有命中。</li>
</ul>
<p>这个时候浏览器会向服务器发起完整的 <code>HTTP</code> 请求，服务器会通过请求头中的 <code>缓存标识</code> 来判断是否命中协商缓存。</p>
<p>决定协商缓存是否命中的 <code>缓存标识</code> 有两组：</p>
<ul>
<li><p><code>Last-Modified</code> 和 <code>If-Modified-since</code> : 两者都是一个(<code>ETC</code>)时间，表示服务器资源最后一次修改的时间。</p>
<ul>
<li><code>Http1.0</code> 就有。</li>
<li><code>Last-Modified</code>：服务器会放 响应报文头 <code>Response Header</code> 响应，浏览器会保存/更新该信息。</li>
<li><code>If-Modified-since</code>：浏览器会放 请求报文头 <code>Request Header</code> 携带。</li>
</ul>
</li>
<li><p><code>Etag</code> 和 <code>If-None-match</code>: 表示的是服务器资源的唯一标识，只要资源变化，<code>Etag</code>就会重新生成。</p>
<ul>
<li><code>Http1.1</code> 新增</li>
<li><code>Etag</code>： 服务器会放响应报文头 <code>Response Header</code> 响应，浏览器会保存/更新该信息。</li>
<li><code>If-None-match</code>： 浏览器会放 请求报文头 <code>Request Header</code> 携带。</li>
</ul>
</li>
</ul>
<p><code>Etag/If-None-match</code> 的优先级比 <code>Last-Modified/If-Modified-since</code> 高。</p>
<h2 id="协商缓存-Last-Modified-If-Modified-since"><a href="#协商缓存-Last-Modified-If-Modified-since" class="headerlink" title="协商缓存 - Last-Modified/If-Modified-since"></a>协商缓存 - Last-Modified/If-Modified-since</h2><ul>
<li>服务器通过 <code>Last-Modified</code> 字段告知客户端，资源最后一次被修改的时间，例如 <code>Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT</code></li>
<li>浏览器将这个值和文件一起记录在缓存数据库中。</li>
<li>下一次请求相同资源时时，浏览器在请求头中将上次的 <code>Last-Modified</code> 的值写入到请求头的 <code>If-Modified-Since</code> 字段。</li>
<li>服务器会将 <code>If-Modified-Since</code> 的值与 <code>Last-Modified</code> 值进行对比。如果相等，则表示未修改，响应 <code>304</code>；反之，则表示修改了，响应 <code>200</code> 状态码，并返回数据。</li>
</ul>
<p><strong>优点</strong>：</p>
<p>不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。</li>
<li>以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
<li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</li>
</ul>
<h2 id="协商缓存-Etag-If-None-match"><a href="#协商缓存-Etag-If-None-match" class="headerlink" title="协商缓存-Etag/If-None-match"></a>协商缓存-Etag/If-None-match</h2><p>为了解决上述问题，<code>Http1.1</code> 新增了一组字段 <code>Etag</code> 和 <code>If-None-Match</code>。</p>
<ul>
<li>服务器存储着文件的 <code>Etag</code> 字段。<code>Etag</code> 存储的是文件的唯一标识(一般都是 <code>hash</code> 生成的)，只有文件内容的变化才会导致 <code>Etag</code>更改。</li>
<li>浏览器在发起请求时，服务器在 Response header中返回 <code>Etag</code> 字段。</li>
<li>浏览器会将Etag值和文件一起记录在缓存数据库中。</li>
<li>在下一次请求相同资源时，浏览器会将上一次返回的 <code>Etag</code> 值赋值给 <code>If-No-Matched</code> 并添加在 <code>Request Header</code>中。</li>
<li>服务器将浏览器传来的 <code>If-No-Matched</code> 跟自己本地资源的 <code>Etag</code> 做对比。如果匹配，则返回 <code>304</code> 通知浏览器读取本地缓存，否则返回 <code>200</code> 和 更新后的资源。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。</li>
<li>不存在版本问题，每次请求都回去服务器进行校验。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>计算<code>Etag</code>值需要性能损耗。</li>
<li>分布式服务器存储的情况下，计算<code>Etag</code>的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现<code>Etag</code>不匹配的情况。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://www.jiqizhixin.com/articles/2020-07-24-12" target="_blank" rel="noopener">彻底弄懂浏览器缓存策略</a><br><a href="https://cloud.tencent.com/developer/article/1439913" target="_blank" rel="noopener">CDN回源原理和多级缓存</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2017/03/14/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/" itemprop="url">一些有用（趣）的网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T14:33:36+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="花瓣网"><a href="#花瓣网" class="headerlink" title="花瓣网"></a>花瓣网</h2><p>大量的灵感图片，可充当设计素材，也可单纯欣赏。<br><a href="https://huaban.com/discovery/" target="_blank" rel="noopener">https://huaban.com/discovery/</a></p>
<h2 id="Can-I-use"><a href="#Can-I-use" class="headerlink" title="Can I use"></a>Can I use</h2><p>HTML5 CSS3 新特性各浏览器内核兼容性查询工具<br><a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a></p>
<h2 id="压缩图"><a href="#压缩图" class="headerlink" title="压缩图"></a>压缩图</h2><p>在线修改图片大小尺寸的工具<br><a href="https://www.yasuotu.com/size" target="_blank" rel="noopener">https://www.yasuotu.com/size</a></p>
<h2 id="codeSandbox"><a href="#codeSandbox" class="headerlink" title="codeSandbox"></a>codeSandbox</h2><p>开源的web在线 IDE 工具，支持在线代码编辑，webpack打包，实时预览，发布。<br><a href="https://codesandbox.io/" target="_blank" rel="noopener">https://codesandbox.io/</a><br><a href="https://hackernoon.com/@compuives" target="_blank" rel="noopener">作者博客</a><br><a href="https://github.com/codesandbox" target="_blank" rel="noopener">开源项目</a><br><a href="https://vince.xin/2019/11/02/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E5%9C%A8%E7%BA%BF%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-IDE/" target="_blank" rel="noopener">实现原理介绍</a></p>
<h2 id="Live2D-for-web"><a href="#Live2D-for-web" class="headerlink" title="Live2D for web"></a>Live2D for web</h2><p>hexo插件：Live2D 可视化技术<br><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d</a><br><a href="https://www.live2d.com/" target="_blank" rel="noopener">live2D</a><br><a href="https://l2dwidget.js.org/docs/" target="_blank" rel="noopener">live2D-widget-js</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/05/live2d-web-webgl-js/" target="_blank" rel="noopener">live2d与web前端技术结合</a></p>
<h2 id="k8s了解一下"><a href="#k8s了解一下" class="headerlink" title="k8s了解一下"></a>k8s了解一下</h2><p><code>Kubernetes</code>是一个开源的，用于管理云平台中多个主机上的容器化的应用，<code>Kubernetes</code>的目标是让部署容器化的应用简单并且高效（powerful）,<code>Kubernetes</code>提供了应用部署，规划，更新，维护的一种机制。<br><a href="https://www.kubernetes.org.cn/k8s" target="_blank" rel="noopener">文档</a></p>
<h2 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h2><p>一个帮助开发者成长的社区，很多文章质量都挺高的。<br><a href="https://juejin.im/" target="_blank" rel="noopener">https://juejin.im/</a></p>
<h2 id="Search-Hacker-News"><a href="#Search-Hacker-News" class="headerlink" title="Search Hacker News"></a>Search Hacker News</h2><p><a href="https://hn.algolia.com/" target="_blank" rel="noopener">https://hn.algolia.com/</a></p>
<h2 id="InfoQ"><a href="#InfoQ" class="headerlink" title="InfoQ"></a>InfoQ</h2><p>是一个实践驱动的社区资讯站点，致力于促进软件开发领域知识与创新的传播。提供架构，云计算，AI，前端，大数据，Java，软件开发，编程等技术资讯及技术会议，搭建连接中国技术高端社区与国际主流技术社区的桥梁。<br><a href="https://www.infoq.cn/" target="_blank" rel="noopener">https://www.infoq.cn/</a></p>
<h1 id="Deepl-翻译"><a href="#Deepl-翻译" class="headerlink" title="Deepl 翻译"></a>Deepl 翻译</h1><p>DeepL，一款优于谷歌（Google）、微软（Microsoft）和脸书（Facebook）的在线翻译器。<br><a href="https://www.deepl.com/translator" target="_blank" rel="noopener">https://www.deepl.com/translator</a></p>
<h1 id="BPMNJS"><a href="#BPMNJS" class="headerlink" title="BPMNJS"></a>BPMNJS</h1><p>BPMN2.0的web建模器，流程图可以在前端完成，在前端应用中展示。<br><a href="https://bpmn.io/toolkit/bomn-js/" target="_blank" rel="noopener">https://bpmn.io/toolkit/bomn-js/</a></p>
<h1 id="TBS腾讯浏览服务"><a href="#TBS腾讯浏览服务" class="headerlink" title="TBS腾讯浏览服务"></a>TBS腾讯浏览服务</h1><p>依托X5内核强大的能力，致力于提供优化移动端浏览器体验的整套解决方案。可用于安卓APP中统一的webview，提高兼容性。<br><a href="https://x5.tencent.com/tbs/index.html" target="_blank" rel="noopener">https://x5.tencent.com/tbs/index.html</a></p>
<h1 id="MD文档在线编辑导出PDF等"><a href="#MD文档在线编辑导出PDF等" class="headerlink" title="MD文档在线编辑导出PDF等"></a>MD文档在线编辑导出PDF等</h1><p><a href="https://resumd.t9t.io/" target="_blank" rel="noopener">https://resumd.t9t.io/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2016/08/21/promiss%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/21/promiss%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/" itemprop="url">promiss原理及应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-21T17:13:30+08:00">
                2016-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>哈哈 纯属搬运，主要别人写的实在太好了：</p>
<p><a href="https://tech.meituan.com/2014/06/05/promise-insight.html" target="_blank" rel="noopener">Promise剖析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2015/03/31/JS%E4%B9%8B%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/31/JS%E4%B9%8B%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/" itemprop="url">JS之数组基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-31T17:24:48+08:00">
                2015-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><hr>
<ul>
<li><strong>数组</strong>是一种使用 整数 作为键(<code>integer-key-ed</code>) 属性 和长度 (<code>lengt</code>h) 属性之间关联的特殊对象。</li>
<li><code>Array</code> 对象是 <code>JS</code> 专门用于构造数组的全局对象。</li>
<li>可以通过 <strong>字面量表达式</strong> 和 <strong><code>Array</code> 构造函数</strong> 定义数组。</li>
</ul>
<pre><code class="language-js">
// 字面量表达式
var arr1 = []; // 空数组
var arr2 = [1, &quot;2&quot;, false];
var arr3 = [3];  // 长度为1，元素只有3的数组

// Array构造函数
var arr4 = new Array(); // 空数组
var arr5 = new Array(1,&quot;2&quot;, false);
var arr6 = new Array(3);  // 初始化为一个长度为 3 的 空数组 [empty × 3]</code></pre>
<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><hr>
<ul>
<li><p><code>fill()</code>: 数组填充</p>
<ul>
<li>参数 <code>(value[, start[, end]])</code>。将数组 <code>start</code>(默认开始) 到 <code>end</code>(默认结束) 索引值替换或填充为 <code>value</code>。</li>
</ul>
<pre><code class="language-js">  // 创建一个10*10的二维数组，所有值填充为0
  let arr = new Array(10).fill(null).map(() =&gt; new Array(10).fill(0));</code></pre>
</li>
<li><p><code>join()</code>: 将数组的元素组起一个字符串。</p>
<ul>
<li>参数 （<code>separator</code>），以 <code>separator</code> 为分隔符，省略的话则用默认用 <code>,</code> 为分隔符。<pre><code class="language-js">var arr = [1,2,3];
console.log(arr.join()); // 1,2,3
console.log(arr.join(&quot;-&quot;)); // 1-2-3
console.log(arr); // [1, 2, 3]（原数组不变）</code></pre>
</li>
</ul>
</li>
<li><p><code>push()</code>和 <code>pop()</code>: </p>
<ul>
<li><code>push()</code> 将在数组 尾部 添加一个或多个元素，并返回修改后数组的长度。</li>
<li><code>pop()</code> 将移除数组尾部的第一个元素，并返回这个元素。<pre><code class="language-js">var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
var count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);
console.log(count); // 5
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]
var item = arr.pop();
console.log(item); // Sean
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]</code></pre>
</li>
</ul>
</li>
<li><p><code>shift()</code> 和 <code>unshift()</code> : </p>
<ul>
<li><code>shift()</code> 将删除数组头部的第一个元素，并返回删除元素的值。如果数组为空则返回 <code>undefined</code>。</li>
<li><code>unshift()</code> 将一个或多个元素添加到原数组开头，并返回修改后数组的长度。</li>
</ul>
<pre><code class="language-js">  var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
  var count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);
  console.log(count); // 5
  console.log(arr); //[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]
  var item = arr.shift();
  console.log(item); // Jack
  console.log(arr); // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]</code></pre>
</li>
<li><p><code>sort()</code> : 数组项排序，默认升序排列。</p>
<ul>
<li><p>无参：将每个数组项 toString() 以后比较。即使数组中的每一项都是数值，sort()方法比较的也是字符串。</p>
</li>
<li><p>有参：支持接收一个比较函数作为参数。比较函数有两个参数<code>(a, b)</code>，通过返回 <code>-1</code>（<code>a</code>排前面）, <code>0</code>（顺序不变）, <code>1</code>（<code>b</code>排前面）来决定顺序。</p>
<pre><code class="language-js">var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];
console.log(arr1.sort()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
arr2 = [13, 24, 51, 3];
console.log(arr2.sort()); // [13, 24, 3, 51]

arr2 = [13, 24, 51, 3];
console.log(arr2.sort((a, b) =&gt; a - b)); // [3, 13, 24, 51]</code></pre>
</li>
</ul>
</li>
<li><p><code>reverse()</code>: 将原数组项的顺序反转并返回，意味着原数组也会被改变。</p>
<pre><code class="language-js">  var arr = [13, 24, 51, 3];
  console.log(arr.reverse()); //[3, 51, 24, 13]
  console.log(arr); //[3, 51, 24, 13](原数组改变)</code></pre>
</li>
<li><p><code>concat()</code>: 用于连接两个或多个数组。不会改变现有的数组，返回一个新的数组。</p>
<pre><code class="language-js">  var arr = [1,3,5,7];
  var arrCopy = arr.concat(9,[11,13]);
  console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
  console.log(arr); // [1, 3, 5, 7](原数组未被修改)</code></pre>
</li>
<li><p><code>slice()</code>: 将原数组的 <code>[begin, end)</code>范围元素生成一个新的数组返回。可以接受一或两个参数，即要截取的 起始索引 和 结束索引。</p>
<ul>
<li>负参：参数为负数，则表示 从后往前 的位置索引，索引相当于是 <code>length + begin/end</code>( <code>length</code> 是数组长度)。</li>
<li>无参：相当于生成原数组的浅拷贝。</li>
<li>不会改变原数组，而是返回一个新的数组。<pre><code class="language-js">var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
console.log(arrCopy); //[3, 5, 7, 9, 11]
console.log(arrCopy2); //[3, 5, 7]
console.log(arrCopy3); //[3, 5, 7]
console.log(arrCopy4); //[5, 7, 9]</code></pre>
</li>
</ul>
</li>
<li><p><code>splice()</code>: 可以实现数组元素的 删除、插入和替换。</p>
<ul>
<li>删除：双参数 <code>(index, n)</code>, 将从<code>index</code>索引 位置开始删除 <code>n</code>个 元素。</li>
<li>插入：3个及以上参数<code>(index, n, ...data)</code>; 其中<code>n === 0</code>,相当于在<code>index</code>索引位置插入<code>...data</code>。</li>
<li>替换：同上，但是 <code>n !== 0</code>。就相当于把<code>index</code>索引开始的<code>n</code>个元素替换为<code>...data</code>。<pre><code class="language-js">var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr); //[5, 7, 9, 11]
console.log(arrRemoved); //[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr); // [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2); // []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3); //[7]</code></pre>
</li>
</ul>
</li>
<li><p><code>indexOf()</code> 和 <code>lastIndexOf()</code>: </p>
<ul>
<li><code>indexOf()</code>: 查找数组中某元素(第一个参数)首次出现的索引值，没有则返回 <code>-1</code>。</li>
<li><code>lastIndexOf()</code>: 查找数组中某元素(第一个参数)最后出现的索引值，没有则返回 <code>-1</code>。</li>
<li>第二个参数都表示开始查找的索引，默认是 <code>0</code>，从第一个开始。<pre><code class="language-js">var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); //2
console.log(arr.lastIndexOf(5)); //5
console.log(arr.indexOf(5,2)); //2
console.log(arr.lastIndexOf(5,4)); //2
console.log(arr.indexOf(&quot;5&quot;)); //-1</code></pre>
</li>
</ul>
</li>
<li><p><code>forEach()</code>: 对数组进行遍历循环。</p>
<ul>
<li>对数组中的每一项运行处理函数。处理函数有两个参数，分别是 当前数组项 和 索引值。</li>
<li>这个方法没有返回值。<pre><code class="language-js">var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
console.log(x + &#39;|&#39; + index + &#39;|&#39; + (a === arr));
});
// 输出为：
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true</code></pre>
</li>
</ul>
</li>
<li><p><code>map()</code>: 对数组中的每一项运行给定函数，然后将每次函数调用的结果组成新的数组返回。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.map(function(item){
  return item*item;
  });
  console.log(arr2); //[1, 4, 9, 16, 25]</code></pre>
</li>
<li><p><code>filter()</code>: “过滤”功能，将数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var arr2 = arr.filter(function(x, index) {
  return index % 3 === 0 || x &gt;= 8;
  }); 
  console.log(arr2); //[1, 4, 7, 8, 9, 10]</code></pre>
</li>
<li><p><code>every()</code>: 将数组中的每一项运行给定函数，只有所有项都满足条件，才会返回true。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.every(function(x) {
  return x &lt; 10;
  }); 
  console.log(arr2); //true
  var arr3 = arr.every(function(x) {
  return x &lt; 3;
  }); 
  console.log(arr3); // false</code></pre>
</li>
<li><p><code>some()</code>: 将数组中的每一项运行给定函数，只要有一项满足条件，就会返回true。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.some(function(x) {
  return x &lt; 3;
  }); 
  console.log(arr2); //true
  var arr3 = arr.some(function(x) {
  return x &lt; 1;
  }); 
  console.log(arr3); // false</code></pre>
</li>
<li><p><code>reduce()</code> 和 <code>reduceRight()</code>: 用于数组项的迭代</p>
<ul>
<li><code>reduce()</code>方法从数组的第一项开始，逐个遍历到最后。而 <code>reduceRight()</code> 则从数组的最后一项开始，向前遍历到第一项。</li>
<li>两个参数：一个在每一项上调用的函数和作为归并基础的初始值（可选）。</li>
<li>调用函数接收 4 个参数：前一个值 ( 初始值 或者 前面迭代返回的结果值 )、当前值、项的索引 和 数组对象。<pre><code class="language-js">var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
return prev + cur;
},10);
console.log(sum); //25</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h1><hr>
<ul>
<li><p>类数组定义</p>
<ul>
<li>拥有 <code>length</code> 属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）的一个<strong>对象</strong>。</li>
<li><code>typeof</code> 是 <code>object</code>，不具有数组所具有的方法。</li>
<li><code>JS</code> 中常见的 类数组 有 <code>arguments</code> 对象和 <code>DOM</code> 方法的返回结果，比如 <code>document.getElementsByTagName()</code>。</li>
</ul>
</li>
<li><p>类数组判断</p>
<pre><code class="language-js">function isLikeArray(o) {
  if (typeof o === &#39;object&#39; &amp;&amp; isFinite(o.length) &amp;&amp;  o.length &gt;= 0 &amp;&amp; o.length &lt; 4294967296){
      // 4294967296: 2^32
      return true
  } else {
      return false
  }
}</code></pre>
<blockquote>
<p>全局 <code>isFinite()</code> 函数用来判断被传入的参数值是否为一个有限数值（<code>finite number</code>）。在必要情况下，参数会首先转为一个数值。</p>
</blockquote>
</li>
<li><p>类数组转换为数组</p>
<ul>
<li>方法1: <code>args = Array.prototype.slice.call(arguments);</code>, 借助数组的<code>slice()</code> 方法。</li>
<li>方法2: <code>Array.from(arguments)</code>,  <code>ES6</code>新增方法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>数组转换为数组后可以直接调用数组具有的方法。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://www.cnblogs.com/obel/p/7016414.html" target="_blank" rel="noopener">JS数组方法大全</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2007/02/28/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2007/02/28/hello-world/" itemprop="url">Hello Hexo</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2007-02-28T15:42:37+08:00">
                2007-02-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="language-bash">$ hexo new &quot;My New Post&quot;</code></pre>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="language-bash">$ hexo server</code></pre>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="language-bash">$ hexo generate</code></pre>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="language-bash">$ hexo deploy</code></pre>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sgj.jpeg"
                alt="祁连" />
            
              <p class="site-author-name" itemprop="name">祁连</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                大牛👇
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://overreacted.io/zh-hans/" title="Dan Abramov" target="_blank">Dan Abramov</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qianduan.group/" title="寸志" target="_blank">寸志</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.robinwieruch.de/blog" title="Robin Wieruch" target="_blank">Robin Wieruch</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">祁连</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<script src="/js/prism/prism.js" async></script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
