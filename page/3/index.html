<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Live and learn">
<meta property="og:url" content="http://www.mala520.life/page/3/index.html">
<meta property="og:site_name" content="Live and learn">
<meta property="article:author" content="祁连">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mala520.life/page/3/"/>





<link rel="stylesheet" href="/js/prism/prism.css">

  <title>Live and learn</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Live and learn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/01/19/micro-service/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/19/micro-service/" itemprop="url">微前端入门Micro-frontends</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-19T16:59:37+08:00">
                2020-01-19
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index">
                    <span itemprop="name">架构</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="微前端资料"><a href="#微前端资料" class="headerlink" title="微前端资料"></a>微前端资料</h2><p>我认为比较好的<strong>微前端</strong>思想技术体系文献资料:<br>参考资料：<a href="https://github.com/xitu/gold-miner/blob/master/TODO1/micro-frontends-1.md" target="_blank" rel="noopener">https://github.com/xitu/gold-miner/blob/master/TODO1/micro-frontends-1.md</a><br>原文资料：<a href="https://martinfowler.com/articles/micro-frontends.html" target="_blank" rel="noopener">https://martinfowler.com/articles/micro-frontends.html</a><br>文章大量引用了上述文献资料的第一部分，对许多翻译生硬的地方加以润色，难理解的点增加注释，并穿插加入一些个人观点。</p>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>众所周知，前端的世界瞬息万变。新的语言，框架库，思想层出不穷，让人应接不暇。其中许多了解一下即可，但是对去现在比较火热的“微前端（MircroFrontends）”,还是值得去了解和研究一下的。大家对于前端的不断探索研究甚至创造，我觉得无非两个目的。一是尝试拓展前端的边界（创造更多可能）；二是前端已有领域的不断优化（效率，维护性，质量，管理成本）。很明显，微前端是后者。那接下来，我们了解一下什么是微前端，探讨一下它如何解决和优化前端领域一些问题的。</p>
<h2 id="什么是微前端"><a href="#什么是微前端" class="headerlink" title="什么是微前端"></a>什么是微前端</h2><p>微前端首先是一种（管理）思想。将前端整体<strong>分解</strong>为小而简单模块的一种模式。这些块可以独立开发、测试和部署。<br>与此同时，我们仍然需要把模块<strong>聚合</strong>为一个产品出现在客户面前。我们将这种技术也称为微前端。<br>所以微前端是一种管理思想和集成技术结合的产物，我们将其定义为：</p>
<blockquote>
<p>一种将多个可独立交付的小型前端应用聚合为一个整体的架构风格</p>
</blockquote>
<p>简而言之，微前端都是将巨大的东西分成更小、更易于管理的小部分，然后明确它们之间的依赖关系。我们的技术选择、代码库、团队以及发布流程都应该能够彼此独立地运行和开发，不需要过多的协调。我认为好的微前端要做好两件事情（微前端也分两步）：</p>
<ul>
<li>分解（业务层面）：保证业务的合理拆分，并理清它们直接的依赖交互关系。</li>
<li>聚合（技术层面）：架构层面，要在技术上做到很好的聚合，保证彼此独立，不相互污染，又能合理通信。</li>
</ul>
<p>使用场景主要有：</p>
<ul>
<li>拆分巨型应用，使应用变得更加可维护。</li>
<li>兼容历史应用，实现增量开发。</li>
</ul>
<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>体积小、易拼合且易于维护的代码库</li>
<li>更具扩展性的互相解耦且独立的团队</li>
<li>和以前相比能采用增量的方式，更易于对前端的某些部分进行升级、更新甚至重写</li>
</ul>
<h3 id="增量升级，逐步翻新。"><a href="#增量升级，逐步翻新。" class="headerlink" title="增量升级，逐步翻新。"></a>增量升级，逐步翻新。</h3><p>  很多公司都普遍存在一个历史问题：过时的技术栈，赶工完成的代码质量，五花八门的代码风格。随着员工的更迭，新功能的不断堆积，后人维<br>护起来，看不懂，改不动，只想重写的情况日益严重。这个时候，你才明白，长江后浪推前浪，前浪原来是被后浪咒死在沙滩上的。如果这个时候，你发现这居然还是一个巨石应用……后浪也想在沙滩上自杀了。<br>  当然了，喜欢折腾的前端没那么脆弱，当然还是要解决这个问题。我相信，这个时候就已经诞生了微前端，或者说应用了微前端的管理思想-细<br>分：随着新的功能，将业务逐步在多个新应用中重构翻新。当然，也有在原应用中或者在一个新应用中想办法逐步翻新，这基本上是重蹈覆辙。</p>
<h3 id="简单、解耦的代码库"><a href="#简单、解耦的代码库" class="headerlink" title="简单、解耦的代码库"></a>简单、解耦的代码库</h3><p>每个单独的微前端项目的源代码库，会远远小于一个单体前端项目的源代码库。这些小的代码库将会更易于开发。更值得一提的是，我们避免了不相关联的组件之间无意造成的不适当的耦合。通过增强应用程序的<a href="https://martinfowler.com/bliki/BoundedContext.html" target="_blank" rel="noopener">边界</a>来减少这种意外耦合的情况的出现（领域驱动设计(DDD)中抽象的限界上下文（BoundedContext）概念，不懂也不用太纠结）。</p>
<p>当然了，一个独立的、高级的架构方式（例如微前端），不是用来取代规范整洁的优秀老代码的。我们不是想要逃避代码优化和代码质量提升。相反，我们降低做出错误决策的可能，增加正确决策的几率，从而使我们Falling Into The Pit of Success<a href="https://blog.codinghorror.com/falling-into-the-pit-of-success/" target="_blank" rel="noopener">进入成功之坑</a>（该思想大致的意思是说设计者要通过精心设计的系统或者API，让用户做正确的事变的容易，而不过于为容易犯错而苦恼。用户犯错，那就是设计者的错）。微前端会促使您明确并慎重地了解数据和事件如何在应用程序的不同部分之间传递（跨应用通信），这本是我们（微前端架构设计师）早就应该开始做的事情！</p>
<h3 id="独立部署"><a href="#独立部署" class="headerlink" title="独立部署"></a>独立部署</h3><p>与微服务一样，微前端的独立可部署性是关键。它减少了部署的范围，从而降低了相关风险。无论您的前端代码在何处托管，每个微前端都应该有自己的连续交付通道，该通道可以构建、测试并将其一直部署到生产环境中。我们应当能够在不考虑其他代码库或者是通道的情况下来部署每个微服务。<br>做到即使原来的单体项目是固定的按照季度手动发布版本，或者其他团队提交了未完成的或者是有问题的代码到他们的主分支上，也不会对当前项目产生影响。如果一个微前端项目已准备好投入生产，它应该具备这种能力，而决定权就在构建并且维护它的团队手中。</p>
<p><img src="https://martinfowler.com/articles/micro-frontends/deployment.png" alt="图示：三个彼此独立的应用从源代码控制开始，经过构建、测试直至部署到生产环境"></p>
<p>图 2 : 每个微前端都独立的部署到生产环境上</p>
<h3 id="自主的团队"><a href="#自主的团队" class="headerlink" title="自主的团队"></a>自主的团队</h3><p>将我们的代码库和发布周期分离的更高阶的好处，是使我们拥有了完全独立的团队，可以参与到自己产品的构思、生产及后续的过程。每个团队都拥有为客户提供价值所需的全部资源，这就使得他们可以快速且有效地行动。为了达到这个目的，我们的团队需要<strong>根据业务功能纵向地划分，而不是根据技术种类</strong>。一种简单的方法是根据最终用户将看到的内容来分割产品，因此每个微前端都封装了应用程序的单个页面，并由一个团队全权负责。与根据技术种类或“横向”关注点（如样式、表单或验证）来组成团队相比，这会使得团队工作更有凝聚力。</p>
<p><img src="https://martinfowler.com/articles/micro-frontends/horizontal.png" alt="图示：根据三个应用构成三个团队，提醒大家不要根据“样式”分队"></p>
<p>图 3：每个应用都由一个团队负责</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><h3 id="负载体积"><a href="#负载体积" class="headerlink" title="负载体积"></a>负载体积</h3><p>独立构建，会造成公共依赖的重复，增加了用户所需下载依赖的体积。<br>一种解决方案是将我们编译后代码的常见依赖外置(如下代码)。一旦我们沿着这条路走下去，我们将重新引入一些微前端之间构建过程的耦合。现在它们之间有着一个隐含的合约：“我们都必须使用这些依赖的明确版本”。如果其中一个依赖产生重大改动，我们可能最终需要一个大的协调升级工作以及一次性的同步发版。这是我们使用微前端最初想要避免的一切。</p>
<p>但并不全是坏消息。首先，即便我们对于重复的依赖不采取任何措施，每个单独页面仍可能比我们构建整个前端更快地加载。原因是通过独立编译每个页面，我们有效地以我们自己的形式实现了代码分割。在传统的前端中，应用中的任何页面加载完成时，我们通常会一次性下载所有页面的源码和依赖。通过独立构建，任何单独的页面加载将只会下载那个页面的源码和依赖。这可能导致更快的首页加载，但随后的导航速度会变慢，因为用户必须在每个页面上重新下载相同的依赖。如果我们严格地不用不必要的依赖使我们的微前端膨胀，或者我们知道用户在应用中通常访问的一两个页面，即便有重复依赖，我们也很可能在性能方面达到净增益。</p>
<p>在前一段有很多“可能”和“也许”，表明了每个应用通常都有它们自己独特的性能特征。如果你想确切地知道特定的变化会造成什么性能影响，只能靠实际测量，而且最好是在生产环境中。我们见过很多团队仅仅为了下载数兆大小的高清图像或者对一个运行非常慢的数据库进行昂贵的查询额外多写几千字节的 JavaScript 代码。因此，尽管考虑每个架构决策的性能影响很重要，但请确保你知道真正的瓶颈在哪里。</p>
<pre><code class="language-javascript">  &lt;body&gt;
    &lt;noscript&gt;
      You need to enable JavaScript to run this app.
    &lt;/noscript&gt;
    &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
    &lt;script src=&quot;%REACT_APP_CONTENT_HOST%/react.prod-16.8.6.min.js&quot;&gt;&lt;/script&gt;
    &lt;script src=&quot;%REACT_APP_CONTENT_HOST%/react-dom.prod-16.8.6.min.js&quot;&gt;&lt;/script&gt;
  &lt;/body&gt;</code></pre>
<h3 id="环境差异"><a href="#环境差异" class="headerlink" title="环境差异"></a>环境差异</h3><p>我们应该能够开发一个单一的微前端，而无需考虑其他团队正在开发的所有其它微前端。我们可能甚至应该在“独立”模式下，在空白页面上运行我们的微前端，而不是运行在将在生产环境中承载微前端的容器应用内部。这可以使开发变得更加简单，特别是当真正的容器是一个复杂的遗留代码库的时候，而通常情况下我们使用微前端来逐步从旧世界迁移到新世界。但是，在与生产环境完全不同的环境中开发存在风险。如果我们的开发时容器与生产容器的行为不同，那么我们可能会发现我们的微前端被破坏，或者在我们部署到生产环境时表现不同。特别值得关注的是可能由容器或其他微前端带来的全局样式。</p>
<p>这里的解决方案与我们不得不担心环境差异的任何其他情况没有什么不同。如果我们在一个与生产环境不同的本地环境开发，我们需要<strong>确保定期将我们的微前端集成和部署到像生产环境的环境中，并且我们应该在这些环境中进行测试（手动以及自动化）以尽早发现集成问题</strong>。这不会完全解决问题，但最终这是一个取舍：简化开发环境的生产力提升是否值得冒集成出问题的风险？答案取决于项目！</p>
<h3 id="运维复杂度"><a href="#运维复杂度" class="headerlink" title="运维复杂度"></a>运维复杂度</h3><p>最后的缺点是与微服务直接平行的缺点。作为一个更加分散的架构，微前端将不可避免地导致需要管理更多的东西 —— 更多的存储库，更多的工具，更多的构建/部署管道，更多的服务器，更多的域等等。因此，在采用这样的架构之前，你应该考虑几个问题：</p>
<ul>
<li>你是否有足够的自动化可行地提供以及管理额外所需的基础设施？</li>
<li>你的前端开发、测试和发布进程是否会扩展到许多应用中？</li>
<li>你是否对围绕工具和开发的实践变得更加分散且不易控制的决策感到满意？</li>
<li>你将如何确保你的多个独立前端代码库中的最低代码质量，一致性或代码管理？<br>我们可能会另写一篇文章讨论这些主题。我们希望提出的主要观点是，当你选择微前端时，根据定义，你选择创建许多小东西而不是一个整体。你应该考虑你是否有采用这种方法所需的技术和组织成熟度，从而不造成混乱。</li>
</ul>
<h2 id="技术点"><a href="#技术点" class="headerlink" title="技术点"></a>技术点</h2><img src="/2020/01/19/micro-service/%E5%BE%AE%E5%89%8D%E7%AB%AF.png" class="" title="微前端技术栈">

<p>主要难点在于<strong>集成方式</strong>（公共依赖）和<strong>跨应用通信</strong>。有兴趣可以研读文章开始的参考资料2-4章节。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/08/09/React-Hoc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/08/09/React-Hoc/" itemprop="url">React 高阶组件（HOC）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-08-09T11:28:34+08:00">
                2019-08-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><hr>
<p>如果一个函数 接受一个或多个函数作为参数或者返回一个函数 就可称之为 高阶函数。</p>
<pre><code class="language-jsx">// ES5 
function isSearched(searchTerm) { 
  return function(item) { 
    return item.title.toLowerCase().includes(searchTerm.toLowerCase()); 
  } 
} 

// ES6 
const isSearched = searchTerm =&gt; item =&gt; 
  item.title.toLowerCase().includes(searchTerm.toLowerCase());</code></pre>
<h1 id="React-HOC"><a href="#React-HOC" class="headerlink" title="React HOC"></a>React HOC</h1><hr>
<p>在实际项目中，组件总是趋于复杂，会包含很多逻辑。当发现在很多组件都需要处理相同逻辑的时候，就应该想办法抽象复用。在React中，具有复用功能的方式主要有：</p>
<ul>
<li>公共组件库</li>
<li>公共方法库</li>
<li>类组件：<code>HOC</code> / <code>Render Props</code></li>
<li>函数组件：<code>Hooks</code></li>
</ul>
<p>当你没法把组件中的重复逻辑抽象成公共组件或者公共方法的情况下，在类组件中，就可以考虑引入<code>HOC</code>。<a href="/2020/04/23/React-Render-Props/index.html">Render Props看这里</a>。</p>
<p>和高阶函数类似，<code>React HOC</code>就是把组件（也可增加一些可选参数）作为输入，然后输出一个新的组件，新组件内部处理一些通用逻辑，并使用输入的组件进行渲染。你可以将其视为参数化容器组件。</p>
<blockquote>
<p>我们知道，在React中函数组件本质上就是一个函数。所以高阶函数组件就是一个<code>HOC</code>。</p>
</blockquote>
<h1 id="高阶组件应用"><a href="#高阶组件应用" class="headerlink" title="高阶组件应用"></a>高阶组件应用</h1><hr>
<p>首先，我们先创建<code>HOC</code>容器：</p>
<pre><code class="language-jsx">// 无状态函数组件
function HigherOrderComponent(WrappedComponent) {
    return props =&gt; &lt;WrappedComponent {...props} /&gt;;
}
// or
// 类组件
function HigherOrderComponent(WrappedComponent) {
    return class extends React.Component {
        render() {
            return &lt;WrappedComponent {...this.props} /&gt;;
        }
    };
}
// 类组件特有的通过继承的方式使用
// 也叫 反向继承（Inheritance Inversion）
function HigherOrderComponent(WrappedComponent) {
    return class extends WrappedComponent {
        render() {
            return super.render();
        }
    };
}</code></pre>
<blockquote>
<p>通过继承输入组件形式实现的<code>HOC</code>又称为 <strong>反向继承（Inheritance Inversion）</strong></p>
</blockquote>
<p>以上<code>HOC</code>只是一个容器，和直接使用 <code>WrappedComponent</code> 组件无二。那么，我们可以在<code>HOC</code>中做点什么来达到共享复用的目的呢？主要通过以下三种方式：</p>
<ul>
<li>操作参数（props / state）</li>
<li>条件渲染</li>
<li>组件包装</li>
</ul>
<h2 id="操作参数"><a href="#操作参数" class="headerlink" title="操作参数"></a>操作参数</h2><p>我们可以通过<code>HOC</code>对一个通用组件的 <code>props</code> 做一些操作达到复用的目的，而不用去修改这个通用组件。</p>
<p>举个简单的例子，一个列表展示组件，在新需求中的某些场景只希望展示列表中 <code>status === &#39;1&#39;</code> 的数据，那我们可以封装一个<code>HOC</code>在这些场景使用，其他场景直接使用。</p>
<pre><code class="language-jsx">
function HigherOrderComponent(WrappedComponent) {
    return props =&gt; {
      let newProps =  props || []
      if (newProps.length &gt; 0){
        newProps = newProps.filter((item) =&gt; item.status === &#39;1&#39;)
      }
      return &lt;WrappedComponent {...newProps} /&gt;
    };
}</code></pre>
<p>当然，你也可以通过修改这个通用组件来适配新场景。但是一直通过修改通用组件来适配所有场景，一方面存在兼容风险，另一方面适配逻辑太多，组件会变得臃肿，很难维护。</p>
<p>在举一个常见的应用：很多页面初始化的时候，都需要通过一个接口获取一些初始化数据。我们也可以通过<code>HOC</code>封装，统一获取，然后作为扩展参数传递给页面组件。</p>
<pre><code class="language-jsx"> function HigherOrderComponent(WrappedComponent) {
    return props =&gt; {
      const fetchData = async () =&gt; {
        const result = await axios(
          &#39;https://hn.algolia.com/api/v1/search?query=redux&#39;,
        );
        return result.data;
      };
      const newProps = fetchData();
      return &lt;WrappedComponent {...props} {...newProps} /&gt;
    };
}</code></pre>
<h2 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h2><p>在实际<code>React</code>项目中，大多采用前端渲染模式。组件的渲染依赖<code>Ajax</code>请求的数据。所以，我们经常会看到（我自己也写过）如下代码：</p>
<pre><code class="language-javascript">class BadComp extends React.Component {
    state = {
      isDateReady: false,
      dataA: null,
      dataB: null,
    }
    //...
    render() {
      if (!isDateReady) return false
      const { isDateReady, hasDataA, hasDataB }= this.state
      return (
        &lt;&gt;
          { dataA &amp;&amp; &lt;A {...dataA}/&gt; }
          { dataB &amp;&amp; &lt;B {...dataB}/&gt; }
        &lt;/&gt;
      );
    }
};
</code></pre>
<p>上述代码并不是一无是处，至少是严谨的，规避了无数据或者数据异常导致页面奔溃的情况。但是上述组件有两个问题：</p>
<ul>
<li>通过 <code>isDateReady</code> 阻断页面渲染，接口返回慢的话，白屏时间会很长。</li>
<li>页面充斥着太多类似 <code>{ dataB &amp;&amp; &lt;B {...dataB}/&gt; }</code> 这种逻辑，不优雅，影响可读性。</li>
</ul>
<p>解决上述问题，我们一般是通过增加 <code>loading</code> 和 <code>占位</code> 来优化。在页面主接口返回数据之前，增加 <code>loading</code> 效果。需要数据才能渲染的组件模块可以先显示 <code>占位框</code>（<code>css</code>），取得数据以后再重新渲染。很明显，这个解决方案比较通用，最好做成可复用的。这个时候，我们就可以通过<code>HOC</code>的条件渲染来实现：</p>
<p>页面<code>loading</code>效果的高阶组件，通过 <strong>反向继承 + 条件渲染</strong> 实现：</p>
<pre><code class="language-jsx">
const withLoadingComponent = (WrappedComponent) =&gt; {
  return (props) =&gt;  {
    render() {
        if(this.state.isLoading) {
          return &lt;Loading /&gt;;
        } else {
          return super.render();
        }
    }
  };
}
</code></pre>
<p>组件占位效果的<code>HOC</code>。额外的 <code>options</code> 参数可以决定占位组件 <code>Placeholder</code> 的高度等信息。</p>
<pre><code class="language-jsx">const withPlaceholderComponent = (WrappedComponent, options) =&gt; {
  return (props) =&gt;  {
    return props ? &lt;WrappedComponent {...props}&gt; : &lt;Placeholder {...options}&gt;
  };
}</code></pre>
<h2 id="组件包装"><a href="#组件包装" class="headerlink" title="组件包装"></a>组件包装</h2><p>如果你总是和相同的元素包裹使用一个通用组件，那么你可以通过抽象一个<code>HOC</code>来复用。比如下面的<code>HOC</code>在组件外面包裹一层背景色为 <code>#fafafa</code> 的 <code>div</code> 元素：</p>
<pre><code class="language-jsx">const withOtherComponent = (WrappedComponent) =&gt; {
  return (props) =&gt;  {
    return (
      &lt;div style={{ backgroundColor: '#fafafa' }}&gt;
          &lt;WrappedComponent {...this.props} {...newProps} /&gt;
      &lt;/div&gt;
    )
  };
}</code></pre>
<p>这里只是举了一个简单的例子，实际项目中，也可以通过其他组件来包裹，或是组合使用。</p>
<h1 id="Recompose-库"><a href="#Recompose-库" class="headerlink" title="Recompose 库"></a>Recompose 库</h1><hr>
<p><code>Recompose</code> 是一个为函数式组件和高阶组件开发的 <code>React</code> 工具库。可以看作是 <code>React</code> 的 <code>Lodash</code>。</p>
<p>复杂场景下，会存在多个 <code>HOC</code> 层层嵌套的情况：</p>
<pre><code class="language-jsx">const TodoListWithConditionalRendering = withLoadingIndicator(
  withTodosNull(
    withTodosEmpty(TodoList)
  )
);</code></pre>
<p>可以使用 <code>recompose</code> 库的 <code>compost</code> 方法优化：</p>
<pre><code class="language-jsx">import { compose } from &#39;recompose&#39;;
const withTodosNull = (Component) =&gt; (props) =&gt;
  ...
const withTodosEmpty = (Component) =&gt; (props) =&gt;
  ...
const withLoadingIndicator = (Component) =&gt; ({ isLoadingTodos, ...others }) =&gt;
  ...
function TodoList({ todos }) {
  ...
}
const withConditionalRenderings = compose(
  withLoadingIndicator,
  withTodosNull,
  withTodosEmpty
);
const TodoListWithConditionalRendering = withConditionalRenderings(TodoList);
function App(props) {
  return (
    &lt;TodoListWithConditionalRendering
      todos={props.todos}
      isLoadingTodos={props.isLoadingTodos}
    /&gt;
  );
}</code></pre>
<p><code>compose</code> 方法用于组合多个高阶组件。注意， props 流向是自上而下的。</p>
<p>另外，<code>recompose</code> 库的 <code>pure</code> 高阶组件，用于控制只在需要的时候重新呈现组件，即除非 <code>props</code> 发生了更改才重新重现组件。 <code>withStateHandler</code>高阶组件，用于将组件状态和组件本身隔离开来……<a href="https://github.com/acdlite/recompose" target="_blank" rel="noopener">了解更多</a></p>
<h1 id="Hoc问题"><a href="#Hoc问题" class="headerlink" title="Hoc问题"></a>Hoc问题</h1><hr>
<h2 id="抽象地狱"><a href="#抽象地狱" class="headerlink" title="抽象地狱"></a>抽象地狱</h2><p>也叫包装地狱。过多使用<code>HOC</code>层层嵌套，会导致层级冗余，逻辑难追踪，很难维护。所以要避免Hoc滥用，充分考虑引入<code>HOC</code>的必要性，尤其<code>HOC</code>多层封装的情况。对于复杂的嵌套结构，最好增加充分的注释。</p>
<h2 id="不要在render中使用-HOC。"><a href="#不要在render中使用-HOC。" class="headerlink" title="不要在render中使用 HOC。"></a>不要在<code>render</code>中使用 <code>HOC</code>。</h2><p>每次<code>render</code>渲染都会创建新的 <code>HOC</code>。diff算法会对新旧子树进行 <code>====</code> 比较。如果不相等，子树会进行卸载，和重新挂载的操作。而每次重新渲染创建的 <code>HOC</code> 前后是 <code>!==</code> 的。</p>
<pre><code class="language-jsx">render() {
  // 每次调用 render 函数都会创建一个新的 EnhancedComponent
  // EnhancedComponent1 !== EnhancedComponent2
  const EnhancedComponent = enhance(MyComponent);
  // 这将导致子树每次渲染都会进行卸载，和重新挂载的操作！
  return &lt;EnhancedComponent /&gt;;
}</code></pre>
<h2 id="Refs-不会被传递。"><a href="#Refs-不会被传递。" class="headerlink" title="Refs 不会被传递。"></a><code>Refs</code> 不会被传递。</h2><p>虽然<code>HOC</code>的约定是将所有 <code>props</code> 传递给被包装组件，但这对于 <code>refs</code> 并不适用。那是因为 <code>ref</code> 实际上并不是一个 <code>prop</code>- 就像 key 一样，它是由 React 专门处理的。如果将 ref 添加到 HOC 的返回组件中，则 ref 引用指向容器组件，而不是被包装组件。</p>
<p>这个问题的解决方案是通过使用 <code>React.forwardRef</code>（<code>React 16.3</code> 中引入）。想要了解更多，可以阅览我的另一篇博文<a href="/2020/03/30/拥抱React-Hooks（二）-Refs/index.html">拥抱React-Hooks（二）-Refs</a></p>
<h2 id="静态方法丢失。"><a href="#静态方法丢失。" class="headerlink" title="静态方法丢失。"></a>静态方法丢失。</h2><p>因为原始组件被包裹在一个容器组件内，也就意味着新组件会没有原始组件的任何静态方法。为了解决这个问题，你可以在返回之前把这些方法拷贝到容器组件上：</p>
<pre><code class="language-jsx">function enhance(WrappedComponent) {
  class Enhance extends React.Component {/*...*/}
  // 必须准确知道应该拷贝哪些方法 :(
  Enhance.staticMethod = WrappedComponent.staticMethod;
  return Enhance;
}</code></pre>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<p><a href="https://zh-hans.reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">官网-HOC</a><br><a href="https://www.robinwieruch.de/react-higher-order-components" target="_blank" rel="noopener">React Higher-order Component</a><br><a href="https://juejin.im/post/5c72b97de51d4545c66f75d5" target="_blank" rel="noopener">React 中的高阶组件及其应用场景</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/06/13/%E5%85%B3%E4%BA%8Esuper-props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/13/%E5%85%B3%E4%BA%8Esuper-props/" itemprop="url">关于React中的super(props)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-13T17:15:38+08:00">
                2019-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>读书笔记<br><a href="https://overreacted.io/why-do-we-write-super-props/" target="_blank" rel="noopener">原文链接</a></p>
</blockquote>
<hr>
<h1 id="super"><a href="#super" class="headerlink" title="super"></a>super</h1><p>在 JavaScript 中，<code>super</code> 指的是父类（即超类）的构造函数。在下面的例子中，它指向了 <code>React.Component</code> 的实现。<code>super</code>只能用在子类的构造函数之中。</p>
<pre><code class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    super(props);
    this.state = { isOn: true };
  }
  // ...
}</code></pre>
<p>值得注意的是，在调用父类的构造函数之前，你是不能在 <code>constructor</code> 中使用 <code>this</code> 关键字的。JavaScript 不允许这个行为。这是一种<strong>成功陷阱机制</strong>。</p>
<pre><code class="language-jsx">class Checkbox extends React.Component {
  constructor(props) {
    // 🔴  还不能使用 `this`
    super(props);
    // ✅  现在可以了
    this.state = { isOn: true };
  }
  // ...
}</code></pre>
<hr>
<h1 id="为什么要传入props👇"><a href="#为什么要传入props👇" class="headerlink" title="为什么要传入props👇"></a>为什么要传入props👇</h1><p>为了让 <code>React.Component</code> 构造函数能够初始化 <code>this.props</code>，将 <code>props</code> 传入 <code>super</code> 是必须的。</p>
<p>看 <code>React</code> 源码 :</p>
<pre><code class="language-jsx">/**
 * Base class helpers for the updating state of a component.
 */
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  // If a component has string refs, we will assign a different object later.
  this.refs = emptyObject;
  // We initialize the default updater but the real one gets injected by the
  // renderer.
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};</code></pre>
<hr>
<h1 id="为什么不传props，依然能访问到-this-props👇"><a href="#为什么不传props，依然能访问到-this-props👇" class="headerlink" title="为什么不传props，依然能访问到 this.props👇"></a>为什么不传<code>props</code>，依然能访问到 <code>this.props</code>👇</h1><p>这当然不是<code>javascript</code>内置的默认逻辑，而是 <code>React</code> 内部做的手脚，在调用构造函数后也立即将 <code>props</code> 赋值到了实例上：</p>
<pre><code class="language-jsx">const instance = new YourComponent(props);
instance.props = props;</code></pre>
<hr>
<h1 id="super-能代替-super-props-？-👇"><a href="#super-能代替-super-props-？-👇" class="headerlink" title="super() 能代替 super(props) ？ 👇"></a>super() 能代替 super(props) ？ 👇</h1><p><strong>最好不要</strong>，虽然 <code>React</code> 会在构造函数执行完毕之后给 <code>this.props</code> 赋值。但在构造函数中 <code>this.props</code> 一直是 <code>undefined</code>。</p>
<pre><code class="language-jsx">// React 內部
class Component {
  constructor(props) {
    this.props = props;
    // ...
  }
}

// 你的程式碼內部
class Button extends React.Component {
  constructor(props) {
    super(); // 😬 我们忘了传入 props
    console.log(props);      // ✅ {}
    console.log(this.props); // 😬 未定义
  }
  // ...
}</code></pre>
<p>如果在构造函数中调用了其他的内部方法，方法链中用到了<code>this.props</code>，就麻烦了。这是 React 作者建议开发者一定执行 <code>super(props)</code> 的原因。 所以，我们还是乖乖的秉承规范：</p>
<pre><code class="language-jsx">class Button extends React.Component {
  constructor(props) {
    super(props); // ✅ 传入 props
    console.log(props);      // ✅ {}
    console.log(this.props); // ✅ {}
  }
  // ...
}</code></pre>
<hr>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/05/28/H5%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/28/H5%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86/" itemprop="url">H5拍照上传处理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-28T15:42:37+08:00">
                2019-05-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<p>很多公司业务中，会存在上传资料图片，以供审核的需求。那我们用<code>H5</code>如何实现，并达到好的效果呢</p>
<p>涉及技术点：</p>
<ul>
<li><code>html media capture</code></li>
<li><code>FileReader</code> || <code>ULR.createObjectURL()</code></li>
<li><code>canvas</code></li>
<li><code>EXIF</code> &amp; <code>orientation</code></li>
</ul>
<h1 id="调用相机"><a href="#调用相机" class="headerlink" title="调用相机"></a>调用相机</h1><p><a href="https://www.w3.org/TR/html-media-capture/" target="_blank" rel="noopener">html media capture</a></p>
<pre><code class="language-html">&lt;input type=&#39;file&#39; accept=&#39;image/*&#39; capture=&quot;camera&quot;/&gt;</code></pre>
<h1 id="获取图片信息"><a href="#获取图片信息" class="headerlink" title="获取图片信息"></a>获取图片信息</h1><hr>
<p>以下两种方式皆可：</p>
<ul>
<li><strong>new FileReader().readAsDataURL(file)</strong> 异步/data:base64</li>
<li><strong>ULR.createObjectURL(file)</strong> 同步/内存url</li>
</ul>
<h1 id="压缩"><a href="#压缩" class="headerlink" title="压缩"></a>压缩</h1><hr>
<ul>
<li>限制最大宽度，对宽高做处理</li>
<li>等比例压缩</li>
</ul>
<pre><code class="language-javascript">  const canvas = document.createElement(&#39;canvas&#39;);
  const ctx = canvas.getContext(&#39;2d&#39;);
  canvas.width = Math.min(image.naturalWidth, option.maxWidth)
  // 高度通过宽度压缩比处理，保证等比例压缩
  const ratio = canvas.width / image.naturalWidth
  canvas.height = image.naturalHeight * ratio
  ...
  // 二次压缩（比如90%）
  canvas.toDataURL(fileType, 0.9); // fileType: image/jpeg</code></pre>
<h1 id="旋转处理"><a href="#旋转处理" class="headerlink" title="旋转处理"></a>旋转处理</h1><hr>
<p>手机相机（基本上都是Iphone）拍照，你会发现有时候照片会自动旋转，有时候并不是我们期望的显示效果。<br>不过手机拍照获取的图片，有<strong>EXIF</strong>（Exchangeable image file format），会默认设置一个<strong>orientation</strong> tag（jpeg格式才有）。<strong>orientation</strong>标示了图片旋转信息。</p>
<img src="/2019/05/28/H5%E6%8B%8D%E7%85%A7%E4%B8%8A%E4%BC%A0%E5%A4%84%E7%90%86/exif.png" class="" title="orientation图示">
<p>首先，我们可以用<a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">Exifjs</a>获取orientation。<strong>Exif.js</strong>提供了js读取图像的原始数据的功能扩展（拍照方向、相机设备型号、拍摄时间、ISO感光度、GPS地理位置等数据）.</p>
<pre><code class="language-javascript">import EXIF from &#39;exif-js&#39;;
...

EXIF.getData(file, function () {
  const orientation = EXIF.getTag(this, &#39;Orientation&#39;);
  console.log(`orientation: ${orientation}`);
});</code></pre>
<p>然后，我们用canvas对图片做一些旋转处理即可( 亲测只存在1，3，6，8四种情况):</p>
<pre><code class="language-javascript">  // 判断图片方向，重置 canvas 大小，确定旋转角度，iphone 默认的是 home 键在右方的横屏拍摄方式
  switch (orientation) {
      // 1 不需要旋转
      case 1: {
          ctx.drawImage(img, 0, 0, width, height);
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          break;
      }
      // iphone 横屏拍摄，此时 home 键在左侧 旋转180度
      case 3: {
          ctx.clearRect(0, 0, width, height);
          ctx.translate(0, 0);
          ctx.rotate(Math.PI);
          ctx.drawImage(img, -width, -height, width, height);
          break;
      }
      // iphone 竖屏拍摄，此时 home 键在下方(正常拿手机的方向) 旋转90度
      case 6: {
          ctx.clearRect(0, 0, width, height);
          ctx.translate(0, 0);
          ctx.rotate(90 * Math.PI / 180);
          ctx.drawImage(img, 0, -height, width, height);
          break;
      }
      // iphone 竖屏拍摄，此时 home 键在上方 旋转270度
      case 8: {
          ctx.clearRect(0, 0, width, height);
          ctx.translate(0, 0);
          ctx.rotate(-90 * Math.PI / 180);
          ctx.drawImage(img, -width, 0, width, height);
          break;
      }
      default: {
          ctx.clearRect(0, 0, width, height);
          ctx.drawImage(img, 0, 0, width, height);
          break;
      }
  }
</code></pre>
<p>最后，我们上传处理完的图片。</p>
<hr>
<p><a href="https://juejin.im/post/5bd705abf265da0a8d36dbdc#heading-5" target="_blank" rel="noopener">参考资料</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/04/23/React-Render-Props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/23/React-Render-Props/" itemprop="url">React - Render Props</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-23T14:29:49+08:00">
                2019-04-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="可组合组件"><a href="#可组合组件" class="headerlink" title="可组合组件"></a>可组合组件</h1><p>我们先回顾一下<strong>可组合组件</strong>。在 <code>props</code> 对象中有一个常用的 <code>children</code> 属性。通过它你可以将元素从上层传递到你的组件中，这些元素对你的组件来说是未知的，但是却为组件相互组合提供了可能性。<code>children</code> 非常灵活，可以是字符串，组件，甚至他们的集合，就像写<code>html</code>一样：</p>
<pre><code class="language-jsx">const A= ({ children }) =&gt; (
  &lt;div&gt;
    &lt;p&gt; A logic&lt;/p&gt;
    { children }
  &lt;/div&gt;
)
const App = () =&gt; (
  &lt;&gt;
    &lt;p&gt; children 示例：&lt;/p&gt;
    &lt;A&gt;
      组件B：&lt;B /&gt;
      组件C：&lt;C /&gt;
    &lt;/A&gt;
  &lt;/&gt;
);</code></pre>
<p>上面的组件<code>A</code>就是一个可组合组件。</p>
<h1 id="可共享的可组合组件"><a href="#可共享的可组合组件" class="headerlink" title="可共享的可组合组件"></a>可共享的可组合组件</h1><p>上面示例中 <code>children</code> 是最基本的使用方式，只是在组合层面，还没到达共享层面。如果 <code>B</code> <code>C</code> 组件要使用 <code>A</code> 组件的属性，即 <code>A</code> 组件要共享自己的属性给<code>B C</code> 使用。通过 通过<code>callBack</code> 实现 <code>A &gt; APP &gt; B&amp;C</code> 这种传递显然太low。这里就有一个技巧：把 <code>children</code> 函数化 这样便可以通过传递实现数据共享。<br>我们来看一个实例：一个检测浏览器在线/离线状态的共享组件，很多组件都需要通过这个组件获取浏览器是否在线：</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;

// 共享组件
class BrowserIfOnline extends React.Component {
  state = {
    isOnline: window.navigator.onLine
  };
  onOffline = () =&gt; {
    this.setState({ isOnline: false });
  };
  onOnline = () =&gt; {
    this.setState({ isOnline: true });
  };
  componentDidMount() {
    // 事件监听
    window.addEventListener(&quot;offline&quot;, this.onOffline);
    window.addEventListener(&quot;online&quot;, this.onOnline);
  }
  componentWillUnmount() {
    window.removeEventListener(&quot;offline&quot;, this.onOffline);
    window.removeEventListener(&quot;online&quot;, this.onOnline);
  }

  render() {
    return (
      &lt;&gt;
        {this.state.isOnline ? (
          &lt;div&gt;网断已连接 ...&lt;/div&gt;
        ) : (
          &lt;div&gt;网络已断开 ...&lt;/div&gt;
        )}
        {this.props.children(this.state.isOnline)}
      &lt;/&gt;
    );
  }
}
// 子组件
const B = ({ isOnline }) =&gt; &lt;p&gt;组件B：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;
const C = ({ isOnline }) =&gt; &lt;p&gt;组件C：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;

// 通过 函数化的 children 使用共享组件
class A extends React.Component {
  render() {
    return (
      &lt;BrowserIfOnline&gt;
        {isOnline =&gt; (
          &lt;&gt;
            &lt;B isOnline={isOnline} /&gt;
            &lt;C isOnline={isOnline} /&gt;
          &lt;/&gt;
        )}
      &lt;/BrowserIfOnline&gt;
    );
  }
}
export default A</code></pre>
<h1 id="Render-props-技巧"><a href="#Render-props-技巧" class="headerlink" title="Render props 技巧"></a>Render props 技巧</h1><p><code>render props</code> 是 <code>React</code> 的 一个高级特性。指一种在 <code>React</code> 组件之间使用一个值为函数的 <code>prop</code> <strong>共享代码/逻辑</strong>的简单技术。是一个用于告知组件需要渲染什么内容的函数。</p>
<p>上述<strong>可共享的可组合组件</strong>的实现，使用的便是 <code>children</code> + <code>render props</code> 技巧。在官方文档中介绍的 <code>render props</code> 使用的是另一种方式：把一个函数作为<code>render</code> 属性传递，而非 <code>children</code>：</p>
<pre><code class="language-jsx">// 共享组件 
// 通过props.render 渲染其他组件，并共享数据
class BrowserIfOnline extends React.Component {

  // ......
  // 这里省略其他逻辑 同上
  // ......

  render() {
    return (
      &lt;&gt;
        {this.state.isOnline ? (
          &lt;div&gt;网断已连接 ...&lt;/div&gt;
        ) : (
          &lt;div&gt;网络已断开 ...&lt;/div&gt;
        )}
        {this.props.render(this.state.isOnline)}
      &lt;/&gt;
    );
  }
}
//通过`render props` 的 属性（render）方式使用共享组件
class A extends React.Component {
  render() {
    return (
      &lt;BrowserIfOnline
        render={isOnline =&gt; (
          &lt;&gt;
            &lt;B isOnline={isOnline} /&gt;
            &lt;C isOnline={isOnline} /&gt;
          &lt;/&gt;
        )}
      /&gt;
    );
  }
}</code></pre>
<p><code>render</code> 属性是国际惯例，你也可以自定义，但最好不要。复杂场景下，你可能需要多个 <code>render</code> 函数。这个时候必须要重命名了，但依然建议加<code>render</code>前缀，比如<code>renderOne renderTwo</code>。</p>
<h1 id="render-props-优势"><a href="#render-props-优势" class="headerlink" title="render props 优势"></a><code>render props</code> 优势</h1><p>很多时候，<code>React Hoc</code> 可替代 <code>render props</code> 来实现逻辑共享。比如上面的功能用<code>React Hoc</code> 实现如下：</p>
<pre><code class="language-jsx">import React from &quot;react&quot;;
// 把BrowserIfOnline组件封装成一个高阶组件 withBrowserIfOnline
const withBrowserIfOnline = comps =&gt;
  class BrowserIfOnline extends React.Component {
    state = {
      isOnline: window.navigator.onLine
    };
    onOffline = () =&gt; {
      this.setState({ isOnline: false });
    };
    onOnline = () =&gt; {
      this.setState({ isOnline: true });
    };
    componentDidMount() {
      // 事件监听
      window.addEventListener(&quot;offline&quot;, this.onOffline);
      window.addEventListener(&quot;online&quot;, this.onOnline);
    }
    componentWillUnmount() {
      window.removeEventListener(&quot;offline&quot;, this.onOffline);
      window.removeEventListener(&quot;online&quot;, this.onOnline);
    }

    render() {
      return (
        &lt;&gt;
          {this.state.isOnline ? (
            &lt;div&gt;网断已连接 ...&lt;/div&gt;
          ) : (
            &lt;div&gt;网络已断开 ...&lt;/div&gt;
          )}
          {comps.map((Comp) =&gt; &lt;Comp isOnline={this.state.isOnline}/&gt;)}
        &lt;/&gt;
      );
    }
  }
const B = ({ isOnline }) =&gt; &lt;p&gt;组件B：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;
const C = ({ isOnline }) =&gt; &lt;p&gt;组件C：{isOnline ? &quot;在线&quot; : &quot;离线&quot;}&lt;/p&gt;;

const D = withBrowserIfOnline([B, C]);
export default class A extends React.Component {
  render() {
    return (
      &lt;D/&gt;
    );
  }
}
</code></pre>
<p>我们使用 <code>render props</code> 的优点主要体现在它的灵活性。比如上述示例，我们是可以在组件 <code>B</code>  <code>C</code> 前后增加一些零碎的代码逻辑，而<code>React Hoc</code>就没那么便利。</p>
<pre><code class="language-jsx">class A extends React.Component {
  render() {
    return (
      &lt;BrowserIfOnline
        render={isOnline =&gt; (
          &lt;&gt;
            &lt;p&gt;组件B：&lt;/p&gt;
            &lt;B isOnline={isOnline} /&gt;
            &lt;p&gt;组件C：&lt;/p&gt;
            &lt;C isOnline={isOnline} /&gt;
            &lt;p&gt;其他信息&lt;/p&gt;
          &lt;/&gt;
        )}
      /&gt;
    );
  }
}
</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://zh-hans.reactjs.org/docs/render-props.html" target="_blank" rel="noopener">官网 - Render Props</a><br><a href="https://www.robinwieruch.de/react-render-props" target="_blank" rel="noopener">React Render Props</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/04/09/React-%E6%B5%8B%E8%AF%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/09/React-%E6%B5%8B%E8%AF%95/" itemprop="url">React 单元测试</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-09T11:27:57+08:00">
                2019-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Jest-快照测试"><a href="#Jest-快照测试" class="headerlink" title="Jest 快照测试"></a>Jest 快照测试</h1><ul>
<li>Jest 是一个在 Facebook 使用的测试框架。在 React 社区，它被用来做 React 的组件测试。</li>
<li>Jest 赋予你写快照测试的能力。</li>
</ul>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
// 写快照之前，需要额外安装一个工具库：
import renderer from &#39;react-test-renderer&#39;;
import App, { Table } from &#39;./App&#39;;

...
// “describe”块中来定义一个测试套件。可包含一系列关于特定组件的“it”块。
describe(&#39;Search&#39;, () =&gt; {
  // mock 一些测试数据 ，非常重要
  const props={ 
    list:[
      { title: &#39;1&#39;, author: &#39;1&#39;, num_comments: 1, points: 2, objectID: &#39;y&#39; },
      { title: &#39;2&#39;, author: &#39;2&#39;, num_comments: 1, points: 2, objectID: &#39;z&#39; },
    ] 
  }
  // “it”块描述了一个测试用例。
  it(&#39;renders without crashing&#39;, () =&gt; {
    const div = document.createElement(&#39;div&#39;);
    ReactDOM.render(&lt;Table { ...props } /&gt;, div);
  });
  // “test”块来实现一个快照测试
  test(&#39;has a valid snapshot&#39;, () =&gt; {
    const component = renderer.create(
      &lt;Table { ...props } /&gt;
    );
    let tree = component.toJSON();
    expect(tree).toMatchSnapshot();
  });
});
</code></pre>
<h1 id="Enzyme-单元测试"><a href="#Enzyme-单元测试" class="headerlink" title="Enzyme 单元测试"></a>Enzyme 单元测试</h1><p>Enzyme 可以用来断言、操作、遍历 React 组件。你可以用它来管理单元测试，在 React 测试中与快照测试互补。</p>
<p>安装（还需要安装一个扩展库）：</p>
<pre><code class="language-bash">npm install --save-dev enzyme react-addons-test-utils enzyme-adapter-react-16</code></pre>
<p>适配器初始化：</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import renderer from &#39;react-test-renderer&#39;;
import Enzyme from &#39;enzyme&#39;;
import Adapter from &#39;enzyme-adapter-react-16&#39;;
import App, { Search, Button, Table } from &#39;./App&#39;;
Enzyme.configure({ adapter: new Adapter() });</code></pre>
<p>写一个单元测试：使用 shallow() 方 法渲染你的Table组件，并且断言 Table 有两个子项，因为你传入了两个列表项。断言仅仅检查这个元素两个带有类名叫 table-row 的元素:</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import renderer from &#39;react-test-renderer&#39;;
import Enzyme, { shallow } from &#39;enzyme&#39;;
import Adapter from &#39;enzyme-adapter-react-16&#39;;
import App, { Search, Button, Table } from &#39;./App&#39;;
...
describe(&#39;Table&#39;, () =&gt; {
  const props = {
    list: [
      { title: &#39;1&#39;, author: &#39;1&#39;, num_comments: 1, points: 2, objectID: &#39;y&#39; },
      { title: &#39;2&#39;, author: &#39;2&#39;, num_comments: 1, points: 2, objectID: &#39;z&#39; },
    ],
  };
...
  it(&#39;shows two items in list&#39;, () =&gt; {
      const element = shallow(&lt;Table { ...props } /&gt;
    );
    expect(element.find(&#39;.table-row&#39;).length).toBe(2);
  });
});
</code></pre>
<p>Enzyme API 中总共有三种渲染机制。 浅渲染 shallow() 外，这里还有 mount() 和render() 方法。这两种方式都会初始化父组件和所有的子组件。此外 mount() 还给予你调用组件生命周期的方法。但是什时候该使用哪种渲染机制呢？这里有一些建议：</p>
<ul>
<li>不论怎样都优先尝试使用浅渲染（shallow()），不会渲染子组件。</li>
<li>如果需要测试 componentDidMount() 或 componentDidUpdate()，使用 mount()。</li>
<li>如果你想测试组件的生命周期和子组件的行为，使用 mount()。</li>
<li>如果你想测试一个组件的子组件的渲染，并且不关心生命周期方法和减少些渲染的花销的话，使用 render()。</li>
</ul>
<p><a href="http://www.ruanyifeng.com/blog/2016/02/react-testing-tutorial.html" target="_blank" rel="noopener">React 测试入门教程-阮一峰</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/03/12/%E5%89%8D%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/12/%E5%89%8D%E7%AB%AF%E5%90%8C%E6%9E%84%E6%B8%B2%E6%9F%93/" itemprop="url">前端同构渲染</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-12T13:43:14+08:00">
                2019-03-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="常见渲染方式"><a href="#常见渲染方式" class="headerlink" title="常见渲染方式"></a>常见渲染方式</h1><ul>
<li>CSR (Client Side Rendering)：SPA单页应用常用，客户端 异步获取数据渲染页面的方式。</li>
<li>SSR (Server Side Rendering)：在服务端获取数据生成html返回客户端的方式，html也可包含js文件，加载后获取数据二次渲染。</li>
<li>SSG (Static Site Generation)：静态网站生成类似于服务器端渲染，不同之处在于您在构建时而不是在请求时渲染页面。</li>
<li>CSR with Pre-rendering：预渲染原理是：一般在构建阶段的最后，在本地启动一个 Puppeteer 服务，访问配置了预渲染的路由，然后将 Puppeteer 中渲染的页面输出到 HTML 文件中打包，并建立路由对应的目录。</li>
</ul>
<p>以此， 达到预渲染的目的。</p>
<h1 id="什么是同构渲染"><a href="#什么是同构渲染" class="headerlink" title="什么是同构渲染"></a>什么是<strong>同构渲染</strong></h1><p>同构渲染是为了解决当下客户端渲染为主的组件式卡法模式下性能，白屏问题而提出的一种解决方案。强调服务端跟客户端公用一套代码。服务端负责渲染，客户端来负责交互。当然服务端渲染挂了，客户端也是可以渲染的。</p>
<h1 id="客户端渲染-还是-同构渲染"><a href="#客户端渲染-还是-同构渲染" class="headerlink" title="客户端渲染 还是 同构渲染"></a>客户端渲染 还是 同构渲染</h1><p>可阅读文章： <a href="https://github.com/camsong/blog/issues/8" target="_blank" rel="noopener">精读前后端渲染之争</a></p>
<p> 作者通过精读<a href="https://www.freecodecamp.org/news/heres-why-client-side-rendering-won-46a349fadb52/" target="_blank" rel="noopener">Here’s Why Client-side Rendering Won</a>这篇文章，并收集近10位同仁的意见，对于同构渲染进行了总结并发表了自己的看法。</p>
<p> 主要阐述了同构渲染在优化体验的同时也会带来一系列问题，并没有想象中的美好。作者认为还是应该选择客户端渲染的方案为主流，可以通过其他方式优化，或部分同构的方式来解决客户端渲染的性能问题。</p>
<h1 id="同构渲染架构如何实现？"><a href="#同构渲染架构如何实现？" class="headerlink" title="同构渲染架构如何实现？"></a>同构渲染架构如何实现？</h1><p>可阅读文章：<a href="https://juejin.im/post/5d7deef6e51d453bb13b66cd#heading-4" target="_blank" rel="noopener">一文吃透React SSR服务端渲染和同构原理</a>。</p>
<p>作者为我们详细解答了：</p>
<ul>
<li>为什么需要同构渲染？</li>
<li>实现同构渲染的核心原理是什么？</li>
<li>实现同构渲染有哪些技术难题？如何设计对应的解决方案和具体实现（ 在 React 提供的 SSR 能力的几个API的基础上）。</li>
</ul>
<p>可行性和是否成熟先不谈，作者解决各种问题的思路值得学习。</p>
<h1 id="我的看法"><a href="#我的看法" class="headerlink" title="我的看法"></a>我的看法</h1><p>同构渲染固然是一种非常好的解决问题的思路，但是需要解决的技术难题非常多。推崇同构渲染的同仁可能会说，有问题解决问题便可，比如上述文章基本上给出了各种技术问题的解决方案。我个人也相对保守，崇尚kiss原则，我觉得在形成一套成熟的同构渲染技术方案（非常困难）的情况下，不宜推广全栈同构，可以部分同构。</p>
<p>我认为的成熟的同构方案至少满足以下两点：</p>
<ul>
<li>解决同构渲染的各种技术难题，稳定且不存在很大的性能，兼容性等问题。</li>
<li>不能使得普通开发者的开发成本和维护成本大大增加。性能虽然重要，开发质量，可维护性也是相当重要的。</li>
</ul>
<blockquote>
<p>软件开发中遇到的所有问题，都可以通过增加一层抽象而得以解决。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2019/03/05/React%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/05/React%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB/" itemprop="url">React技术体系</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-05T17:29:27+08:00">
                2019-03-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul>
<li>Virtual DOM（Diff算法）</li>
<li>Jsx 语法</li>
<li>Flux Data Flow（单向数据流）</li>
<li>类组件&amp;生命周期</li>
<li>函数组件-无状态组件<a href="https://www.jackfranklin.co.uk/blog/functional-stateless-components-react/" target="_blank" rel="noopener">FSC</a></li>
<li>高阶特性 <code>Hoc</code> <code>Render Props</code> <code>Context</code> 等</li>
</ul>
<h1 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h1><p>在挂载过程中有四个生命周期方法，它们的调用顺序是这样的：</p>
<ul>
<li><code>constructor()</code>   组件初始化时被调用，用于初始化状态</li>
<li><code>componentWillMount()</code> 在 <code>render()</code> 之前被调用。可用于设置一些组件本地状态，不过还是推荐在 <code>constructor()</code> 中去初始化状态。</li>
<li><code>render()</code> 它返回作为组件输出的元素。这个方法应该是一个纯函数，因此不应该在这个方法中修改组件的状态。</li>
<li><code>componentDidMount()</code> 它仅在组件挂载后执行一次。一般用于处理<code>Ajax</code>请求等副作用。</li>
</ul>
<p>共有5个生命周期方法用于组件更新周期，调用顺序如下：</p>
<ul>
<li><code>componentWillReceiveProps(nextProps)</code> 新的属性会作为它的输入。因此你可以利用 <code>this.props</code> 来对比之后的属性和之前的属性，基于对比的结果去实现不同的行为。此外，你可以基于新的属性来设置组件的状态。</li>
<li><code>shouldComponentUpdate((nextProps, nextState)</code> 每次组件因为状态或者属性更改而更新时，它都会被调用。组件及其子组件将根据该方法返回的布尔值来决定是否重新渲染，从而避免不必要的渲染。用于性能优化。</li>
<li><code>componentWillUpdate((nextProps, nextState)</code>  - 这个方法是 <code>render()</code> 执行之前的最后一个方法。你已经拥有下一个属性和状态，它们可以在这个方法中任由你处置。你可以利用这个方法在渲染之前进行最后的准备。注意在这个生命周期方法中你不能再触发 <code>setState()</code>。如果你想基于新的属性计算状态，你必须利用<code>componentWillReceiveProps()</code>。</li>
<li><code>render()</code> 同上。</li>
<li><code>componentDidUpdate()</code>  这个方法在 <code>render()</code> 之后立即调用。你可以用它当成操作 <code>DOM</code> 或者执行更多异步请求的机会。</li>
</ul>
<p>组件卸载也有生命周期。只有一个：</p>
<ul>
<li><code>componentWillUnmount()</code>。它会在组件销毁之前被调用。你可以利用这个生命周期方法去执行任何清理任务。</li>
</ul>
<blockquote>
<p><code>componentDidCatch()</code> 。它在 <code>React 16</code> 中引入，用来捕获组件的错误。</p>
</blockquote>
<h1 id="setState-异步"><a href="#setState-异步" class="headerlink" title="setState() 异步?"></a>setState() <code>异步?</code></h1><ul>
<li><code>setState</code> 只在合成事件和钩子函数中是“异步”的，在原生事件和 <code>setTimeout</code> 中都是同步的。</li>
<li><code>setState</code>的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 <code>setState(partialState, callback)</code> 中的<code>callback</code>拿到更新后的结果。</li>
<li><code>setState</code> 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和<code>setTimeout</code> 中不会批量更新，在“异步”中如果对同一个值进行多次 <code>setState</code> ， <code>setState</code> 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 <code>setState</code> 多个不同的值，在更新时会对其进行合并批量更新。</li>
</ul>
<h1 id="React-Hooks"><a href="#React-Hooks" class="headerlink" title="React Hooks"></a>React Hooks</h1><p><code>Hook</code> 是 <code>React 16.8</code> 的新增特性。它可以让你在不编写 <code>class</code> 的情况下使用 <code>state</code> 以及其他的 <code>React</code> 特性。</p>
<ul>
<li>基础 Hook : <code>useState</code>  <code>useEffect</code> <code>useContext</code></li>
<li>其他 Hook : <code>useReducer</code> <code>useCallback</code> <code>useMemo</code> <code>useRef</code> <code>useImperativeHandle</code> <code>useLayoutEffect</code> <code>useDebugValue</code></li>
</ul>
<h1 id="React-SSR"><a href="#React-SSR" class="headerlink" title="React SSR"></a>React SSR</h1><ul>
<li>CSR 客户端渲染</li>
<li>SSR 服务端渲染</li>
<li>SPA 单页应用</li>
</ul>
<p><code>SSR</code>其实属于古老的技术了，早期的前端页面都是<code>SSR</code>渲染的，<code>node + ejs（模版引擎)，java + （velocity模版引擎），php，jsp</code>等都可以实现。但是只实现<code>SSR</code>其实没啥意义，技术上没有任何发展和进步，否则 <code>SPA</code> 技术就不会出现。<br>但是单纯的 <code>SPA</code>又不够完美，所以最好的方案就是这两种体验和技术的结合，第一次访问页面是服务端渲染，基于第一次访问后续的交互就是 <code>SPA</code> 的效果和体验，还不影响<code>SEO</code> 效果，这就有点完美了。关于<code>React SSR</code>，主要有下面几个框架：</p>
<h2 id="Nextjs"><a href="#Nextjs" class="headerlink" title="Nextjs"></a>Nextjs</h2><p><code>React</code>轻量级后端渲染框架，<strong>同构渲染</strong>利器。</p>
<h2 id="Umijs"><a href="#Umijs" class="headerlink" title="Umijs"></a>Umijs</h2><p><code>Umi</code>，中文可发音为<strong>乌米</strong>，是可扩展的企业级前端应用框架，参考 <code>next.js</code> 做的。要说有哪些地方不如<code>Umi</code>，我觉得可能是不够贴近业务，不够接地气。比如 <code>antd、dva</code> 的深度整合，比如国际化、权限、数据流、配置式路由、补丁方案、自动化 external 方面等等一线开发者才会遇到的问题。</p>
<h2 id="Bigfish-阿里内部，非开源"><a href="#Bigfish-阿里内部，非开源" class="headerlink" title="Bigfish(阿里内部，非开源)"></a>Bigfish(阿里内部，非开源)</h2><ul>
<li><code>Umi</code> 和 <code>Bigfish</code>，前者是从无线业务中长出来的，后者是从中台业务中长出来的。</li>
<li>后来统一技术栈，<code>Bigfish</code> 后来改造成 <code>umi + umi 插件集</code>的一个架构。这样一个对外开源，一个对内服务。类似的还有 <code>eggjs</code> 和 <code>chair</code>。<br>既然是阿里内部框架，这里为啥提及：<strong><code>这是一种很好的方式，开源和业务两不误</code></strong></li>
</ul>
<h2 id="Eggjs"><a href="#Eggjs" class="headerlink" title="Eggjs"></a>Eggjs</h2><p>企业级<code>Node.js</code>框架, 基于 <code>Koa</code> 开发，性能优异,高度可扩展的插件机制,内置多进程管理。<br><strong>有成熟的配合React实现SSR技术解决方案</strong></p>
<hr>
<h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><p><code>Redux</code> 是 JavaScript 状态容器，提供可预测化的状态管理。</p>


<p><a href="https://github.com/camsong/redux-in-chinese" target="_blank" rel="noopener">Redux中文文档</a></p>
<h2 id="redux-saga"><a href="#redux-saga" class="headerlink" title="redux-saga"></a>redux-saga</h2><p>异步解决方案，相似仓库还有：</p>
<ul>
<li><code>redux-thunk</code></li>
<li><code>redux-promise</code></li>
</ul>
<h2 id="dav"><a href="#dav" class="headerlink" title="dav"></a>dav</h2><p>基于 <code>redux</code> 和 <code>redux-saga</code> 的数据流方案，额外内置了 <code>react-router</code> 和 <code>fetch</code>，所以也可以理解为一个轻量级的应用框架。</p>
<hr>
<h2 id="好文"><a href="#好文" class="headerlink" title="好文"></a>好文</h2><p><a href="https://juejin.im/post/5def0816f265da33aa6aa7fe" target="_blank" rel="noopener">React SSR详解</a><br><a href="http://ykfe.net/guide/#%E5%88%9D%E8%A1%B7" target="_blank" rel="noopener">Egg + React + SSR 服务端渲染</a><br><a href="https://github.com/sorrycc/blog/issues/85" target="_blank" rel="noopener">蚂蚁金服前端框架和工程化实践</a><br><a href="https://github.com/sorrycc/blog/issues/1" target="_blank" rel="noopener">React + Redux 最佳实践</a><br><a href="https://github.com/sorrycc/blog/issues/6" target="_blank" rel="noopener">支付宝前端应用架构的发展和选择</a><br><a href="https://juejin.cn/post/6844903636749778958" target="_blank" rel="noopener">你真的理解setState吗？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/08/21/js-%E5%9F%BA%E7%A1%80%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/21/js-%E5%9F%BA%E7%A1%80%E7%A2%8E%E7%89%87/" itemprop="url">JS 基础知识碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-08-21T17:11:51+08:00">
                2018-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="8-种基本数据类型"><a href="#8-种基本数据类型" class="headerlink" title="8 种基本数据类型"></a>8 种基本数据类型</h1><hr>
<ul>
<li><code>Number</code>: 数值类型。范围是<code>±(253-1)</code>；特殊值有<code>Infinity</code>(正无穷，其实是大过最大值), <code>-Infinity</code>（负无穷，其实是小过最小值）和 <code>NaN</code>（非数值）。</li>
<li><code>String</code>: 字符串类型。</li>
<li><code>Object</code>:  对象类型。</li>
<li><code>Boolean</code>: 布尔类型 true or false</li>
<li><code>null</code>: 特殊的对象，表示空，已定义未赋值。</li>
<li><code>undefined</code>: 未定义</li>
<li><code>BigInt</code>: 表示任意长度的整数。通过在数值末尾加 <code>n</code>来定义，比如 <code>const bigInt = 1234567890123456789012345678901234567890n;</code></li>
<li><code>Symbols</code>: 生成唯一标示符。</li>
</ul>
<p><code>typeof</code> 用于检测变量的数据类型：</p>
<ul>
<li>两种使用方式: <code>typeof x</code> or <code>typeof(x)</code>。</li>
<li>返回类型的字符串, 比如 <code>&quot;string&quot;</code>。</li>
<li><code>typeof null</code> 返回 <code>&quot;object&quot;</code> <code>null</code> 被认为是一个 特殊 的对象( 空对象 )。</li>
</ul>
<blockquote>
<p><code>BigInt</code> 注意兼容性： <code>Firefox/Chrome/Edge/Safari</code>都已支持, <code>IE</code>尚不支持。</p>
</blockquote>
<h1 id="作用域（scope）之声明提前（hoisting）"><a href="#作用域（scope）之声明提前（hoisting）" class="headerlink" title="作用域（scope）之声明提前（hoisting）"></a>作用域（scope）之声明提前（hoisting）</h1><ul>
<li><code>js</code> 只有函数作用域，没有块级作用域。</li>
<li><code>js</code> 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。</li>
<li>这意味这变量在函数体内声明之前就已经可用，这个特性被非正式的称为声明提前（<code>hoisting</code>）。</li>
</ul>
<pre><code class="language-javascript">var scope = &quot;global&quot;
function f() {
  console.log(scope);  // 输出 undefined 而非 global
  var scope = &quot;local&quot;;
  console.log(scope);  // 输出 local
}</code></pre>
<p>上述函数相当于</p>
<pre><code class="language-javascript">
function f() {
  var scope;  // 自动的 声明提前
  console.log(scope);
  scope = &quot;local&quot;;
  console.log(scope);
}</code></pre>
<hr>
<h1 id="toString-和-valueOf"><a href="#toString-和-valueOf" class="headerlink" title="toString() 和 valueOf()"></a>toString() 和 valueOf()</h1><ul>
<li>所有的对象继承了两个转换方法：<code>toString()</code> 和 <code>valueOf()</code>。</li>
<li><code>toString()</code> 不同的对象类型表现不同，比如数组返回逗号拼接的字符串，日期类型返回一个可读的日期事件字符串等。</li>
<li><code>valueOf()</code> 如果对象存在原始值，就返回原始值。对象是复合值，大多数时候无法真正表示为一个原始值，就返回其本身。</li>
</ul>
<pre><code class="language-javascript">[1,2,3].toString();  // &quot;1,2,3&quot;
new Date(2010,0,1).toString();  // &quot;Fri Jan 01 2010 00:00:00 GMT+0800 (中国标准时间)&quot;
new Date(2010,0,1).valueOf();  // 1262275200000</code></pre>
<hr>
<h1 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h1><pre><code class="language-javascript">var obj = { x: 1, y: 2 }
&quot;x&quot; in obj; // =&gt; true
&quot;z&quot; in obj; // =&gt; false
&quot;toString&quot; in obj; // =&gt; true: 所有对象继承了toString()方法</code></pre>
<hr>
<h1 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h1><ul>
<li><code>A instanceof B</code> : 左操作数<code>A</code>为一个对象，右操作数<code>B</code>标示对象的类型。</li>
<li>如果<code>A</code>是<code>B</code>的实例就返回<code>true</code>，否则返回<code>false</code>。</li>
</ul>
<pre><code class="language-javascript">var d = new Date();
d instanceof Date;     // =&gt; true
d instanceof Object;   // =&gt; true : 所有对象都是 Object 的实例
d instanceof Number;   // =&gt; false
var a = [1, 2, 3];
a instanceof Array;    // =&gt; true
a instanceof Object;   // =&gt; true
function f() { };
f instanceOf Function;  // =&gt; true</code></pre>
<hr>
<h1 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h1><ul>
<li><code>对象直接量</code> ：常用方式。</li>
</ul>
<pre><code class="language-javascript">var empty = {};       // 空对象
var point = {x: 0, y: 0};
var book = {
  &quot;main title&quot;: &quot;Javascropt&quot;, // 属性名有空格必须使用字符串表示
  &quot;sub-title&quot;: &quot;The Definitive Guide&quot;,  // 属性名有连字符必须使用字符串表示
  for: &quot;all audiences&quot;
}
</code></pre>
<ul>
<li><code>new</code>：new运算符创建并初始化一个新对象，new后面跟随一个函数调用，这个函数其实是一个构造函数（constructor）。</li>
</ul>
<pre><code class="language-javascript">var empty = new Object();       // 同 {}
var point = new Object({x: 0, y: 0});
var a = new Array(); // 同 []
var b = new Date();</code></pre>
<ul>
<li><code>Object.create(proto, propertiesObject)</code>：<code>ES6</code>定义的方法，它创建一个对象.其中<code>proto</code>（必须参数）是这个对象的原型。<br><code>propertiesObject</code>是可选参数，作用就是给新对象添加新属性以及描述器。具体可参考 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperties" target="_blank" rel="noopener">Object.defineProperties() - mdn</a> 的第二个参数。新添加的属性是新对象自身具有的属性也就是通过<code>hasOwnProperty()</code> 方法可以获取到的属性，</li>
</ul>
<pre><code class="language-javascript">// 创建一个没有原型的对象
var o1 = Object.create(null);  
// 同 {} 和 new Object()
var o2 = Object.create(Object.prototype); 
o2.a = 1;
// o3._propo_ = o2 继承了o2, 也继承了o2的属性a；增加了属性 b=1;
var o3 = Object.create(o2, {b: { vaue: 1, writable: true}}); 
o3; // print {b:1} ：自🈶️属性
o3.a; // print 1: 获取对象的属性，如果自有属性没有，会继续在对象继承的原型链中（o3&gt;o2&gt;Object.prototype）查找。</code></pre>
<p>自己实现一个 <code>Object.create()</code>:</p>
<pre><code class="language-javascript">Object.myCreate = function (obj, properties)  {
  var F = function ()  {}
  F.prototype = obj
  if (properties) {
     Object.defineProperties(F, properties)
  }
  return new F()
}

Object.myCreate({}, {a: {value: 1}})     // {a: 1}</code></pre>
<hr>
<h1 id="对象动态属性"><a href="#对象动态属性" class="headerlink" title="对象动态属性"></a>对象动态属性</h1><pre><code class="language-javascript">// 设置
var selfProp = &#39;other&#39;;
var index = 1;
var book={
  &quot;main title&quot;: &quot;&quot;, // 属性名有空格必须使用字符串表示
  &quot;sub-title&quot;: &quot;&quot;,  // 属性名有连字符必须使用字符串表示
  auther: &quot;&quot;,
  [selfProp + index]: &quot;&quot;   // 动态属性通过 [] 设置。 
}
// 读取 
var auther = book.auther;
var title = book[&quot;main title&quot;]; // 属性名有空格，连字符的属性通过 [] 获取。
var other = book[selfProp + index]; // 动态属性通过 [] 获取。
</code></pre>
<hr>
<h1 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h1><ul>
<li><code>delete</code>只能删除自由属性，无法删除继承属性。</li>
<li><code>delete</code>无法删除通过<code>var</code>定义的全局变量。</li>
</ul>
<pre><code class="language-javascript">delete book.auther;              // true
delete book[&quot;main title&quot;];       // true
var obj = Object.create({x: 1}); 
delete obj.x;                    // true 但是并没有删除继承属性x。
var global1 = 1;                 // 定义全局变量，用var
this.global2 = 2;                // 定义全局变量
delete global1;                  // 无法删除
delete global2;                  // 可删除</code></pre>
<hr>
<h1 id="检测属性的几种方式"><a href="#检测属性的几种方式" class="headerlink" title="检测属性的几种方式"></a>检测属性的几种方式</h1><ul>
<li><code>in</code> 运算符</li>
<li><code>.property !== undefined</code>的形式</li>
<li><code>hasOwnProperty()</code> （ 只能检测自有属性 ）</li>
</ul>
<hr>
<h1 id="枚举对象属性"><a href="#枚举对象属性" class="headerlink" title="枚举对象属性"></a>枚举对象属性</h1><ul>
<li>for/in 运算符: 可枚举自有属性和继承属性</li>
<li>Object.keys(obj)：只能枚举自有属性</li>
</ul>
<hr>
<h1 id="Object对象常用方法"><a href="#Object对象常用方法" class="headerlink" title="Object对象常用方法"></a>Object对象常用方法</h1><ul>
<li>Object.assign();</li>
<li>Object.create();</li>
<li>Object.keys();</li>
<li>Object.values();</li>
<li>Object.defineProperty();</li>
<li>Object.entries();</li>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener">其他-MDN</a></li>
</ul>
<hr>
<h1 id="对象原型判断"><a href="#对象原型判断" class="headerlink" title="对象原型判断"></a>对象原型判断</h1><ul>
<li><code>isPrototypeOf</code>方法(推荐)</li>
<li><code>_proto_</code>属性</li>
</ul>
<pre><code class="language-javascript">var obj = {};
var newObj = Object.create(obj);
obj.isPrototypeOf(newObj);  // true
newObj._proto_ === obj; // true</code></pre>
<hr>
<h1 id="获取对象类属性（class-attribute）"><a href="#获取对象类属性（class-attribute）" class="headerlink" title="获取对象类属性（class attribute）"></a>获取对象类属性（class attribute）</h1><ul>
<li><code>typeof</code> 操作符:</li>
</ul>
<pre><code class="language-javascript">typeof null;         // =&gt; &quot;object&quot;
typeof undefined;    // =&gt; &quot;undefined&quot;
typeof true;         // =&gt; &quot;boolean&quot;
typeof 100;          // =&gt; &quot;number&quot;  NaN也是
typeof &quot;abc&quot;;        // =&gt; &quot;string&quot;
typeof function(){}; // =&gt; &quot;function&quot;
typeof 任意内置对象；  // =&gt; &quot;&quot;object</code></pre>
<ul>
<li>利用<code>Object.prototype.toString()</code> 返回 <code>[object class]</code>的特性，实现一下方法：</li>
</ul>
<pre><code class="language-javascript">function classof(0) {
  if (o === null) return &#39;null&#39;;
  if(o === undefined) return &#39;undefined&#39;;
  return Object.prototype.toString.call(o).slice(8,-1);
}

classof(1); // =&gt; &#39;Number&#39;
classof(&quot;&quot;); // =&gt; &#39;String&#39;
classof(false); // =&gt; &#39;Boolean&#39;
classof({}); // =&gt; &#39;Object&#39;
classof([]); // =&gt; &#39;Array&#39;
classof(/./); // =&gt; &#39;Regexp&#39;
classof(new Date()); // =&gt; &#39;Date&#39;
classof(Window); // =&gt; &#39;Window&#39;
function f() {};
classof(new f()); // =&gt; &#39;Object&#39;</code></pre>
<hr>
<h1 id="数组须知"><a href="#数组须知" class="headerlink" title="数组须知"></a>数组须知</h1><ul>
<li>数组索引必须为非负整数（非负整数的字符串也可以）。使用其他类型来索引数组，只能作为数组的属性。</li>
</ul>
<pre><code class="language-javascript">var a = new Array(10) // =&gt; length = 10 
a[&quot;1000&quot;] = 1; // =&gt; length = 1001  ( [0,1,...1000] )
a[-1] = -1; // =&gt; length 不变，数组多一个“-1”属性</code></pre>
<ul>
<li>数组也是对象，可以使用对象的各种方法和操作。</li>
</ul>
<pre><code class="language-javascript">//eg
var a = new Array(10)
Object.defineproperty(a,&#39;length&#39;,{writable: false}) // 让数组length不可变</code></pre>
<ul>
<li><code>delete</code> 不会改变数组的<code>length</code>，只是让某个 索引位 没有值。</li>
</ul>
<h1 id="Get-Post-请求须知"><a href="#Get-Post-请求须知" class="headerlink" title="Get/Post 请求须知"></a>Get/Post 请求须知</h1><ul>
<li>请求数据大小的限制并不是HTTP协议限制，而是浏览器的限制。</li>
<li>get适合查找数据，post适合添加/修改数据。所以在缓存策略上，get请求可以被缓存，post请求不会被缓存。</li>
</ul>
<h1 id="为什么频繁调用-element-getboundingclientrect-可能引发重绘-回流？"><a href="#为什么频繁调用-element-getboundingclientrect-可能引发重绘-回流？" class="headerlink" title="为什么频繁调用 element.getboundingclientrect() 可能引发重绘/回流？"></a>为什么频繁调用 element.getboundingclientrect() 可能引发重绘/回流？</h1><p>浏览器都会优化重绘和回流的操作。浏览器会把所有会引起回流、重绘的Dom操作放入一个队列中，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<p>另外，当我们取一些属性值时（offsetWidth、clientWidth、width）等，只为了取到正确的值，浏览器可能提前执行 flush 队列，即便是队列里的操作不影响所取的值。</p>
<h1 id="ES6-定义对象方法时，还可以省去-function-关键字。"><a href="#ES6-定义对象方法时，还可以省去-function-关键字。" class="headerlink" title="ES6 定义对象方法时，还可以省去 function 关键字。"></a>ES6 定义对象方法时，还可以省去 function 关键字。</h1><pre><code class="language-js">{
  reducers: {
    add() {}  // 等同于 add: function() {}
  },
  effects: {
    *addRemote() {}  // 等同于 addRemote: function*() {}
  },
}</code></pre>
<h1 id="Set集合-amp-Map字典"><a href="#Set集合-amp-Map字典" class="headerlink" title="Set集合 &amp; Map字典"></a>Set集合 &amp; Map字典</h1><p>Set 操作方法：</p>
<ul>
<li>add(value)：新增，相当于 array里的push。</li>
<li>delete(value)：存在即删除集合中value。</li>
<li>has(value)：判断集合中是否存在 value。</li>
<li>clear()：清空集合。</li>
</ul>
<p>Map 操作方法：</p>
<ul>
<li><p>set(key, value)：向字典中添加新元素。</p>
</li>
<li><p>get(key)：通过键查找特定的数值并返回。</p>
</li>
<li><p>has(key)：判断字典中是否存在键key。</p>
</li>
<li><p>delete(key)：通过键 key 从字典中移除对应的数据。</p>
</li>
<li><p>clear()：将这个字典中的所有元素删除。</p>
</li>
<li><p>共同点：集合、字典 可以储存不重复的值。</p>
</li>
<li><p>不同点：集合 是以 <code>[value, value]</code>的形式储存元素，字典 是以 <code>[key, value]</code> 的形式储存</p>
</li>
</ul>
<h1 id="页面加载多个JS的处理过程"><a href="#页面加载多个JS的处理过程" class="headerlink" title="页面加载多个JS的处理过程"></a>页面加载多个JS的处理过程</h1><p>step 1. 读入第一个代码块。</p>
<p>step 2. 做语法分析，有错则报语法错误（比如括号不匹配等），并跳转到step5。</p>
<p>step 3. 对var变量和function定义做“预编译处理”（永远不会报错的，因为只解析正确的声明）。</p>
<p>step 4. 执行代码段，有错则报错（比如变量未定义）。</p>
<p>step 5. 如果还有下一个代码段，则读入下一个代码段，重复step2。</p>
<p>step6. 结束。</p>
<h1 id="HTTPS加密为啥需要CA认证"><a href="#HTTPS加密为啥需要CA认证" class="headerlink" title="HTTPS加密为啥需要CA认证"></a>HTTPS加密为啥需要CA认证</h1><p>方案一：对称加密</p>
<p>加密解密使用同一个密钥。<br>存在密钥协商的问题（客户端和服务器同步密钥的时候很容易被截获）。</p>
<p>方案二：非对称加密</p>
<p>公钥/私钥互为锁和钥匙。如果 公钥 在服务器发送给客户端时被窃取。那么服务器私钥加密的内容会被坏人解密。不过，客户端发送的公钥加密过的数据，坏人没有私钥没法解密。另外，非对称加密性能是很差的，因为支持双向加解密，复杂度和密钥长度都需要很大，否则容易被暴力破解。</p>
<p>方案三：改进方案</p>
<ul>
<li>方案：客户端获取公钥后生成对称密钥，然后用公钥加密后给服务器，服务器用私钥解密得到对称密钥，后续就进行对称加密即可。</li>
<li>问题：如果坏人一开始就窃听了公钥，然后发送假的公钥（当然坏人有对应的私钥）给客户端。那么客户端发给服务器的对称密钥会被第三方解密，然后第三方用真的公钥加密给服务器。这样，后续的通信中，第三方就能获取所有的信息，毕竟得到了对称密钥。</li>
</ul>
<p>为了做到绝对的安全，CA认证（数字证书+数字签名）诞生。具体流程如下：</p>
<ol>
<li><p>服务器需要提交服务器站点的信息如域名、公司名称、公钥等给CA机构去申请和购买数字证书。CA机构就是数字证书颁发的权威机构，负责颁发证书以及验证证书的合法性。</p>
</li>
<li><p>CA机构在给服务器颁发证书的时候，除了<strong>数字证书</strong>，还会根据 <code>数字证书 + hash算法（MD5）</code>计算出<strong>摘要</strong>，CA机构自己的私钥对摘要进行加密形成<strong>数字签名</strong>一并发给服务器。</p>
</li>
<li><p>服务器在与客户端通信的时候，就会将数字证书和数字签名出示给客户端。客户端也能拿到浏览器内置的CA机构的公钥。</p>
</li>
<li><p>客户端使用CA公钥解密数字签名得到摘要，再通过 <code>数字证书 + hash算法</code>计算出摘要。如果两个摘要一致，那就证书有效，否则证书被篡改。因为CA机构的私钥坏人得不到。</p>
</li>
<li><p>客户端生成对称密钥，用从证书拿到服务器的 公钥 加密后发给服务器，服务器用 私钥 解密拿到密钥。因为客户端拿到的肯定是服务器正确的公钥，所以没有方案三存在的问题。</p>
</li>
<li><p>密钥协商完成，对称加密传输数据。</p>
</li>
</ol>
<h1 id="数组解构赋值交换元素"><a href="#数组解构赋值交换元素" class="headerlink" title="数组解构赋值交换元素"></a>数组解构赋值交换元素</h1><p>等号的左右两边模式相同，就会将右边的值赋给左边的变量。</p>
<pre><code class="language-js">[array[index1],array[index2]] = [array[index2],array[index1]];</code></pre>
<h1 id="JSBridge-原理"><a href="#JSBridge-原理" class="headerlink" title="JSBridge 原理"></a>JSBridge 原理</h1><ul>
<li>JavaScript 调用 Native 推荐使用 注入 API 的方式。通过 WebView 提供的接口，Native 向 JavaScript 的 Context（window）中注入对象或者方法，让 JavaScript 调用时，直接执行相应的 Native 代码逻辑，达到 JavaScript 调用 Native 的目的。</li>
<li>Native 调用 JavaScript 则直接执行拼接好的 JavaScript 代码即可。</li>
</ul>
<pre><code class="language-js">//js具体实现：
(function () {
    var id = 0,
        callbacks = {},
        registerFuncs = {};

    window.JSBridge = {
        // 调用 Native
        invoke: function(bridgeName, callback, data) {
            // 判断环境，获取不同的 nativeBridge
            var thisId = id ++; // 获取唯一 id
            callbacks[thisId] = callback; // 存储 Callback
            nativeBridge.postMessage({
                bridgeName: bridgeName,
                data: data || {},
                callbackId: thisId // 传到 Native 端
            });
        },
        receiveMessage: function(msg) {
            var bridgeName = msg.bridgeName,
                data = msg.data || {},
                callbackId = msg.callbackId, // Native 将 callbackId 原封不动传回
                responstId = msg.responstId;
            // 具体逻辑
            // bridgeName 和 callbackId 不会同时存在
            if (callbackId) {
                if (callbacks[callbackId]) { // 找到相应句柄
                    callbacks[callbackId](msg.data); // 执行调用
                }
            } elseif (bridgeName) {
                if (registerFuncs[bridgeName]) { // 通过 bridgeName 找到句柄
                    var ret = {},
                        flag = false;
                    registerFuncs[bridgeName].forEach(function(callback) =&gt; {
                        callback(data, function(r) {
                            flag = true;
                            ret = Object.assign(ret, r);
                        });
                    });
                    if (flag) {
                        nativeBridge.postMessage({ // 回调 Native
                            responstId: responstId,
                            ret: ret
                        });
                    }
                }
            }
        },
        register: function(bridgeName, callback) {
            if (!registerFuncs[bridgeName])  {
                registerFuncs[bridgeName] = [];
            }
            registerFuncs[bridgeName].push(callback); // 存储回调
        }
    };
})();
//作者：嫖桑 https://juejin.cn/post/6844903585268891662</code></pre>
<h1 id="语音播报"><a href="#语音播报" class="headerlink" title="语音播报"></a>语音播报</h1><pre><code class="language-js">function  voiceAnnouncements(str){
//百度
    var  url = &quot;http://tts.baidu.com/text2audio?lan=zh&amp;ie=UTF-8&amp;text=&quot; + encodeURI(str); // baidu
    var  n = new  Audio(url);
    n.src = url;
    n.play();
}
voiceAnnouncements(&#39;你好，今天吃的什么？&#39;)</code></pre>
<h1 id="静态作用域-和-闭包"><a href="#静态作用域-和-闭包" class="headerlink" title="静态作用域 和 闭包"></a>静态作用域 和 闭包</h1><ul>
<li>因为JavaScript是静态作用域的，所以它内部环境中需要的变量在编译时就确定了，运行时不会改变；</li>
<li>又因为JavaScript中，函数是一等公民，可以被调用，可以作为参数传递，可以赋值给变量，也可以作为函数返回值，所以它的运行时环境很容易变化；</li>
<li>当函数作为另一个函数（外层函数）的返回值返回时，其外层函数中的变量已经从调用栈弹出，但是我们必须让内部函数可以访问到它需要的变量，因此运行时的环境和定义时的作用域之间就产生矛盾；</li>
<li>所以我们把内部环境中需要的变量，打包交给内层函数（闭包函数），它就可以随时访问这些变量了，就形成了闭包。</li>
</ul>
<h1 id="moment-时区操作"><a href="#moment-时区操作" class="headerlink" title="moment 时区操作"></a>moment 时区操作</h1><ul>
<li>时区计算<pre><code class="language-js">import moment from &#39;moment&#39;;
moment().utcOffset(-8)  // 基于`-8`时区计算。</code></pre>
</li>
<li>设置时区<pre><code class="language-js">import moment from &#39;moment-timezone&#39;;
moment?.tz?.setDefault() //系统默认
moment?.tz?.setDefault(-8) //设置为-8</code></pre>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/07/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/25/%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" itemprop="url">跨域问题</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-25T18:36:25+08:00">
                2018-07-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域"></a>什么是跨域</h1><p>作为前端开发，尤其当下前后端分离越来越普遍，<strong>跨域</strong>成为我们工作中经常会遇到的问题。</p>
<p><strong>跨域</strong>，是指浏览器不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器对<code>JavaScript</code>实施的安全限制。所谓的同源是指 域名（包括二级域名）、协议、端口均相同。</p>
<blockquote>
<p><code>localhost</code> 调用 <code>127.0.0.1</code> 也属于跨域。</p>
</blockquote>
<p>同源策略限制了以下行为：</p>
<ul>
<li>无法读取 <code>Cookie</code>、<code>LocalStorage</code> 、<code>SessionStorage</code> 和 <code>IndexDB</code> </li>
<li>无法获取 <code>DOM</code> 和 <code>JS</code> 对象</li>
<li>无法发送 <code>Ajax</code> 请求</li>
</ul>
<p>常见跨域场景主有二种：</p>
<ul>
<li>场景一：嵌套第三方页面，并互相通信。</li>
<li>场景二：跨域<code>Ajax</code>请求。</li>
</ul>
<p>场景一主要涉及的前端技术有：</p>
<ul>
<li><code>Iframe</code>…</li>
<li><code>PostMessage</code></li>
<li>代理服务（<code>Nginx</code>）</li>
</ul>
<p>场景二主要涉及的前端技术有：</p>
<ul>
<li><code>JSONP</code></li>
<li>跨域资源共享(<code>Cors</code>)</li>
<li>代理服务（<code>Nginx</code>）</li>
</ul>
<p>接下来，我们分别探讨一下。</p>
<h1 id="Iframe"><a href="#Iframe" class="headerlink" title="Iframe"></a>Iframe</h1><p><code>Iframe</code> 的应用一直非常广泛，包括当下。用于在你的页面开辟一个子窗体嵌套展示其他页面。主要解决页面级别的复用问题。很多时候，你不仅需要展示子页面，还需要和子页面沟通。由于<code>Iframe</code>同样受同源策略限制，跨域问题就随之而来。</p>
<p>曾经我们主要通过以下2种方式解决<code>iframe</code>跨域问题：</p>
<ul>
<li>设置 <code>domain</code> 解决主域名相同，二级域名不同导致的跨域阻碍。</li>
<li>通过一个<strong>同域</strong>的<strong>中间页</strong>。</li>
</ul>
<p>当下，我们主要通过接下来要介绍的 <code>PostMessage</code>来解决跨域窗口通信问题，以上方式就不具体赘述。</p>
<h1 id="PostMessage"><a href="#PostMessage" class="headerlink" title="PostMessage"></a>PostMessage</h1><p><code>window.postMessage</code>是一个安全的、基于事件的消息<code>API</code>。它允许来自不同源的脚本采用异步方式进行有限的通信，可以实现跨文档、多窗口、跨域消息传递。<code>IE8+</code>，<code>chrome</code>，<code>firefox</code>等都已经支持。同源窗口通信也可以使用<code>PostMessage</code>，逻辑比较清晰。</p>
<p><code>PostMessage</code>实现通信的方式也很简单，分为两步:</p>
<ul>
<li>发送消息</li>
<li>接受消息</li>
</ul>
<h2 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h2><p>在需要发送消息的源窗口调用<code>targetWindow.postMessage(message,targetOrigin)</code>方法即可发送消息：</p>
<h3 id="targetWindow"><a href="#targetWindow" class="headerlink" title="targetWindow"></a><code>targetWindow</code></h3><p><code>targetWindow</code>是对目标窗体的引用。获得该引用的方法包括：</p>
<ul>
<li><code>Window.open</code> JS打开的窗体</li>
<li><code>Window.opener</code> 打开当前窗体的窗体</li>
<li><code>HTMLIFrameElement.contentWindow</code> iframe窗体</li>
<li><code>Window.parent</code> 当前窗体的父窗体</li>
<li><code>Window.frames[index]</code> 当前窗体的 iframe</li>
</ul>
<h3 id="message-参数"><a href="#message-参数" class="headerlink" title="message 参数"></a><code>message</code> 参数</h3><ul>
<li>作用：要传递的数据。</li>
<li>类型：可以是<code>JS</code>的任意基本类型或可复制的对象。然而部分浏览器只能处理字符串参数，保险起见，推荐使用<code>JSON.stringify()</code>方法对数据序列化。</li>
</ul>
<h3 id="targetOrigin-参数："><a href="#targetOrigin-参数：" class="headerlink" title="targetOrigin 参数："></a><code>targetOrigin</code> 参数：</h3><ul>
<li>类型：<code>string</code></li>
<li>作用：为了安全考虑，指明目标窗口的源，协议+域名+端口号[+path]，path会被忽略，所以可以不写。当然如果愿意也可以设置为<code>&quot;*&quot;</code>，这样可以传递给任意窗口，如果要指定和当前窗口同源的话可设置为<code>&quot;/&quot;</code>。</li>
</ul>
<blockquote>
<p>只有当目标窗口的源与postMessage函数中传入的源参数值匹配时，才能接收到消息。</p>
</blockquote>
<p>举个栗子：</p>
<pre><code class="language-js">// http://www.domainA.com
// 发送消息
var iframe = document.getElementById(&#39;iframe&#39;)
iframe.contentWindow.postMessage(&#39;hi&#39;, &#39;http://www.domainB.com&#39;)</code></pre>
<h2 id="接收消息"><a href="#接收消息" class="headerlink" title="接收消息"></a>接收消息</h2><p>目标窗体通过监听<code>window</code>的<code>message</code>事件就可以接收任何窗口传递来的消息了。</p>
<p><code>message</code>事件的<code>event</code>对象有三个属性，分别是：</p>
<ul>
<li><code>event.data</code> 表示接收到的消息；</li>
<li><code>event.origin</code> 表示<code>postMessage</code>的发送来源，包括协议，域名和端口；</li>
<li><code>event.source</code> 表示发送消息的窗口对象的引用。我们可以用这个引用来建立两个不同来源的窗口之间的双向通信。</li>
</ul>
<p>举个栗子：</p>
<pre><code class="language-js">// http://www.domainB.com
// 接受消息
function receiveMsg(event) {
  // 打印消息
  console.log(event.data)
  // 双向通信
  event.source.postMessage(&#39;hello&#39;, &#39;http://www.domainA.com&#39;)
  // 如果是父窗口 也可以这么沟通
  window.parent.postMessage(&#39;hello&#39;, &#39;http://www.domainA.com&#39;)
}
// 监听message事件
if (window.addEventListener) {
  window.addEventListener(&#39;message&#39;, receiveMsg, false);
}else {
  window.attachEvent(&#39;message&#39;, receiveMsg);
}</code></pre>
<h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><p>曾经主流的跨域<code>Ajax</code>请求的主要方式，虽然当下已经有点过时，但还是值得了解以下的。它的原理比较有趣，算是一种“投机取巧”的设计模式吧。</p>
<ul>
<li>原理：利用<code>html</code>页面允许通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的特点，动态的创建<code>script</code>标签，再去请求一个带参（包含一个<strong>回调方法</strong>作为参数）<code>url</code>来实现跨域通信。</li>
<li>缺点：只能够实现 <code>get</code> 请求。</li>
</ul>
<pre><code class="language-js">//原生实现方式
let script = document.createElement(&#39;script&#39;);

script.src = &#39;http://www.nealyang.cn/login?username=Nealyang&amp;callback=callback&#39;;

document.body.appendChild(script);

function callback(res) {
  console.log(res);
}</code></pre>
<h1 id="跨域资源共享-Cors"><a href="#跨域资源共享-Cors" class="headerlink" title="跨域资源共享(Cors)"></a>跨域资源共享(Cors)</h1><hr>
<p><code>CORS</code> 是目前主流的跨域 <code>Ajax</code> 请求解决方案。</p>
<ul>
<li>是一个<code>W3C</code>标准，全称是”跨域资源共享”（<code>Cross-origin resource sharing</code>）。</li>
<li>它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了<code>AJAX</code>只能同源使用的限制。</li>
<li>需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，<code>IE</code>浏览器不能低于<code>IE10</code>。</li>
<li>整个<code>CORS</code>通信过程，都是浏览器自动完成，不需要用户参与。</li>
<li>实现<code>CORS</code>通信的关键是服务器。只要服务器实现了<code>CORS</code>接口，就可以跨源通信。浏览器一旦发现<code>AJAX</code>请求跨源，就会自动添加一些附加的头信息，有时还会多一次附加的请求，但用户不会有感觉。 </li>
</ul>
<p>要理解<code>Cors</code> 需要搞清楚以下几个概念：</p>
<h2 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h2><p>简单请求需要满足以下几点：</p>
<ul>
<li>请求方式为 HEAD、POST 或者 GET</li>
<li>http头信息不超出以下原始字段：Accept、Accept-Language 、 Content-Language、 Last-Event-ID、 Content-Type。</li>
<li>Content-Type限于三个值：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
<h2 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h2><p>简单请求之外的其他请求。非简单请求在正式通信之前，浏览器会先发送OPTION请求，进行预检，这一次的请求称为“预检请求”。服务器成功响应预检请求后，才会发送真正的请求，并且携带真实数据。</p>
<h2 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a><code>withCredentials</code> 属性</h2><p>CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。另一方面，开发者必须在AJAX请求中打开withCredentials属性。</p>
<h1 id="代理服务（如-Nginx）"><a href="#代理服务（如-Nginx）" class="headerlink" title="代理服务（如 Nginx）"></a>代理服务（如 Nginx）</h1><ul>
<li>特殊，个别，紧急情况下，可以考虑通过代理服务（如<code>Nginx</code>）配置<code>url</code>地址映射解决跨域等问题。</li>
<li>一般由运维/后端人员负责配置。</li>
<li>不用发布代码，高效，非常有用。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="http://www.imooc.com/article/21976" target="_blank" rel="noopener">详解跨域</a><br><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html" target="_blank" rel="noopener">阮一峰-Cors详解</a><br><a href="https://ningyu1.github.io/site/post/92-cors-ajax/#solution1" target="_blank" rel="noopener">Cors常见问题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/06/28/CSS%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/28/CSS%E7%A2%8E%E7%89%87/" itemprop="url">CSS碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-28T19:36:26+08:00">
                2018-06-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="单行-多行文本溢出省略号"><a href="#单行-多行文本溢出省略号" class="headerlink" title="单行/多行文本溢出省略号"></a>单行/多行文本溢出省略号</h1><hr>
<pre><code class="language-css">/* 单行 */
.oneLine {
  overflow:hidden;
  text-overflow:ellipsis;
  white-space:nowrap
}

/* 👇 仅适用于WebKit浏览器或移动端的页面 */

.twoLine {
  /* 必须结合的属性 ，将对象作为弹性伸缩盒子模型显示 */
  display: -webkit-box; 
  /* 必须结合的属性 ，设置或检索伸缩盒对象的子元素的排列方式 */
  -webkit-box-orient: vertical; 
  /* 行数*/
  -webkit-line-clamp: 2; 
  overflow: hidden;
}</code></pre>
<h1 id="毛玻璃模糊遮罩效果"><a href="#毛玻璃模糊遮罩效果" class="headerlink" title="毛玻璃模糊遮罩效果"></a>毛玻璃模糊遮罩效果</h1><hr>
<pre><code class="language-css">/* 
filter: CSS属性将模糊或颜色偏移等图形效果应用于元素。
blur(radius):函数将高斯模糊应用于输入图像。
  radius 定义了高斯函数的标准偏差值，或者屏幕上有多少像素相互融合.
  因此，较大的值将产生更多的模糊。若没有设置值，默认为0。
  该参数可以指定为 CSS 长度，但不接受百分比值。
*/
.Mask {
  filter: blue(2px);
}</code></pre>
<h1 id="position-sticky-实现粘性布局的坑"><a href="#position-sticky-实现粘性布局的坑" class="headerlink" title="position:sticky 实现粘性布局的坑"></a>position:sticky 实现粘性布局的坑</h1><hr>
<p>设定了 <code>position:sticky</code> 的元素表现为 <code>relative</code> 还是 <code>fixed</code> 是根据元素是否达到设定了的阈值（<code>top, left,...</code>）决定的。</p>
<pre><code class="language-css">/* 下面元素当滚动到viewPort顶部以后吸顶*/
.Box {
  top:0;
  position: sticky;
}</code></pre>
<ul>
<li>问题：粘性布局突然时效。</li>
<li>原因：其他组件<code>CSS</code> 给页面顶层元素增加 <code>overflow:hidden;</code> 导致。设定为 <code>position:sticky</code> 元素的<strong>任意</strong>父节点的 <code>overflow</code> 属性必须是 <code>visible</code>，否则 <code>position:sticky</code> 不会生效。</li>
<li><a href="https://www.cnblogs.com/coco1s/p/6402723.html" target="_blank" rel="noopener">参考文档</a></li>
</ul>
<p><code>position:sticky</code> 的生效的其他限制：</p>
<ul>
<li>须指定 <code>top, right, bottom</code> 或 <code>left</code> 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</li>
<li>并且 <code>top</code> 和 <code>bottom</code> 同时设置时，<code>top</code> 生效的优先级高，<code>left</code> 和 <code>right</code> 同时设置时，<code>left</code> 的优先级高。</li>
</ul>
<h1 id="隐藏滚动元素的滚动条"><a href="#隐藏滚动元素的滚动条" class="headerlink" title="隐藏滚动元素的滚动条"></a>隐藏滚动元素的滚动条</h1><hr>
<ul>
<li>背景：显示原生滚动条太丑，自定义滚动条交互样式。</li>
<li>方法：滚动元素包装一个父元素，设置其高度为 滚动元素高度 - 滚动条高度（以X轴为例）。</li>
</ul>
<pre><code class="language-css">/* 滚动元素 */
.scrollDiv {
  height: 5rem;
  overflow-x: auto;
}
/* 滚动元素父元素*/
.scrollDivContainer {
  overflow: hidden;
  height: 4.6rem;
}</code></pre>
<blockquote>
<p>方法2: 增加一个同级 <code>Div</code> 或使用父元素的 伪类 元素；通过 绝对定位 + 同色背景 遮住滚动条。</p>
</blockquote>
<h1 id="css-新特性-contain"><a href="#css-新特性-contain" class="headerlink" title="css 新特性 contain"></a>css 新特性 contain</h1><p>CSS contain 属性允许开发者声明当前元素和它的内容尽可能的独立于 DOM 树的其他部分。这使得浏览器在重新计算布局、样式、绘图、大小或这四项的组合时，只影响到有限的 DOM 区域，而不是整个页面，可以有效改善性能。</p>
<p>使用参考： <a href="https://juejin.cn/post/6958990366888607757" target="_blank" rel="noopener">CSS新特性contain，控制页面的重绘与重排</a></p>
<h1 id="margin-inline，inset"><a href="#margin-inline，inset" class="headerlink" title="margin-inline，inset"></a>margin-inline，inset</h1><p><code>margin-inline</code> will set both <code>margin-left</code> and <code>margin-right</code> to the same value (<code>auto</code>). It has <strong>very good browser support</strong>.<br>setting <code>inset: 0px</code>, which is a shorthand that sets <code>top, left, right</code>, and <code>bottom</code> all to the same value, <code>0px</code>.</p>
<pre><code class="language-css">.element {
  max-width: fit-content;
  margin-inline: auto;
}

.element2 {
  position: fixed;
  inset: 0px;
  width: 12rem;
  height: 5rem;
  max-width: 100vw;
  max-height: 100dvh;
  margin: auto;
}</code></pre>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/filter" target="_blank" rel="noopener">Moz-filter滤镜</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/06/25/web%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/25/web%E7%A2%8E%E7%89%87/" itemprop="url">web碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-06-25T18:33:01+08:00">
                2018-06-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="本地种cookie"><a href="#本地种cookie" class="headerlink" title="本地种cookie"></a>本地种cookie</h1><p><code>document.cookie = &quot;name=value;path=path;domain=domain&quot;</code></p>
<hr>
<h1 id="微信URl自带参数"><a href="#微信URl自带参数" class="headerlink" title="微信URl自带参数"></a>微信URl自带参数</h1><p>原来微信会在原来的网页网址后面加上一个参数，朋友圈、好友分享和微信群的参数各不同：<br>朋友圈   <code>from=timeline&amp;isappinstalled=0</code><br>微信群   <code>from=groupmessage&amp;isappinstalled=0</code><br>好友分享 <code>from=singlemessage&amp;isappinstalled=0</code></p>
<hr>
<h1 id="滚动区域css背景设置"><a href="#滚动区域css背景设置" class="headerlink" title="滚动区域css背景设置"></a>滚动区域css背景设置</h1><p>滚动区域设置background-color，不可见区域没有生效。<br>办法是加float: left</p>
<hr>
<h1 id="object-key"><a href="#object-key" class="headerlink" title="object[key]"></a>object[key]</h1><p>eval(“myValue = myObject.” + myKey + “;”);<br>可以直接写成<br>myValue = myObject[myKey];</p>
<hr>
<h1 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h1><p>一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。</p>
<hr>
<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><ul>
<li>Object.assign({},obj) 只深拷贝第一层！！！！</li>
<li>JSON.parse(JSON.stringfy(obj)) 完全深拷贝 </li>
</ul>
<p>因为在序列化JavaScript对象时，所有函数和原型成员会被有意忽略。用于拷贝的对象中只能是Number, String, Boolean, Array, 扁平对象，即那些能够被 JSON 直接表示的数据结构。JSON.parse(JSON.stringfy(obj)) 缺陷：</p>
<ul>
<li>如果obj里面有时间对象，则JSON.stringify后再JSON.parse的结果，时间将只是字符串的形式，而不是对象的形式。</li>
<li>如果obj里有RegExp(正则表达式的缩写)、Error对象，则序列化的结果将只得到空对象；</li>
<li>如果obj里有函数，undefined，file数据流，则序列化的结果会把函数或 undefined丢失；</li>
<li>如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null；</li>
<li>如果对象中存在循环引用的情况也无法正确实现深拷贝；</li>
</ul>
<blockquote>
<p>参考文档<a href="https://www.cnblogs.com/makai/p/13883544.html" target="_blank" rel="noopener">JSON.stringify深拷贝的缺点</a></p>
</blockquote>
<hr>
<h1 id="获取元素位置的快速方法"><a href="#获取元素位置的快速方法" class="headerlink" title="获取元素位置的快速方法"></a>获取元素位置的快速方法</h1><p>使用getBoundingClientRect()方法。它返回一个对象，其中包含了left、right、top、bottom四个属性，分别对应了该元素的左上角和右下角相对于浏览器窗口（viewport）左上角的距离。<br>所以，网页元素的相对位置就是：</p>
<pre><code class="language-javascript">  var X= this.getBoundingClientRect().left;
  var Y =this.getBoundingClientRect().top;</code></pre>
<p>再加上滚动距离，就可以得到绝对位置</p>
<pre><code class="language-javascript">  var X= this.getBoundingClientRect().left + document.documentElement.scrollLeft;
  var Y =this.getBoundingClientRect().top + document.documentElement.scrollTop;</code></pre>
<h1 id="IOS-Universal-Links"><a href="#IOS-Universal-Links" class="headerlink" title="IOS Universal Links"></a>IOS Universal Links</h1><p>Universal Links是iOS9推出的一项功能，使你的应用可以通过传统的HTTPS链接来启动APP(如果iOS设备上已经安装了你的app，不管在微信里还是在哪里)， 或者打开网页(iOS设备上没有安装你的app)。<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/AppSearch/UniversalLinks.html" target="_blank" rel="noopener">官网</a>配置如下：<br>Adding support for universal links is easy. There are three steps you need to take:</p>
<ul>
<li><p>Create an apple-app-site-association file that contains JSON data about the URLs that your app can handle.</p>
</li>
<li><p>Upload the apple-app-site-association file to your HTTPS web server. You can place the file at the root of your server or in the .well-known subdirectory.</p>
</li>
<li><p>Prepare your app to handle universal links.</p>
</li>
</ul>
<h1 id="const-定义的数据也可变"><a href="#const-定义的数据也可变" class="headerlink" title="const 定义的数据也可变"></a>const 定义的数据也可变</h1><p>对象这种引用类型可以：</p>
<pre><code class="language-javascript">// allowed
const helloWorld = {
text: &#39;Welcome to the Road to learn React&#39;
};
helloWorld.text = &#39;Bye Bye React&#39;;</code></pre>
<h1 id="箭头函数-this"><a href="#箭头函数-this" class="headerlink" title="箭头函数 this"></a>箭头函数 this</h1><p>一个普通的函数表达式总会定义它自己的 this 对象。this指向函数被调用时候的作用域。<br>但是箭头函数表达式仍然会使用包含它的语境下的 this 对象。this指向函数被定义时候的作用域。</p>
<h1 id="ES6-自动属性名"><a href="#ES6-自动属性名" class="headerlink" title="ES6 自动属性名"></a>ES6 自动属性名</h1><pre><code class="language-javascript">// ES5
var user = {
name: &#39;Robin&#39;,
};
// ES6
const key = &#39;name&#39;;
const user = {
[key]: &#39;Robin&#39;,
};</code></pre>
<h1 id="import-export"><a href="#import-export" class="headerlink" title="import export"></a>import export</h1><p>导入全部变量：</p>
<pre><code class="language-javascript">//file1
const firstname = &#39;robin&#39;;
const lastname = &#39;wieruch&#39;;
export { firstname, lastname };
// file2
import * as person from &#39;./file1.js&#39;;</code></pre>
<p>在导入 default 输出时省略花括号。default 语句，可以被用在一些使用情况下：</p>
<ul>
<li>为了导出和导入单一功能</li>
<li>为了强调一个模块输出 API 中的主要功能</li>
<li>这样可以向后兼容 ES5只有一个导出物的功能</li>
</ul>
<pre><code class="language-javascript">//file1
const firstname = &#39;robin&#39;;
const lastname = &#39;wieruch&#39;;
const person = {
firstname,
lastname,
};
export {
firstname,
lastname,
};
export default person;
// file2
import developer, { firstname as fname, lastname } from &#39;./file1.js&#39;;</code></pre>
<h1 id="chrome-浏览器截取页面"><a href="#chrome-浏览器截取页面" class="headerlink" title="chrome 浏览器截取页面"></a>chrome 浏览器截取页面</h1><ul>
<li>首先按下 ⌘Command + ⌥Option + I（Windows 为 F12）快捷键，召唤出调试界面。</li>
<li>按下 ⌘Command + ⇧Shift + P（Windows 为 Ctrl + Shift + P），输入命令 Capture full size screenshot（只输前几个字母就能找到），敲下回车，Chrome 就会自动截取整个网页内容并保存至本地。</li>
</ul>
<h1 id="axios-fetch-区别"><a href="#axios-fetch-区别" class="headerlink" title="axios fetch 区别"></a>axios fetch 区别</h1><p>Axios是对XMLHttpRequest的封装，而Fetch是一种新的获取资源的接口方式，并不是对XMLHttpRequest的封装。<br>Fetch唯一碾压Axios的一点就是现代浏览器的原生支持，而Axios需要引入Axios库。他们都基于promise。</p>
<h1 id="为什么-Element-getBoundingClientRect-可能引发重绘-回流？"><a href="#为什么-Element-getBoundingClientRect-可能引发重绘-回流？" class="headerlink" title="为什么 Element.getBoundingClientRect() 可能引发重绘/回流？"></a>为什么 Element.getBoundingClientRect() 可能引发重绘/回流？</h1><p>浏览器都会优化重绘和回流的操作。浏览器会把所有会引起回流、重绘的操作放入1个队列中，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。另外，当我们取一些属性值时，类似offsetWidth、clientWidth、width等，只为了取到正确的值，浏览器可能提前执行 flush 队列，即便是队列里的操作不影响所取的值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/05/06/hexo-prism-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/06/hexo-prism-%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE/" itemprop="url">hexo + prism 代码高亮</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-06T18:26:28+08:00">
                2018-05-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="为什么选择-prism"><a href="#为什么选择-prism" class="headerlink" title="为什么选择 prism"></a>为什么选择 prism</h1><p>我使用 hexo + next 搭建的个人博客, <code>NexT</code> 使用 <code>Tomorrow Theme</code> 作为代码高亮, 效果实在差强人意，并存在明显的错误。尤其对<code>jsx</code>的支持很差。在网上去找其他替代方案的时候发现了<code>prism</code>。效果提升明显。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://prismjs.com/download.html" target="_blank" rel="noopener">prism官网</a><br><a href="https://www.zfl9.com/hexo-code.html" target="_blank" rel="noopener">prism配置介绍</a></p>
<blockquote>
<p>注意，项目重新<code>npm install</code>的话，高亮会丢失，你需要重新配置上述文档中的最后一步。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/04/07/React%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/04/07/React%E7%A2%8E%E7%89%87/" itemprop="url">React碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-04-07T18:13:18+08:00">
                2018-04-07
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="react-受控组件"><a href="#react-受控组件" class="headerlink" title="react 受控组件"></a>react 受控组件</h1><p>表单元素比如 <input>, <textarea> 和 <select> 会以原生 HTML 的形式保存他们自己的状态。一旦有人从外部做了一些修改，它们就会修改内部的值，在 React 中这被称为不受控组件，因为它们自己处理状态。在 React 中，你应该确保这些元素变为受控组件。<br>你应该怎么做呢？你只需要设置输入框的值属性。</p>
<h1 id="react-可组合组件"><a href="#react-可组合组件" class="headerlink" title="react 可组合组件"></a>react 可组合组件</h1><p>在 <code>props</code> 对象中还有一个小小的属性可供使用: <code>children</code> 属性。通过它你可以将元素从上层传递到你的组件中。</p>
<h1 id="React-事件须知"><a href="#React-事件须知" class="headerlink" title="React 事件须知"></a>React 事件须知</h1><ul>
<li><code>React</code>所有事件都挂载载 <code>document</code> 上</li>
<li>真实 <code>Dom</code> 触发后冒泡到 <code>document</code>后才会对<code>React</code>事件进行处理</li>
<li>所有原生事件先执行</li>
<li>然后执行<code>React</code>合成事件</li>
<li>最后执行真正在<code>document</code>上挂载的事件</li>
<li>原生事件中如果执行了<code>stopPropagation()</code>会导致其他<code>React</code> 事件失效，因为所有事件无法冒泡到<code>document</code>上</li>
</ul>
<h1 id="React-模块热替换-HMR"><a href="#React-模块热替换-HMR" class="headerlink" title="React 模块热替换(HMR)"></a>React 模块热替换(HMR)</h1><p>帮助你在浏览器中重新加载应用的工具，并且无需再让浏览器刷新页面。</p>
<pre><code class="language-jsx">import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;
import App from &#39;./App&#39;;
import &#39;./index.css&#39;;
ReactDOM.render(
&lt;App /&gt;,
document.getElementById(&#39;root&#39;)
);
// HMR
if (module.hot) {
module.hot.accept();
}</code></pre>
<h1 id="React-列表关键字-Key"><a href="#React-列表关键字-Key" class="headerlink" title="React 列表关键字 Key"></a>React 列表关键字 Key</h1><p><code>React</code> 可以在列表发生变化的时候识别其中成员的添加、更改和删除的状态。你应该确保这个关键字属性是一个稳定的标识符。不要错误地使用列表成员在数组的索引(<code>index</code>)作为关键字。列表成员的索引是完全不稳定的。</p>
<h1 id="React-PorpTypes"><a href="#React-PorpTypes" class="headerlink" title="React PorpTypes"></a>React PorpTypes</h1><p>强烈建议所有子组件声明<code>PorpTypes</code>，尤其UI/业务组件库。</p>
<ul>
<li>支持类型：<code>PropTypes.array</code>，<code>bool</code>，<code>func</code>,<code>number</code>,<code>object</code>,<code>string</code>,（<code>node</code>,<code>element</code> ：可渲染的片段（节点）。比如一段字符串，或者一个 <code>React</code> 元素）</li>
<li>必须参数：必须参数类型后加<code>.isRequired</code>，比如：<code>PropTypes.func.isRequired</code>。</li>
<li>默认值：<code>defaultProps</code>。</li>
<li>你可以将数组 <code>PropTypes</code> 的元素定义的更加明确：</li>
</ul>
<pre><code class="language-javascript">// 类型
Table.propTypes = {
  list: PropTypes.arrayOf(
  PropTypes.shape({
    objectID: PropTypes.string.isRequired,
    author: PropTypes.string,
    url: PropTypes.string,
    num_comments: PropTypes.number,
    points: PropTypes.number,
    })
  ).isRequired,
  onDismiss: PropTypes.func.isRequired,
};
// 默认值
Table.defaultProps = {
  className: &#39;&#39;,
};</code></pre>
<h1 id="props-详解"><a href="#props-详解" class="headerlink" title="props 详解"></a>props 详解</h1><p><a href="https://www.robinwieruch.de/react-pass-props-to-component" target="_blank" rel="noopener">https://www.robinwieruch.de/react-pass-props-to-component</a></p>
<h1 id="子组件状态管理"><a href="#子组件状态管理" class="headerlink" title="子组件状态管理"></a>子组件状态管理</h1><p>子组件初始化状态来自父组件(<code>props</code>)。<code>props</code>改变以后，会触发子组件会重新渲染，但不会执行<code>constructor</code>函数和<code>componentDidMount</code>生命周期。状态管理可总结为两类：</p>
<ul>
<li><p><strong><code>props</code>完全自控</strong>：在<code>constructor</code>函数读取<code>props</code>建立自己的<code>state</code>。<code>onChange</code>的时候<code>setState({})</code>重新渲染自身。同时调用父组件方法更新数据。适用多数组件，比如<code>input</code>使用这种方式比较合理。</p>
</li>
<li><p><strong><code>props</code>非完全自控</strong>： 在<code>render</code>函数直接根据<code>props</code>渲染，<code>onChange</code>的时候调用父组件方法更新父组件的<code>state</code>, 然后父组件重新渲染触发子组件渲染。比如一个<code>list</code>选择组件，<code>initList</code>，<code>checkedValue</code>，来自父组件，<code>value</code>是可控的，可以本地<code>state</code>管理，如果<code>initList</code>是不可控的，取决于父组件，如果在父组件中是可能发生改变的，就没有办法本地管理，所以只能使用这种方式。</p>
</li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/03/27/%E5%BA%95%E5%B1%82API%E5%AE%9E%E7%8E%B0Audio%E5%8A%9F%E8%83%BD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/27/%E5%BA%95%E5%B1%82API%E5%AE%9E%E7%8E%B0Audio%E5%8A%9F%E8%83%BD/" itemprop="url">底层API实现Audio元素</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-27T17:43:01+08:00">
                2018-03-27
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web/" itemprop="url" rel="index">
                    <span itemprop="name">web</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="公司IOS-APP兼容性问题"><a href="#公司IOS-APP兼容性问题" class="headerlink" title="公司IOS APP兼容性问题"></a>公司IOS APP兼容性问题</h2><p>大家第一反应是，用h5<strong>audio元素</strong>就好了，何须自己实现。原因只有一个：<strong>audio元素</strong>出问题了，在公司IOS APP中出现了兼容性问题：</p>
<pre><code class="language-html">&lt;audio preload=&quot;auto&quot; id=&quot;videoPlay&quot;&gt;
  &lt;source src={declarationUrl}/&gt;
&lt;/audio&gt;</code></pre>
<ul>
<li>列表页 &gt; 详情页 详情页有个人宣言的短音频，点击播放。功能很简单。</li>
<li>到不同的详情页播放，时间久了（无规律）。就会出现播放不了的情况。</li>
<li>卸载重装APP正常，用久了再次出现。</li>
<li>尝试抓包，看上去是缓存了错误的音频（长度为0）。ios排查不出问题，坚称缓存机制没有问题。</li>
<li>压力之下，实在没办法，在小组架构的指导下，才知道还有底层API。</li>
</ul>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>排查下来，大概率还是 <code>&lt;audio&gt;</code> 自身的缓存策略和我们的 <code>IOS webview</code> 的缓存策略有点冲突。决定自己实现一个<code>&lt;audio&gt;</code>，不采用缓存策略，音频完全下载以后调用底层 <code>API</code> 来实现播放。</p>
<p>组件代码：</p>
<pre><code class="language-jsx">class AudioBuffer {

  constructor(props) {
    this.url = props.url || &#39;&#39;;  // 音频url
    this.playBtn = props.playBtn;  // 播放/暂停 按钮
    this.stopBtn = props.stopBtn;  // 停止 按钮
    this.callback = props.callback; // 回调函数 param：play|pause|stop
    this.sourceNode = null; // BufferSource对象节点
    this.startedAt = 0;  // 播放时间点
    this.pausedAt = 0;  // 暂停时间点
    this.playing = false;  // 播放中
    [&#39;play&#39;, &#39;pause&#39;, &#39;stop&#39;, &#39;update&#39;, &#39;getCurrentTime&#39;, &#39;getDuration&#39;, &#39;init&#39;, &#39;bind&#39;].forEach(method =&gt; {
      this[method] = this[method].bind(this);
    });
    this.init();
  }
  // 播放
  play() {
    let offset = this.pausedAt;
    // 如果已经播放完成，重新播放
    if (offset &gt;= this.getDuration()) {
      offset = 0;
    }
    this.sourceNode = this.context.createBufferSource();
    this.sourceNode.connect(this.context.destination);
    this.sourceNode.buffer = this.buffer;
    this.sourceNode.start(0, offset);
    this.startedAt = this.context.currentTime - offset;
    this.pausedAt = 0;
    this.playing = true;
    if (typeof (this.callback) === &#39;function&#39;) {
      // console.log(&#39;------------callback: play&#39;);
      this.callback(&#39;play&#39;, this);
    }
    this.update();
  }

  update() {
    window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame;
    if (this.getCurrentTime() &lt; this.getDuration()) {
      window.requestAnimationFrame(this.update);
    } else {
      this.stop();
      if (typeof (this.callback) === &#39;function&#39;) {
        // console.log(&#39;------------callback: stop&#39;);
        this.callback(&#39;stop&#39;, this);
      }
    }
  }
  // 暂停
  pause() {
    const elapsed = this.context.currentTime - this.startedAt;
    this.stop();
    this.pausedAt = elapsed;
    if (typeof (this.callback) === &#39;function&#39;) {
       // console.log(&#39;------------callback: pause&#39;);
      this.callback(&#39;pause&#39;, this);
    }
  }
  // 停止
  stop() {
    if (this.sourceNode) {
      this.sourceNode.disconnect();
      this.sourceNode.stop(0);
      this.sourceNode = null;
    }
    this.pausedAt = 0;
    this.startedAt = 0;
    this.playing = false;
    if (typeof (this.callback) === &#39;function&#39;) {
       // console.log(&#39;------------callback: stop&#39;);
      this.callback(&#39;stop&#39;, this);
    }
  }
  // 已播放时间
  getCurrentTime() {
    if (this.pausedAt) {
      return this.pausedAt;
    }
    if (this.startedAt) {
      return this.context.currentTime - this.startedAt;
    }
    return 0;
  }
  // 总时长
  getDuration() {
    return this.buffer.duration;
  }
  // 事件绑定
  bind(buffer) {
    this.buffer = buffer;
    if (this.stopBtn) {
      this.stopBtn.addEventListener(&#39;click&#39;, () =&gt; {
        this.stop();
      });
    }
    this.playBtn.addEventListener(&#39;click&#39;, () =&gt; {
      if (this.playing) {
        this.pause();
      } else {
        this.play();
      }
    });

    // function update() {
    //   window.requestAnimationFrame(update);
    // //   info.innerHTML = sound.getCurrentTime().toFixed(1) + &#39;/&#39; + sound.getDuration().toFixed(1);
    // }
    // update();
  }

  init() {
    window._audioContext = window._audioContext || new (window.AudioContext || window.webkitAudioContext)();
    this.context = window._audioContext;
    const request = new XMLHttpRequest();
    request.open(&#39;GET&#39;, this.url, true);
    request.responseType = &#39;arraybuffer&#39;;
    request.addEventListener(&#39;load&#39;, () =&gt; {
      this.context.decodeAudioData(
        request.response,
        (buffer) =&gt; {
          this.bind(buffer);
        },
        () =&gt; {
        });
    });
    request.send();
  }
}

export default AudioBuffer;
</code></pre>
<p>使用：</p>
<pre><code class="language-jsx">  componentDidMount() {
    const audio = this.refs.videoPlay
    const url = audio.getAttribute(&#39;data-url&#39;)
    if(audio &amp;&amp; url ){  
        this.audio = new AudioBuffer({&#39;url&#39;:url,&#39;playBtn&#39;:this.refs.videoPlay})
      }
    } 
  }</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2018/03/17/%E8%8B%B1%E8%AF%AD%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/03/17/%E8%8B%B1%E8%AF%AD%E4%B8%93%E4%B8%9A%E8%AF%8D%E6%B1%87/" itemprop="url">英语专业词汇</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-03-17T10:40:34+08:00">
                2018-03-17
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><code>HTTP</code> HyperText Transfer Protocol，超文本传输协议<br><code>HTTPS</code> Hyper Text Transfer Protocol over SecureSocket Layer，是以安全为目标的 HTTP 通道，HTTPS 在HTTP 的基础下加入SSL 层。<br><code>HSTS</code> 全称 HTTP Strict Transport Security，HTTP严格传输安全，是一个Web安全策略机制。<br><code>DNS</code> Domain Name System 域名解析系统<br><code>CDN</code> Content Delivery Network，即内容分发网络<br><code>function</code> 函数<br><code>functional</code> 函数式<br><code>method</code> 方法。js中指对象中定义的函数，赋值给对象属性的函数。<br><code>programme</code> 编程<br><code>FP</code> Functional Programming 函数式编程<br><code>OOP</code> Object-oriented Programming 面向对象编程<br><code>refactor</code> 代码重构。指对软件代码做任何更动以增加可读性或者简化结构而不影响输出结果。名词是<code>refactorings</code>。<br><code>FSC</code>: functional stateless components 无状态组件，来自React，使用函数定义一个组件。<br><code>lifecycle</code>: 生命周期<br><code>side-effects</code>: 副作用<br><code>Browser</code> 浏览器<br><code>API</code> Application Programming Interface，应用程序编程接口<br><code>Abstraction</code> 抽象<br><code>reusability</code> 复用性<br><code>logic</code> 逻辑<br><code>concept</code> 概念 思想<br><code>feature</code> 特性<br><code>backward compatible</code> 向后兼容<br><code>bloated</code> 臃肿<br><code>solutions</code> 解决方案<br><code>boundary</code> 边界<br><code>syntax</code> 语法，句法<br> <code>destructuring</code>  解构<br> <code>Object destructuring</code> 对象解构<br> <code>prevent</code> 阻止 预防<br> <code>ternary operator</code> 三元操作符 ？：<br> <code>spread operator</code> 展开操作符 …<br> <code>pitfall</code> 陷阱<br> <code>theme</code> 主题<br> <code>producer</code> 生产者<br> <code>consumer</code> 消费者<br> <code>crash</code> 使奔溃  crash your application<br> <code>performance issues</code> 性能问题<br> <code>a pseudo function</code> 伪函数<br> <code>IIFE</code> 立即调用函数表达式(<code>Immediately Invoked function Expression</code>)<br> <code>initially</code> 起初<br> <code>execute</code> 执行<br> <code>plain text</code> 纯文本<br> <code>In this aspect</code> 从这个角度看<br> <code>has no relation to</code> 和……无关<br> <code>embed</code> 嵌入的<br> <code>basics</code> 核心 基本原理<br> <code>QR code</code> 二维码<br> <code>unrealistic</code> 不切实际的<br> <code>contender</code> 竞争者<br> <code>giant</code>  巨头 巨人<br> <code>DCS</code>  Distributed Cache Service, 分布式缓存服务<br> <code>WH</code> Website Hosting, 静态网站托管, 是云开发提供的一项服务<br> <code>Hosting</code> 托管<br> <code>appeal</code> 呼吁<br> <code>maintenance overhead</code> 维护成本<br> <code>reimagine</code> 再定义的<br> <code>specific</code> 特定的 明确的；特性<br> <code>situation</code> 情况;处境<br> <code>make sense</code> 讲得通 言之有理<br> <code>syntactic sugar</code> 语法糖<br> <code>GPU</code>  (=Graphic Processing Unit) 浏览器的图形处理器<br> <code>GUI</code>  (Graphical User Interface) 图形用户接口. 浏览器采用图形方式显示的计算机操作用户界面。<br> <code>AWS</code> 亚马逊云计算服务<br> <code>silver bullet</code> 直译成“银弹”，私以为译成“万金油”（褒义）更接地气一些。<br> <code>reference</code> 引用 参考<br> <code>Flame-graph</code> 火焰图<br> <code>patch</code> 补丁<br> <code>customization</code> 定制<br> <code>significant</code> 重要的<br> <code>Lightweight</code> 轻量的<br> <code>interactions</code> 交流 交互<br> <code>technique</code> 技术 技巧<br> <code>Currying</code> 柯里化<br> <code>kindergarten</code> 幼儿园<br> <code>customize</code> 定制<br> <code>flexibility</code> 灵活性 柔韧性</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2017/04/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/04/04/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E7%AD%96%E7%95%A5/" itemprop="url">浏览器缓存策略</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-04T15:19:26+08:00">
                2017-04-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="浏览器缓存"><a href="#浏览器缓存" class="headerlink" title="浏览器缓存"></a>浏览器缓存</h1><hr>
<p><strong>什么是浏览器缓存</strong></p>
<p>我们都知道，<code>web</code>页面显示所需要的各种资源文件（<code>html</code>，<code>css</code>，<code>js</code>，<code>png</code>等）都是通过 <code>HTTP</code>请求从服务端获取的。浏览器缓存便是将这些资源文件保存在浏览器（内存或者硬盘）中，这样同样的资源文件在后续请求中，如果命中缓存，则直接读取浏览器缓存，而无需重新从服务端获取。</p>
<p>浏览器会在内存、硬盘中开辟一个空间用于保存请求资源副本。我们经常调试时在<code>Chrome</code>的 <code>DevTools Network</code> 里看到 <code>Memory Cache</code>（內存缓存）和 <code>Disk Cache</code>（硬盘缓存），指的就是缓存所在的位置。缓存在内存当中，响应速度更快。但是对于大文件，大概率存储在硬盘中；当系统内存使用率高的话，文件优先存储进硬盘。</p>
<p><strong>为什么需要浏览器缓存</strong></p>
<p><code>HTTP</code>请求耗时耗流量，高频的访问服务器也会对服务器形成压力。而且 <code>HTTP</code>请求本身就是浏览器的宝贵资源，并行请求的数量是有限的。所以使用缓存有以下几个好处：</p>
<ul>
<li>减少了无谓的流量消耗和浏览器资源消耗。</li>
<li>增加了网页的响应速度，提升了用户体验。</li>
<li>降低了服务器的压力。</li>
</ul>
<p><strong>为什么需要缓存策略？</strong></p>
<ul>
<li>有些资源文件是高频更新的，不需要也不能被缓存。</li>
<li>有些资源文件是定期更新的，希望被缓存，但是缓存需要有时效性。时效范围内使用缓存，过了失效则从服务器获取。</li>
<li>有些资源文件是不定期更新的，希望被缓存，但是更新后需要重新从服务器获取并更新缓存，不能命中旧缓存。</li>
</ul>
<p>为了满足以上几点，浏览器就需要一套浏览器缓存策略来保证。</p>
<h1 id="浏览器缓存策略"><a href="#浏览器缓存策略" class="headerlink" title="浏览器缓存策略"></a>浏览器缓存策略</h1><hr>
<ul>
<li><p><strong>存储策略</strong>：请求后，用于判断是否缓存/更新资源。浏览器会根据服务器响应的报文信息（<code>Response Headers</code>）判断是否缓存/更新该资源。</p>
<ul>
<li>缓存资源发生在首次请求后。</li>
<li>更新资源发生在后续请求后。</li>
</ul>
</li>
<li><p><strong>命中策略</strong>：请求中，用于判断是否使用缓存资源。命中策略的前提是浏览器检索到当前请求资源存在本地缓存。</p>
<ul>
<li>不存在本地缓存： 直接发起<code>HTTP</code>请求，从服务器获取资源文件。</li>
<li>存在本地缓存：根据<code>HTTP</code>请求头中的 <code>缓存标识</code> 判断是否使用缓存，因为缓存可能已过期。</li>
</ul>
</li>
</ul>
<p>根据尝试命中缓存的顺序，可以将 命中策略 分为两个阶段：</p>
<ul>
<li><p><code>强缓存</code>命中阶段: 浏览器每次发起请求时，首先尝试命中 <code>强缓存</code>。</p>
<ul>
<li>如果命中，浏览器会直接读取本地缓存直接响应，不会向服务器发起<code>HTTP</code>请求，请求状态是 <code>200</code> 。</li>
<li>如果没有命中，会向服务器发起<code>HTTP</code>请求，进入 协商缓存 阶段。</li>
</ul>
</li>
<li><p><code>协商缓存</code>命中阶段: <code>强缓存</code> 如果未命中，浏览器会携带参数向服务器发起完整的 <code>HTTP</code> 请求。服务器校验是否命中  <code>协商缓存</code>。</p>
<ul>
<li>如果命中，服务器返回<code>304</code>状态码，通知浏览器直接使用本地缓存资源。</li>
<li>如果没有命中，将从服务端获取资源并返回（状态码 <code>200</code>）。</li>
</ul>
</li>
</ul>
<p>下面，让我们分别详细的了解一下两个阶段具体的 命中策略 和对应的 缓存标识。</p>
<h1 id="强缓存命中策略"><a href="#强缓存命中策略" class="headerlink" title="强缓存命中策略"></a>强缓存命中策略</h1><hr>
<p>控制 强缓存 命中的 <strong>缓存标识</strong> 有两个：</p>
<ul>
<li><code>Expires</code>: <code>Http1.0</code> 就存在，是一个绝对时间。用以表达在这个时间点之前发起请求可以直接从浏览器中读取数据，而无需发起请求。</li>
<li><code>Cache-Control</code>: <code>Http1.1</code>新增标识。为了解决 <code>Expires</code> 在浏览器时间被手动更改导致缓存判断错误的问题。优先级更高。</li>
</ul>
<h2 id="强缓存-Expires"><a href="#强缓存-Expires" class="headerlink" title="强缓存 - Expires"></a>强缓存 - Expires</h2><ul>
<li><p><strong>来源</strong>：来自 <code>HTTP</code> 请求的服务器响应消息（<code>Response Headers</code>）。</p>
</li>
<li><p><strong>用法</strong>：表示 缓存到期时间，是一个绝对的时间 (当前时间+缓存时间)。浏览器在 缓存到期时间 之前再次请求资源即命中，直接使用本地缓存。</p>
</li>
<li><p><strong>优势</strong>：<code>Http 1.0</code>产物，同时兼容 <code>Http 1.0</code> 和 <code>Http 1.1</code> 。简单易用。</p>
</li>
<li><p><strong>劣势</strong></p>
<ul>
<li>时间是由服务器发送的(<code>UTC</code>)，如果服务器时间和客户端时间存在不一致，可能会出现问题。</li>
<li>用户可能会将客户端本地的时间进行修改，而导致浏览器判断缓存失效。</li>
</ul>
</li>
</ul>
<h2 id="强缓存-Cache-control"><a href="#强缓存-Cache-control" class="headerlink" title="强缓存 - Cache-control"></a>强缓存 - Cache-control</h2><ul>
<li><p><strong>来源</strong>：<code>HTTP 1.1</code> 新增，同样来自 <code>HTTP</code> 请求的服务器响应消息（<code>Response Headers</code>）。</p>
</li>
<li><p><strong>用法</strong>：提供了一系列更细致的功能设置。常用值如下：</p>
<ul>
<li><code>private</code>: <strong>默认值</strong>。资源只可以被客户端缓存（代理服务器不能）；后续请求都会直接命中强缓存。</li>
<li><code>public</code>: 资源可以被缓存 (包括客户端和代理服务器，如 CDN边缘缓存服务器)；后续请求都会直接命中强缓存。</li>
<li><code>no-cache</code>: 资源可以被缓存；后续请求不命中 强缓存，但是可以尝试命中协商缓存。</li>
<li><code>no-store</code>: 真正意义上的 “不要缓存”。资源根本不会被缓存，所以也不会执行命中策略，直接请求服务器获取资源。</li>
<li><code>max-age=&lt;seconds&gt;</code>: 缓存存储的最长周期，周期内再次请求都会直接命中强缓存，超过这个周期本地缓存会过期失效。</li>
<li><code>other</code>: <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control" target="_blank" rel="noopener">更多高级用法，参考MDN</a></li>
</ul>
</li>
<li><p><strong>优势</strong>：</p>
<ul>
<li><code>HTTP 1.1</code> 产物，以时间间隔标识失效时间，解决了<code>Expires</code> 服务器和客户端相对时间的问题。</li>
<li>相比<code>Expires</code>，提供了更多选项设置。</li>
</ul>
</li>
<li><p><strong>劣势</strong>：同样存在客户端本地时间被修改，缓存有效期失真的问题。</p>
</li>
</ul>
<blockquote>
<p><code>Cache-control</code> 的优先级高于 <code>Expires</code>，为了兼容 <code>HTTP/1.0</code> 和 <code>HTTP/1.1</code>，实际项目中两个字段都可以设置。</p>
</blockquote>
<h1 id="协商缓存命中策略"><a href="#协商缓存命中策略" class="headerlink" title="协商缓存命中策略"></a>协商缓存命中策略</h1><hr>
<p>进入协商缓存命中阶段有 两个 前提条件：</p>
<ul>
<li>请求的资源文件，已经在本地缓存当中。</li>
<li>强缓存没有命中。</li>
</ul>
<p>这个时候浏览器会向服务器发起完整的 <code>HTTP</code> 请求，服务器会通过请求头中的 <code>缓存标识</code> 来判断是否命中协商缓存。</p>
<p>决定协商缓存是否命中的 <code>缓存标识</code> 有两组：</p>
<ul>
<li><p><code>Last-Modified</code> 和 <code>If-Modified-since</code> : 两者都是一个(<code>ETC</code>)时间，表示服务器资源最后一次修改的时间。</p>
<ul>
<li><code>Http1.0</code> 就有。</li>
<li><code>Last-Modified</code>：服务器会放 响应报文头 <code>Response Header</code> 响应，浏览器会保存/更新该信息。</li>
<li><code>If-Modified-since</code>：浏览器会放 请求报文头 <code>Request Header</code> 携带。</li>
</ul>
</li>
<li><p><code>Etag</code> 和 <code>If-None-match</code>: 表示的是服务器资源的唯一标识，只要资源变化，<code>Etag</code>就会重新生成。</p>
<ul>
<li><code>Http1.1</code> 新增</li>
<li><code>Etag</code>： 服务器会放响应报文头 <code>Response Header</code> 响应，浏览器会保存/更新该信息。</li>
<li><code>If-None-match</code>： 浏览器会放 请求报文头 <code>Request Header</code> 携带。</li>
</ul>
</li>
</ul>
<p><code>Etag/If-None-match</code> 的优先级比 <code>Last-Modified/If-Modified-since</code> 高。</p>
<h2 id="协商缓存-Last-Modified-If-Modified-since"><a href="#协商缓存-Last-Modified-If-Modified-since" class="headerlink" title="协商缓存 - Last-Modified/If-Modified-since"></a>协商缓存 - Last-Modified/If-Modified-since</h2><ul>
<li>服务器通过 <code>Last-Modified</code> 字段告知客户端，资源最后一次被修改的时间，例如 <code>Last-Modified: Mon, 10 Nov 2018 09:10:11 GMT</code></li>
<li>浏览器将这个值和文件一起记录在缓存数据库中。</li>
<li>下一次请求相同资源时时，浏览器在请求头中将上次的 <code>Last-Modified</code> 的值写入到请求头的 <code>If-Modified-Since</code> 字段。</li>
<li>服务器会将 <code>If-Modified-Since</code> 的值与 <code>Last-Modified</code> 值进行对比。如果相等，则表示未修改，响应 <code>304</code>；反之，则表示修改了，响应 <code>200</code> 状态码，并返回数据。</li>
</ul>
<p><strong>优点</strong>：</p>
<p>不存在版本问题，每次请求都会去服务器进行校验。服务器对比最后修改时间如果相同则返回304，不同返回200以及资源内容。</p>
<p><strong>缺点</strong>：</p>
<ul>
<li>只要资源修改，无论内容是否发生实质性的变化，都会将该资源返回客户端。例如周期性重写，这种情况下该资源包含的数据实际上一样的。</li>
<li>以时刻作为标识，无法识别一秒内进行多次修改的情况。 如果资源更新的速度是秒以下单位，那么该缓存是不能被使用的，因为它的时间单位最低是秒。</li>
<li>某些服务器不能精确的得到文件的最后修改时间。</li>
<li>如果文件是通过服务器动态生成的，那么该方法的更新时间永远是生成的时间，尽管文件可能没有变化，所以起不到缓存的作用。</li>
</ul>
<h2 id="协商缓存-Etag-If-None-match"><a href="#协商缓存-Etag-If-None-match" class="headerlink" title="协商缓存-Etag/If-None-match"></a>协商缓存-Etag/If-None-match</h2><p>为了解决上述问题，<code>Http1.1</code> 新增了一组字段 <code>Etag</code> 和 <code>If-None-Match</code>。</p>
<ul>
<li>服务器存储着文件的 <code>Etag</code> 字段。<code>Etag</code> 存储的是文件的唯一标识(一般都是 <code>hash</code> 生成的)，只有文件内容的变化才会导致 <code>Etag</code>更改。</li>
<li>浏览器在发起请求时，服务器在 Response header中返回 <code>Etag</code> 字段。</li>
<li>浏览器会将Etag值和文件一起记录在缓存数据库中。</li>
<li>在下一次请求相同资源时，浏览器会将上一次返回的 <code>Etag</code> 值赋值给 <code>If-No-Matched</code> 并添加在 <code>Request Header</code>中。</li>
<li>服务器将浏览器传来的 <code>If-No-Matched</code> 跟自己本地资源的 <code>Etag</code> 做对比。如果匹配，则返回 <code>304</code> 通知浏览器读取本地缓存，否则返回 <code>200</code> 和 更新后的资源。</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>可以更加精确的判断资源是否被修改，可以识别一秒内多次修改的情况。</li>
<li>不存在版本问题，每次请求都回去服务器进行校验。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>计算<code>Etag</code>值需要性能损耗。</li>
<li>分布式服务器存储的情况下，计算<code>Etag</code>的算法如果不一样，会导致浏览器从一台服务器上获得页面内容后到另外一台服务器上进行验证时现<code>Etag</code>不匹配的情况。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://www.jiqizhixin.com/articles/2020-07-24-12" target="_blank" rel="noopener">彻底弄懂浏览器缓存策略</a><br><a href="https://cloud.tencent.com/developer/article/1439913" target="_blank" rel="noopener">CDN回源原理和多级缓存</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2017/03/14/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/14/%E4%B8%80%E4%BA%9B%E6%9C%89%E8%B6%A3%E7%9A%84%E7%BD%91%E7%AB%99/" itemprop="url">一些有用（趣）的网站</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-14T14:33:36+08:00">
                2017-03-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9D%82%E9%A1%B9/" itemprop="url" rel="index">
                    <span itemprop="name">杂项</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="花瓣网"><a href="#花瓣网" class="headerlink" title="花瓣网"></a>花瓣网</h2><p>大量的灵感图片，可充当设计素材，也可单纯欣赏。<br><a href="https://huaban.com/discovery/" target="_blank" rel="noopener">https://huaban.com/discovery/</a></p>
<h2 id="Can-I-use"><a href="#Can-I-use" class="headerlink" title="Can I use"></a>Can I use</h2><p>HTML5 CSS3 新特性各浏览器内核兼容性查询工具<br><a href="https://caniuse.com/" target="_blank" rel="noopener">https://caniuse.com/</a></p>
<h2 id="压缩图"><a href="#压缩图" class="headerlink" title="压缩图"></a>压缩图</h2><p>在线修改图片大小尺寸的工具<br><a href="https://www.yasuotu.com/size" target="_blank" rel="noopener">https://www.yasuotu.com/size</a></p>
<h2 id="codeSandbox"><a href="#codeSandbox" class="headerlink" title="codeSandbox"></a>codeSandbox</h2><p>开源的web在线 IDE 工具，支持在线代码编辑，webpack打包，实时预览，发布。<br><a href="https://codesandbox.io/" target="_blank" rel="noopener">https://codesandbox.io/</a><br><a href="https://hackernoon.com/@compuives" target="_blank" rel="noopener">作者博客</a><br><a href="https://github.com/codesandbox" target="_blank" rel="noopener">开源项目</a><br><a href="https://vince.xin/2019/11/02/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%89%88%E5%9C%A8%E7%BA%BF%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-IDE/" target="_blank" rel="noopener">实现原理介绍</a></p>
<h2 id="Live2D-for-web"><a href="#Live2D-for-web" class="headerlink" title="Live2D for web"></a>Live2D for web</h2><p>hexo插件：Live2D 可视化技术<br><a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">https://github.com/EYHN/hexo-helper-live2d</a><br><a href="https://www.live2d.com/" target="_blank" rel="noopener">live2D</a><br><a href="https://l2dwidget.js.org/docs/" target="_blank" rel="noopener">live2D-widget-js</a><br><a href="https://www.zhangxinxu.com/wordpress/2018/05/live2d-web-webgl-js/" target="_blank" rel="noopener">live2d与web前端技术结合</a></p>
<h2 id="k8s了解一下"><a href="#k8s了解一下" class="headerlink" title="k8s了解一下"></a>k8s了解一下</h2><p><code>Kubernetes</code>是一个开源的，用于管理云平台中多个主机上的容器化的应用，<code>Kubernetes</code>的目标是让部署容器化的应用简单并且高效（powerful）,<code>Kubernetes</code>提供了应用部署，规划，更新，维护的一种机制。<br><a href="https://www.kubernetes.org.cn/k8s" target="_blank" rel="noopener">文档</a></p>
<h2 id="掘金"><a href="#掘金" class="headerlink" title="掘金"></a>掘金</h2><p>一个帮助开发者成长的社区，很多文章质量都挺高的。<br><a href="https://juejin.im/" target="_blank" rel="noopener">https://juejin.im/</a></p>
<h2 id="Search-Hacker-News"><a href="#Search-Hacker-News" class="headerlink" title="Search Hacker News"></a>Search Hacker News</h2><p><a href="https://hn.algolia.com/" target="_blank" rel="noopener">https://hn.algolia.com/</a></p>
<h2 id="InfoQ"><a href="#InfoQ" class="headerlink" title="InfoQ"></a>InfoQ</h2><p>是一个实践驱动的社区资讯站点，致力于促进软件开发领域知识与创新的传播。提供架构，云计算，AI，前端，大数据，Java，软件开发，编程等技术资讯及技术会议，搭建连接中国技术高端社区与国际主流技术社区的桥梁。<br><a href="https://www.infoq.cn/" target="_blank" rel="noopener">https://www.infoq.cn/</a></p>
<h1 id="Deepl-翻译"><a href="#Deepl-翻译" class="headerlink" title="Deepl 翻译"></a>Deepl 翻译</h1><p>DeepL，一款优于谷歌（Google）、微软（Microsoft）和脸书（Facebook）的在线翻译器。<br><a href="https://www.deepl.com/translator" target="_blank" rel="noopener">https://www.deepl.com/translator</a></p>
<h1 id="BPMNJS"><a href="#BPMNJS" class="headerlink" title="BPMNJS"></a>BPMNJS</h1><p>BPMN2.0的web建模器，流程图可以在前端完成，在前端应用中展示。<br><a href="https://bpmn.io/toolkit/bomn-js/" target="_blank" rel="noopener">https://bpmn.io/toolkit/bomn-js/</a></p>
<h1 id="TBS腾讯浏览服务"><a href="#TBS腾讯浏览服务" class="headerlink" title="TBS腾讯浏览服务"></a>TBS腾讯浏览服务</h1><p>依托X5内核强大的能力，致力于提供优化移动端浏览器体验的整套解决方案。可用于安卓APP中统一的webview，提高兼容性。<br><a href="https://x5.tencent.com/tbs/index.html" target="_blank" rel="noopener">https://x5.tencent.com/tbs/index.html</a></p>
<h1 id="MD文档在线编辑导出PDF等"><a href="#MD文档在线编辑导出PDF等" class="headerlink" title="MD文档在线编辑导出PDF等"></a>MD文档在线编辑导出PDF等</h1><p><a href="https://resumd.t9t.io/" target="_blank" rel="noopener">https://resumd.t9t.io/</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2016/08/21/promiss%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/08/21/promiss%E5%8E%9F%E7%90%86%E5%8F%8A%E5%BA%94%E7%94%A8/" itemprop="url">promiss原理及应用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-08-21T17:13:30+08:00">
                2016-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>哈哈 纯属搬运，主要别人写的实在太好了：</p>
<p><a href="https://tech.meituan.com/2014/06/05/promise-insight.html" target="_blank" rel="noopener">Promise剖析</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2015/03/31/JS%E4%B9%8B%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2015/03/31/JS%E4%B9%8B%E6%95%B0%E7%BB%84%E5%9F%BA%E7%A1%80/" itemprop="url">JS之数组基础</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2015-03-31T17:24:48+08:00">
                2015-03-31
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="数组的定义"><a href="#数组的定义" class="headerlink" title="数组的定义"></a>数组的定义</h1><hr>
<ul>
<li><strong>数组</strong>是一种使用 整数 作为键(<code>integer-key-ed</code>) 属性 和长度 (<code>lengt</code>h) 属性之间关联的特殊对象。</li>
<li><code>Array</code> 对象是 <code>JS</code> 专门用于构造数组的全局对象。</li>
<li>可以通过 <strong>字面量表达式</strong> 和 <strong><code>Array</code> 构造函数</strong> 定义数组。</li>
</ul>
<pre><code class="language-js">
// 字面量表达式
var arr1 = []; // 空数组
var arr2 = [1, &quot;2&quot;, false];
var arr3 = [3];  // 长度为1，元素只有3的数组

// Array构造函数
var arr4 = new Array(); // 空数组
var arr5 = new Array(1,&quot;2&quot;, false);
var arr6 = new Array(3);  // 初始化为一个长度为 3 的 空数组 [empty × 3]</code></pre>
<h1 id="数组的方法"><a href="#数组的方法" class="headerlink" title="数组的方法"></a>数组的方法</h1><hr>
<ul>
<li><p><code>fill()</code>: 数组填充</p>
<ul>
<li>参数 <code>(value[, start[, end]])</code>。将数组 <code>start</code>(默认开始) 到 <code>end</code>(默认结束) 索引值替换或填充为 <code>value</code>。</li>
</ul>
<pre><code class="language-js">  // 创建一个10*10的二维数组，所有值填充为0
  let arr = new Array(10).fill(null).map(() =&gt; new Array(10).fill(0));</code></pre>
</li>
<li><p><code>join()</code>: 将数组的元素组起一个字符串。</p>
<ul>
<li>参数 （<code>separator</code>），以 <code>separator</code> 为分隔符，省略的话则用默认用 <code>,</code> 为分隔符。<pre><code class="language-js">var arr = [1,2,3];
console.log(arr.join()); // 1,2,3
console.log(arr.join(&quot;-&quot;)); // 1-2-3
console.log(arr); // [1, 2, 3]（原数组不变）</code></pre>
</li>
</ul>
</li>
<li><p><code>push()</code>和 <code>pop()</code>: </p>
<ul>
<li><code>push()</code> 将在数组 尾部 添加一个或多个元素，并返回修改后数组的长度。</li>
<li><code>pop()</code> 将移除数组尾部的第一个元素，并返回这个元素。<pre><code class="language-js">var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
var count = arr.push(&quot;Jack&quot;,&quot;Sean&quot;);
console.log(count); // 5
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;, &quot;Sean&quot;]
var item = arr.pop();
console.log(item); // Sean
console.log(arr); // [&quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;, &quot;Jack&quot;]</code></pre>
</li>
</ul>
</li>
<li><p><code>shift()</code> 和 <code>unshift()</code> : </p>
<ul>
<li><code>shift()</code> 将删除数组头部的第一个元素，并返回删除元素的值。如果数组为空则返回 <code>undefined</code>。</li>
<li><code>unshift()</code> 将一个或多个元素添加到原数组开头，并返回修改后数组的长度。</li>
</ul>
<pre><code class="language-js">  var arr = [&quot;Lily&quot;,&quot;lucy&quot;,&quot;Tom&quot;];
  var count = arr.unshift(&quot;Jack&quot;,&quot;Sean&quot;);
  console.log(count); // 5
  console.log(arr); //[&quot;Jack&quot;, &quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]
  var item = arr.shift();
  console.log(item); // Jack
  console.log(arr); // [&quot;Sean&quot;, &quot;Lily&quot;, &quot;lucy&quot;, &quot;Tom&quot;]</code></pre>
</li>
<li><p><code>sort()</code> : 数组项排序，默认升序排列。</p>
<ul>
<li><p>无参：将每个数组项 toString() 以后比较。即使数组中的每一项都是数值，sort()方法比较的也是字符串。</p>
</li>
<li><p>有参：支持接收一个比较函数作为参数。比较函数有两个参数<code>(a, b)</code>，通过返回 <code>-1</code>（<code>a</code>排前面）, <code>0</code>（顺序不变）, <code>1</code>（<code>b</code>排前面）来决定顺序。</p>
<pre><code class="language-js">var arr1 = [&quot;a&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;];
console.log(arr1.sort()); // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;]
arr2 = [13, 24, 51, 3];
console.log(arr2.sort()); // [13, 24, 3, 51]

arr2 = [13, 24, 51, 3];
console.log(arr2.sort((a, b) =&gt; a - b)); // [3, 13, 24, 51]</code></pre>
</li>
</ul>
</li>
<li><p><code>reverse()</code>: 将原数组项的顺序反转并返回，意味着原数组也会被改变。</p>
<pre><code class="language-js">  var arr = [13, 24, 51, 3];
  console.log(arr.reverse()); //[3, 51, 24, 13]
  console.log(arr); //[3, 51, 24, 13](原数组改变)</code></pre>
</li>
<li><p><code>concat()</code>: 用于连接两个或多个数组。不会改变现有的数组，返回一个新的数组。</p>
<pre><code class="language-js">  var arr = [1,3,5,7];
  var arrCopy = arr.concat(9,[11,13]);
  console.log(arrCopy); //[1, 3, 5, 7, 9, 11, 13]
  console.log(arr); // [1, 3, 5, 7](原数组未被修改)</code></pre>
</li>
<li><p><code>slice()</code>: 将原数组的 <code>[begin, end)</code>范围元素生成一个新的数组返回。可以接受一或两个参数，即要截取的 起始索引 和 结束索引。</p>
<ul>
<li>负参：参数为负数，则表示 从后往前 的位置索引，索引相当于是 <code>length + begin/end</code>( <code>length</code> 是数组长度)。</li>
<li>无参：相当于生成原数组的浅拷贝。</li>
<li>不会改变原数组，而是返回一个新的数组。<pre><code class="language-js">var arr = [1,3,5,7,9,11];
var arrCopy = arr.slice(1);
var arrCopy2 = arr.slice(1,4);
var arrCopy3 = arr.slice(1,-2);
var arrCopy4 = arr.slice(-4,-1);
console.log(arr); //[1, 3, 5, 7, 9, 11](原数组没变)
console.log(arrCopy); //[3, 5, 7, 9, 11]
console.log(arrCopy2); //[3, 5, 7]
console.log(arrCopy3); //[3, 5, 7]
console.log(arrCopy4); //[5, 7, 9]</code></pre>
</li>
</ul>
</li>
<li><p><code>splice()</code>: 可以实现数组元素的 删除、插入和替换。</p>
<ul>
<li>删除：双参数 <code>(index, n)</code>, 将从<code>index</code>索引 位置开始删除 <code>n</code>个 元素。</li>
<li>插入：3个及以上参数<code>(index, n, ...data)</code>; 其中<code>n === 0</code>,相当于在<code>index</code>索引位置插入<code>...data</code>。</li>
<li>替换：同上，但是 <code>n !== 0</code>。就相当于把<code>index</code>索引开始的<code>n</code>个元素替换为<code>...data</code>。<pre><code class="language-js">var arr = [1,3,5,7,9,11];
var arrRemoved = arr.splice(0,2);
console.log(arr); //[5, 7, 9, 11]
console.log(arrRemoved); //[1, 3]
var arrRemoved2 = arr.splice(2,0,4,6);
console.log(arr); // [5, 7, 4, 6, 9, 11]
console.log(arrRemoved2); // []
var arrRemoved3 = arr.splice(1,1,2,4);
console.log(arr); // [5, 2, 4, 4, 6, 9, 11]
console.log(arrRemoved3); //[7]</code></pre>
</li>
</ul>
</li>
<li><p><code>indexOf()</code> 和 <code>lastIndexOf()</code>: </p>
<ul>
<li><code>indexOf()</code>: 查找数组中某元素(第一个参数)首次出现的索引值，没有则返回 <code>-1</code>。</li>
<li><code>lastIndexOf()</code>: 查找数组中某元素(第一个参数)最后出现的索引值，没有则返回 <code>-1</code>。</li>
<li>第二个参数都表示开始查找的索引，默认是 <code>0</code>，从第一个开始。<pre><code class="language-js">var arr = [1,3,5,7,7,5,3,1];
console.log(arr.indexOf(5)); //2
console.log(arr.lastIndexOf(5)); //5
console.log(arr.indexOf(5,2)); //2
console.log(arr.lastIndexOf(5,4)); //2
console.log(arr.indexOf(&quot;5&quot;)); //-1</code></pre>
</li>
</ul>
</li>
<li><p><code>forEach()</code>: 对数组进行遍历循环。</p>
<ul>
<li>对数组中的每一项运行处理函数。处理函数有两个参数，分别是 当前数组项 和 索引值。</li>
<li>这个方法没有返回值。<pre><code class="language-js">var arr = [1, 2, 3, 4, 5];
arr.forEach(function(x, index, a){
console.log(x + &#39;|&#39; + index + &#39;|&#39; + (a === arr));
});
// 输出为：
// 1|0|true
// 2|1|true
// 3|2|true
// 4|3|true
// 5|4|true</code></pre>
</li>
</ul>
</li>
<li><p><code>map()</code>: 对数组中的每一项运行给定函数，然后将每次函数调用的结果组成新的数组返回。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.map(function(item){
  return item*item;
  });
  console.log(arr2); //[1, 4, 9, 16, 25]</code></pre>
</li>
<li><p><code>filter()</code>: “过滤”功能，将数组中的每一项运行给定函数，返回满足过滤条件组成的数组。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
  var arr2 = arr.filter(function(x, index) {
  return index % 3 === 0 || x &gt;= 8;
  }); 
  console.log(arr2); //[1, 4, 7, 8, 9, 10]</code></pre>
</li>
<li><p><code>every()</code>: 将数组中的每一项运行给定函数，只有所有项都满足条件，才会返回true。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.every(function(x) {
  return x &lt; 10;
  }); 
  console.log(arr2); //true
  var arr3 = arr.every(function(x) {
  return x &lt; 3;
  }); 
  console.log(arr3); // false</code></pre>
</li>
<li><p><code>some()</code>: 将数组中的每一项运行给定函数，只要有一项满足条件，就会返回true。</p>
<pre><code class="language-js">  var arr = [1, 2, 3, 4, 5];
  var arr2 = arr.some(function(x) {
  return x &lt; 3;
  }); 
  console.log(arr2); //true
  var arr3 = arr.some(function(x) {
  return x &lt; 1;
  }); 
  console.log(arr3); // false</code></pre>
</li>
<li><p><code>reduce()</code> 和 <code>reduceRight()</code>: 用于数组项的迭代</p>
<ul>
<li><code>reduce()</code>方法从数组的第一项开始，逐个遍历到最后。而 <code>reduceRight()</code> 则从数组的最后一项开始，向前遍历到第一项。</li>
<li>两个参数：一个在每一项上调用的函数和作为归并基础的初始值（可选）。</li>
<li>调用函数接收 4 个参数：前一个值 ( 初始值 或者 前面迭代返回的结果值 )、当前值、项的索引 和 数组对象。<pre><code class="language-js">var values = [1,2,3,4,5];
var sum = values.reduceRight(function(prev, cur, index, array){
return prev + cur;
},10);
console.log(sum); //25</code></pre>
</li>
</ul>
</li>
</ul>
<h1 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h1><hr>
<ul>
<li><p>类数组定义</p>
<ul>
<li>拥有 <code>length</code> 属性，其它属性（索引）为非负整数（对象中的索引会被当做字符串来处理）的一个<strong>对象</strong>。</li>
<li><code>typeof</code> 是 <code>object</code>，不具有数组所具有的方法。</li>
<li><code>JS</code> 中常见的 类数组 有 <code>arguments</code> 对象和 <code>DOM</code> 方法的返回结果，比如 <code>document.getElementsByTagName()</code>。</li>
</ul>
</li>
<li><p>类数组判断</p>
<pre><code class="language-js">function isLikeArray(o) {
  if (typeof o === &#39;object&#39; &amp;&amp; isFinite(o.length) &amp;&amp;  o.length &gt;= 0 &amp;&amp; o.length &lt; 4294967296){
      // 4294967296: 2^32
      return true
  } else {
      return false
  }
}</code></pre>
<blockquote>
<p>全局 <code>isFinite()</code> 函数用来判断被传入的参数值是否为一个有限数值（<code>finite number</code>）。在必要情况下，参数会首先转为一个数值。</p>
</blockquote>
</li>
<li><p>类数组转换为数组</p>
<ul>
<li>方法1: <code>args = Array.prototype.slice.call(arguments);</code>, 借助数组的<code>slice()</code> 方法。</li>
<li>方法2: <code>Array.from(arguments)</code>,  <code>ES6</code>新增方法。</li>
</ul>
</li>
</ul>
<blockquote>
<p>数组转换为数组后可以直接调用数组具有的方法。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://www.cnblogs.com/obel/p/7016414.html" target="_blank" rel="noopener">JS数组方法大全</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sgj.jpeg"
                alt="祁连" />
            
              <p class="site-author-name" itemprop="name">祁连</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">61</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                大牛👇
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://overreacted.io/zh-hans/" title="Dan Abramov" target="_blank">Dan Abramov</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qianduan.group/" title="寸志" target="_blank">寸志</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.robinwieruch.de/blog" title="Robin Wieruch" target="_blank">Robin Wieruch</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">祁连</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<script src="/js/prism/prism.js" async></script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
