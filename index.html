<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Live and learn">
<meta property="og:url" content="http://www.mala520.life/index.html">
<meta property="og:site_name" content="Live and learn">
<meta property="article:author" content="祁连">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://www.mala520.life/"/>





<link rel="stylesheet" href="/js/prism/prism.css">

  <title>Live and learn</title>
  








<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Live and learn</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2022/07/21/canvas%E7%A2%8E%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/07/21/canvas%E7%A2%8E%E7%89%87/" itemprop="url">canvas碎片</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-07-21T18:56:12+08:00">
                2022-07-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2022/06/14/slatejs%E5%AE%9E%E8%B7%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/06/14/slatejs%E5%AE%9E%E8%B7%B5/" itemprop="url">slatejs实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-06-14T14:51:27+08:00">
                2022-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr>
<p><code>Slate.js</code> 是一个完全可定制的的富文本编辑器，准确来说是一个框架。其诞生于 2016 年，作者是 <code>Ian Storm Taylor</code>。它和 <code>Draft.js</code>, <code>Prosemirror</code>, <code>Quill</code>类似，都是基于结构化对象来渲染富文本内容。 </p>
<p><code>slate.js</code> 架构设计类似于 <code>MVC</code>：</p>
<ul>
<li><code>(Model)</code>slate 定义了一套数据模型以及更新 model 的一系列 commonds。</li>
<li><code>(View)</code> slate 定义了一套与数据模型对应的视图模型（洋葱模型），使用 react 将数据模型渲染成视图模型。</li>
<li><code>(Ctrl)</code> slate 支持自定义事件监听，然后通过 commonds 调用更新数据模型。</li>
</ul>
<p>这里，<code>commonds</code>指的是 <code>slate</code> 内部定义的一系列 <code>Operation</code>。和用来生产<code>Operation</code>的一系列<code>Transforms</code> 辅助方法。<br><code>model</code> 更新以后会通过一些规则来保证数据格式的规范，对<code>model</code>进行正确性校验，然后触发<code>view</code>变更。</p>
<p><code>slate</code> 仓库下包含四个 <code>package</code>：</p>
<ul>
<li><code>slate</code>：这一部分是编辑器的核心，定义了数据模型<code>（model）</code>，操作模型的方法和编辑器实例本身。</li>
<li><code>slate-react</code>：以插件的形式提供 <code>DOM</code> 渲染和用户交互能力，包括光标、快捷键等等。</li>
<li><code>slate-history</code>：以插件的形式提供 <code>undo/redo</code> 能力。</li>
<li><code>slate-hyperscript</code>：让用户能够使用 <code>JSX</code>语法来创建 <code>slate</code> 的数据。</li>
</ul>
<h1 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h1><hr>
<ul>
<li>灵活，完全可定制。</li>
<li>插件是一等公民，你可以以插件的形式定制自己的用于修改编辑器的行为API.</li>
<li>数据模型类似于可嵌套的<code>Dom</code>树，<code>Schema</code>结构非常精简。</li>
<li>具有原子化操作 <code>API</code>，支持协同编辑。</li>
<li>使用 <code>React</code> 作为渲染层；</li>
</ul>
<h1 id="slate-数据模型"><a href="#slate-数据模型" class="headerlink" title="slate 数据模型"></a>slate 数据模型</h1><hr>
<p><code>slate</code> 以树形结构来表示和存储文档内容，树的节点类型为 <code>Node</code>，分为三种子类型：</p>
<pre><code class="language-js">export type Node = Editor | Element | Text

export interface Element {
  children: Node[]
  [key: string]: unknown
}

export interface Text {
  text: string
  [key: string]: unknown
}</code></pre>
<ul>
<li><code>Editor</code> 是一种特殊的 <code>Element</code> ，它既是编辑器实例类型，也是文档树的根节点</li>
<li><code>Element</code> 类型含有 <code>children</code> 属性，可以作为其他 <code>Node</code> 的父节点</li>
<li><code>Text</code> 类型是树的叶子结点，包含文字信息</li>
</ul>
<p>用户可以自行拓展 <code>Node</code> 的属性，例如通过添加 <code>type</code> 字段标识<code>Node</code> 的类型（<code>paragraph</code>, <code>ordered list</code>, <code>heading</code> 等等），或者是文本的属性（<code>italic</code>, <code>bold</code>等等），来描述富文本中的文字和段落。</p>
<pre><code class="language-js">const initialValue = [
    {
        type: &#39;paragraph&#39;,
        children: [{ text: &#39;我是&#39;, bold: true }, { text: &#39;一行&#39;, underline: true }, {text: &#39;文字&#39;}]
    },
    {
        type: &#39;code&#39;,
        children: [{ text: &#39;hello world&#39; }]
    },
    {
        type: &#39;image&#39;,
        children: [],
        url: &#39;xxx.png&#39;
    }
    // 其他的继续扩展
]</code></pre>
<h1 id="slate-渲染模型"><a href="#slate-渲染模型" class="headerlink" title="slate 渲染模型"></a>slate 渲染模型</h1><hr>
<p><code>slate</code>数据模型通过<code>slate-react</code>视图渲染以后的组件层级如下图所示：</p>
<p>你会看到一些 <code>data-</code> 开头的自定义内置特性（<code>attribute</code>），比如 <code>data-slate-node</code> 等。</p>
<p><code>slate</code>主要内置特性如下：</p>
<ul>
<li><p><code>Editable</code></p>
<ul>
<li><code>data-slate-editor</code> 用于标识编辑器组件。</li>
</ul>
</li>
<li><p><code>Element</code></p>
<ul>
<li><code>data-slate-node</code>: ‘element’|’value’|’text’；取值分别代表元素、文档全量值（适用于 Editable 上）、文本节点。</li>
<li><code>data-slate-void</code>: 若为空元素则取值为 true，否则不存在。</li>
<li><code>data-slate-inline</code>: 若为内联元素则取值为 true，否则不存在。</li>
</ul>
</li>
<li><p><code>Leaf</code></p>
<ul>
<li><code>data-slate-leaf</code>: 必须，取值为 true，表明对应 DOM 元素为 Leaf 节点。</li>
</ul>
</li>
<li><p><code>String</code></p>
<ul>
<li><code>data-slate-string</code>: 若为文本节点则取值为 true，否则不存在。</li>
<li><code>data-slate-zero-width</code>: 若为零宽度文本节点则取值 ‘n’|’z’，分别指代换行、不换行，否则不存在。</li>
<li><code>data-slate-length</code>: 用于标注零宽度文本节点的实际宽度，单位为字符数。默认为 0，如果不为零则为被设置了 isVoid 的元素的文本字符的宽度。</li>
</ul>
</li>
</ul>
<p>此外，对于 <code>Element</code> 的 <code>attributes</code> 中还有以下内置特性内容：</p>
<ul>
<li><code>contentEditable</code>: 若不可编辑则取值为 false，否则不存在。</li>
<li><code>dir</code>: 若编辑方向为从右到左则取值 ‘rtl’，否则不存在。</li>
<li><code>ref</code>: 必选，当前元素的 ref 引用。Slate 会在每次 Element 渲染时将该元素和其对应 DOM 节点的映射关系添加到 ELEMENT_TO_NODE 的 WeakMap 中。若缺少 ref 则会因为 ELEMENT_TO_NODE 中映射关系的缺失而导致渲染失败和 toSlateNode 中报错。</li>
</ul>
<h1 id="简单实例"><a href="#简单实例" class="headerlink" title="简单实例"></a>简单实例</h1><hr>
<pre><code class="language-jsx">
import React, { useState, useMemo } from &#39;react&#39;
import { createEditor } from &#39;slate&#39;  // 创建编辑器实例的方法
import { Slate, Editable, withReact } from &#39;slate-react&#39;
import { withHistory } from &#39;slate-history&#39;; //以插件的形式提供 undo/redo 能力

// 初始化编辑器内容的数据。其结构类似于 vnode。
const initialValue = [
  {
    type: &#39;paragraph&#39;,
    children: [ { text: &#39;我是一行文字&#39; } ]
  }
]

export default  BasicEditor = () =&gt; {
    /** editor 变量为编辑器的对象实例，可以使用它提供的大量 API，也可以用来扩展其他插件。 */
    const editor = useMemo(() =&gt; withHistory(withReact(createEditor())) ,[])
    const [value, setValue] = useState(initialValue)

    return (
        &lt;div style={{ border: '1px solid #ccc', padding: '10px' }}&gt;
            &lt;Slate
                editor={editor}
                onChange={newValue =&gt; setValue(newValue)}
            &gt;
                &lt;Editable/&gt;
            &lt;/Slate&gt;
        &lt;/div&gt;
    )
}
</code></pre>
<h1 id="renderElement"><a href="#renderElement" class="headerlink" title="renderElement"></a>renderElement</h1><p>slate.js 提供了 renderElement 让我们来自定义渲染逻辑，不过先别着急。富文本编辑器嘛，肯定不仅仅只有文字，还有很多数据类型，这些都是需要渲染的，所以都要依赖于这个 renderElement 。</p>
<h1 id="renderLeaf"><a href="#renderLeaf" class="headerlink" title="renderLeaf"></a>renderLeaf</h1><p>renderElement 是渲染 Element ，但是它管不了更底层的 Text ，所以 slate.js 提供了 renderLeaf ，用来控制文本格式。renderElement 和 renderLeaf 并不冲突，可以一起用。</p>
<h1 id="自定义事件"><a href="#自定义事件" class="headerlink" title="自定义事件"></a>自定义事件</h1><p>在 slate.js，自定义事件可以直接在 <Editable> 组件监听 DOM 事件即可。通常，一些快捷键可以通过这种方式来设置。</p>
<h1 id="操作API"><a href="#操作API" class="headerlink" title="操作API"></a>操作API</h1><p>到 Editor 和 Transforms 对象里封装了很多常用的一系列 API 。可以增加样式，操作节点等。</p>
<h1 id="简单插件"><a href="#简单插件" class="headerlink" title="简单插件"></a>简单插件</h1><p>slate.js 提供的是编辑器的基本能力，如果不能满足使用，它提供了插件机制供用户去自行扩展。<br>另外，有了规范的插件机制，还可以形成自己的社区，可以直接下载使用第三方插件。</p>
<p>插件开发其实很简单，就是对 editor 的扩展和装饰。你想要做什么，可以充分返回自己的想象力。</p>
<h1 id="数据处理"><a href="#数据处理" class="headerlink" title="数据处理"></a>数据处理</h1><h1 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h1><ul>
<li>contenteditable</li>
<li>execCommand</li>
<li>Selection 和 Range </li>
<li>自定义组件</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul>
<li><a href="https://docs.slatejs.org/" target="_blank" rel="noopener">slate.js 官网</a></li>
<li><a href="https://juejin.cn/post/6970289345911586853" target="_blank" rel="noopener">富文本编辑器框架 - slate.js</a></li>
<li><a href="https://juejin.cn/post/7086816312789794846" target="_blank" rel="noopener">从 Slate 的内置特性到洋葱模型</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2022/03/01/%E6%97%A5%E6%8A%A5%E6%8E%A8%E9%80%81%E5%AF%B9%E5%A4%96%E7%89%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2022/03/01/%E6%97%A5%E6%8A%A5%E6%8E%A8%E9%80%81%E5%AF%B9%E5%A4%96%E7%89%88/" itemprop="url">报表导出与自动推送在大数据平台场景下的探索与实践</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-03-01T11:03:56+08:00">
                2022-03-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><hr>
<p>在大数据分析平台，分析师可以通过多维交叉分析模型，生成许多能够直观反应现状的报表。这些报表可以动态更新，实时计算。我们可以通过不同的看板，把相关的报表进行聚合，聚焦。这些看板往往是对公司是非常有价值的智慧沉淀。越有价值的东西，我们就应该让它的价值最大化。我们可以把它们分享给内部同样关注和需要的人。分享一般有两种形式：</p>
<ul>
<li>系统内分享：把看板分享给同样具有系统账户和权限的其他同事。</li>
<li>系统外分享：把看板信息通过其他载体分享出去。比如作为 <code>PDF</code> 或者图片在邮件，企业微信等渠道分享。</li>
</ul>
<p>系统外分享也是非常有用和普遍的。一方面可以作为日报/周报，周期性的反应阶段性现状。另一方面，可以让其他同事，老板非常便捷的了解到这些信息。</p>
<p>对于推送方式，一般有两种：</p>
<ul>
<li>分析师可以把自己的看板导出为 <code>PDF</code> 或者图片，通过邮件或者内部沟通工具进行针对性分享。</li>
<li>分析师可以创建规则（一般是推送时间，推送渠道，推送内容），将自己的看板定时的推送给相关人员。</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><hr>
<p>对于看板导出为 <code>PDF</code>，这在前端就可以实现。把 <code>Html</code> 页面生成<code>PDF</code> 的前端技术已经比较成熟，比如当下比较流行的两大利器：</p>
<ul>
<li><code>html2canvas</code>： 可以把 <code>Html</code> 转成 <code>Canvas</code>，进而生成图片。</li>
<li><code>jspdf</code>： 可以把图片转成 <code>PDF</code> 文件。</li>
</ul>
<p>对于看板定时推送，更多的需要借助后端的能力。比如定时任务，邮件，企业微信/钉钉/飞书等渠道的推送都需要后端来完成。报表的定时生成，需要用到无头浏览器来进行登录模拟，页面加载和图片生成（截屏）。</p>
<ul>
<li><code>Node</code> 环境下可以使用 <code>Puppeteer</code>，</li>
<li><code>Java</code> 环境下可以使用 <code>ChromeDriver</code> 工具。</li>
</ul>
<p>前端需要配合完成推送规则，渠道和内容的配置。此外，前端还需要针对导出模式对原有页面做一系列特殊处理，让导出的报表更加符合预期。比如隐藏一些无用信息，额外显示一些信息（比如在页面上 <code>hover</code> 上去才会显示的有用信息）。同时还要保证不会影响常规模式下页面的使用效果。</p>
<h1 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h1><p>工具虽好，但在实际场景中应用的时候，很多问题是工具无法帮你解决的。在大数据平台下，以下场景就比较常见：</p>
<ul>
<li>懒加载</li>
<li>巨量数据请求</li>
<li>巨量数据渲染</li>
</ul>
<p>你不能给用户导出一个数据不全，或者还没有渲染完成的报表。所以，我们必须解决懒加载的问题，并确保巨量数据已经请求并渲染完成。</p>
<h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>懒加载也叫按需加载，是一种被广泛应用的网页性能优化方式，它能极大的提升用户体验。比如页面很长，我们优先加载可视区域的内容，其他部分等用户滚动进入可视区域再加载。</p>
<p>比如在 <code>React</code> 技术栈项目中，我们可以使用 <a href="https://www.npmjs.com/package/react-lazyload" target="_blank" rel="noopener"><code>react-lazyload</code></a> 组件实现懒加载：</p>
<pre><code class="language-javascript">import React from &#39;react&#39;;
import LazyLoad from &#39;react-lazyload&#39;;

const Demo = () =&gt; {
  return (
    &lt;&gt;
      &lt;LazyLoad height={500} offset={100}&gt;
    &lt;&gt;
  )
}</code></pre>
<p>你可以简单粗暴的的把需要导出为 <code>PDF</code> 的页面去除懒加载。这种方法唯一的优点是尽早的开始请求和加载页面，让用户能进行尽早的导出，尽少的等待。缺点是为了实现功能而牺牲了性能。如果懒加载带来的优化微乎其微，也可以接受。</p>
<p>但是在很多场景，懒加载非常重要，直接去除的代价会非常大。比如大数据平台的报表看板页面。一方面，服务测的大数据计算队列是非常宝贵的资源，默认全量加载，计算队列的消耗会随着用户数几何式增长。另一方面，大数据报表的前端渲染也比较复杂耗时，如果看板的报表数量较多，一次习惯加载会导致页面卡顿。</p>
<p>那么，在这些懒加载必要的场景下，我们只能在用户进行导出的时候，再进行全量加载。这样页面导出 <code>PDF</code> 就分三步：</p>
<ul>
<li>页面加载中</li>
<li>文件生成中</li>
<li>文件可下载</li>
</ul>
<p>在使用 <code>react-lazyload</code> 的情况下，可以通过重新设置 <code>offset</code> 参数，并触发容器 <code>scroll</code> 事件来进行全量加载：</p>
<pre><code class="language-javascript">import React, { useState, useEffect } from &#39;react&#39;;
import LazyLoad from &#39;react-lazyload&#39;;

const Demo = (height) =&gt; {
  const [offset, setOffset] = useState(100);

  useEffect(() =&gt; {
    const myEvent = new Event(&#39;scroll&#39;);
    document.body.dispatchEvent(myEvent);
  }, [offset])

  return (
    &lt;&gt;
      &lt;LazyLoad height={height} offset={100}&gt;
      &lt;Button onClick={ () =&gt; { setOffset(height) } }&gt;
        导出为PDF
      &lt;/Button&gt;
    &lt;&gt;
  )
}</code></pre>
<p>这种方案的缺点就是用户在点击导出以后，要等待页面的全量加载和<code>PDF</code>的生成，可能需要较长时间。我们可以通过以下两种方式来进行一些优化：</p>
<ul>
<li>前端侧：友好的提示用户导出的进展和进度。</li>
<li>服务测：用户在点击导出 <code>PDF</code> 以后，服务端生成一个任务来进行 <code>PDF</code> 的导出。这样，用户可以进行其他操作，等文件生成以后通过异步回调来提示用户进行文件下载。</li>
</ul>
<p>服务测的优化方式实现起来会比较复杂。如果服务端本身具备自动推送的功能，那么是可以复用自动推送的能力的。如果没有自动推送，前端侧优化性价比更高。</p>
<h2 id="巨量数据请求-amp-渲染"><a href="#巨量数据请求-amp-渲染" class="headerlink" title="巨量数据请求&amp;渲染"></a>巨量数据请求&amp;渲染</h2><p>巨量数据下，数据的请求和渲染都比较耗时。那么在看板导出的场景下，我们需要进行<strong>导出时机</strong>的判断。我们在导出的时候需要确保：</p>
<ul>
<li>数据请求都已返回。</li>
<li><code>DOM</code> 渲染已完成。</li>
<li>图表（<code>Canvas</code>）绘制已完成。</li>
</ul>
<blockquote>
<p>在巨量数据的情况下，<code>DOM</code> 渲染 和 <code>Canvas</code> 绘制 不能简单的通过在请求完成后，预留一点时间的方式来判断。</p>
</blockquote>
<p>那么，有没有一种全局的，与业务逻辑解耦的方式来来进行判断，比如监听方式。</p>
<h3 id="请求监听"><a href="#请求监听" class="headerlink" title="请求监听"></a>请求监听</h3><p>在前端侧，我没有找到全局解耦的进行请求监听的方式，服务测非常简单。比如 <code>Node</code> 环境的 <code>Puppeteer</code>就可以很方便的进行网络监听。</p>
<p>对于普通的的 <code>Http</code> 请求， 在 <code>Puppeteer</code> 中监听非常便利：</p>
<pre><code class="language-javascript">await page.goto(&#39;https://www.baidu.com&#39;, {
   timeout: 30 * 1000,
   waitUntil: [
       &#39;load&#39;,                             //等待 “load” 事件触发
       &#39;domcontentloaded&#39;,       //等待 “domcontentloaded” 事件触发
       &#39;networkidle0&#39;,               //在 500ms 内没有任何网络连接
       &#39;networkidle2&#39;               //在 500ms 内网络连接个数不超过 2 个
   ]
});</code></pre>
<p>但是上述方式不适用于 <code>webSocket</code> 请求。我们可以通过以下方式来监听 <code>webSocket</code> 请求的所有通信：</p>
<pre><code class="language-javascript">  const client = await page.target().createCDPSession();

  await client.send(&#39;Network.enable&#39;);

  client.on(&#39;Network.webSocketCreated&#39;, function (params) {   
    // console.log(`创建 WebSocket 连接：`)
  });
  client.on(&#39;Network.webSocketClosed&#39;,function (params) {
    // console.log(`关闭 WebSocket 连接`)
  });
  client.on(&#39;Network.webSocketWillSendHandshakeRequest&#39;,function (params) {
    // console.log(`发送 WebSocket 握手消息`)
  });

  client.on(&#39;Network.webSocketHandshakeResponseReceived&#39;,function (params) {
    // console.log(`收到 WebSocket 握手消息`)
  });

  client.on(&#39;Network.webSocketFrameSent&#39;, ( frame ) =&gt; {
    // console.log(`发送 WebSocket 请求`) 
  });

  client.on(&#39;Network.webSocketFrameReceived&#39;,function (frame) {
    // console.log(`收到 WebSocket 请求`) 
  );</code></pre>
<p>我们只需最后两种监听，就可以判断是否还存在未完成的 <code>websocket</code> 请求。</p>
<p>前面有提到，在前端侧我们并没有找到一种全局解耦的方式进行请求监听。但是对于页面导出为 <code>PDF</code> 这样的纯前端功能，需要前端来判断所有请求已完成。无法通过请求监听的方式，那只能通过记录所有请求的发送和回调这种请求判断的方式。</p>
<h3 id="DOM-监听"><a href="#DOM-监听" class="headerlink" title="DOM 监听"></a>DOM 监听</h3><p><code>DOM</code> 监听的运用和实践已经比较普遍，我们使用 <code>MutationObserver</code> 就可以。<code>MutationObserver</code> 主要用于监听 <code>DOM</code> 元素的一系列变化。如果一段时间内页面无任何<code>DOM</code> 变化，我们可以认为页面渲染已经完成。</p>
<pre><code class="language-javascript">/**
 * 监听 Dom 变化
 */
function domMutationObserver(resolve): void {
  observer = new MutationObserver(() =&gt; {
    // console.log(&#39;rendering...&#39;);
    observerHeadler(resolve);
  });

  observer.observe(document.body, {
    attributes: true,
    childList: true,
    subtree: true,
  });
}</code></pre>
<h3 id="Canvas监听"><a href="#Canvas监听" class="headerlink" title="Canvas监听"></a>Canvas监听</h3><p>我们都知道，<code>Canvas</code> 是通过 <code>JS</code> 绘制，所以图形不会反应在 <code>DOM</code> 结构中，没法通过 <code>DomMutationObserver</code> 来进行监听。但是要进行 <code>Canvas</code> 绘制，必然会一直掉用 <code>Canvas</code> 的各种 <code>API</code>。我们可以通过 <strong>数据劫持</strong> 的方式来监听这些 <code>API</code>。如果短时间内无任何相关 <code>API</code>的调用，我们可以认为 <code>Canvas</code> 绘制已经完成。</p>
<pre><code class="language-javascript">/**
 * 监听 canvas 绘制
 */
function canvasMutationObserver(resolve): void {
  const canvasProto = CanvasRenderingContext2D.prototype;
  const canvasProps = Object.getOwnPropertyNames(canvasProto);

  canvasProps.forEach((prop) =&gt; {
    const property = Object.getOwnPropertyDescriptor(canvasProto, prop);
    const getter = property &amp;&amp; property.get;

    /* 监听 canvas 属性（方法就不用不监听了）*/
    if (getter) {
      Object.defineProperty(canvasProto, prop, {
        get: function () {
          // console.log(&#39;drawing...&#39;);
          observerHeadler(resolve);
        },
      });
    }
  });
}
</code></pre>
<p>至此，我们可以通过导出时机的准确判断来导出一个懒加载的页面。</p>
<h1 id="差异化导出"><a href="#差异化导出" class="headerlink" title="差异化导出"></a>差异化导出</h1><p>在报表导出的时候，用户可能希望导出的 <code>PDF</code> 文件中隐藏一些不必要的元素（比如操作功能区），也可能希望额外显示一些重要的信息（比如 <code>hover</code> 到某元素上去才显示）。这是非常普遍又合理的。</p>
<p>首先，我觉得在页面交互设计上，应该尽量保证页面和导出的一致性，对于个别无法保证的差异点再通过编码处理。对于处理方式，需要分 前端导出 和 自动推送 两种场景来分析。</p>
<h2 id="前端导出"><a href="#前端导出" class="headerlink" title="前端导出"></a>前端导出</h2><p>对于前端导出的场景，用户导出的同时，还是能够看到页面。如何做到用户无感知的差异化导出比较重要。我们可以在导出时先微调，导出后再还原。但是这种用户可感知的方案非常奇怪。新开一个不可见的窗口二次渲染又非常耗时耗能。</p>
<p>好在，<code>html2canvas</code> 提供了一个非常好用的 <code>onclone</code> 钩子函数作为配置参数。该函数会在 <code>html2canvas</code> 已经解析获取到页面 <code>dom</code> 副本后，在生成<code>canvas</code> 前调用。我们只需要给隐藏的元素增加一个 <code>pdf_hidden</code> 标记。在页面新增默认隐藏的需要额外显示的信息，然后增加 <code>pdf_show</code> 标记。然后在 <code>onclone</code> 钩子函数中移除或隐藏带 <code>pdf_hidden</code> 标记的元素；显示带 <code>pdf_show</code> 标记的元素即可。</p>
<pre><code class="language-javascript">html2canvas(element, {
  ...options,
  onclone: (html) =&gt; {
    const needHide = html.getElementsByClassName(&#39;pdf_hidden&#39;);
    const needShow = html.getElementsByClassName(&#39;pdf_show&#39;);
    if (needHide) {
      Array.from(needHide).forEach((item) =&gt; {
        item.remove();
      });
    }
    if (needShow) {
      Array.from(needShow).forEach((item) =&gt; {
        item.setAttribute(&#39;style&#39;, &#39;display: block&#39;);
      });
    }
  },
}).then((canvas) =&gt; { });</code></pre>
<p><code>onclone</code> 钩子函数能处理很多问题。比如你页面的自定义图标( <code>SVG</code> )是使用 <code>&lt;symbol&gt;</code>元素来全局定义，然后在具体的 <code>&lt;svg/&gt;</code> 元素中使用 <code>&lt;use&gt;</code> 来引用的，那么你生成的 canvas 是看不到svg图标的。因为 html2canvas 是单独解析遇到的 <code>&lt;svg/&gt;</code> 元素的。这个时候，你就需要通过 <code>onclone</code> 钩子函数来做一些特殊处理，比如：</p>
<pre><code class="language-javascript">/**
 * svg 处理
 */
function svgDealwith(element): void {
  const svgs: Document[] = Array.from(element.getElementsByTagName(&#39;svg&#39;));
  svgs.forEach((svg) =&gt; {
    const use = svg.getElementsByTagName(&#39;use&#39;);
    if (use.length &gt; 0) {
      const fontId = use[0].getAttribute(&#39;xlink:href&#39;);
      if (fontId) {
        const path = document.getElementById(fontId.replace(&#39;#&#39;, &#39;&#39;)).cloneNode(true);
        svg.insertBefore(path, svg.firstChild);
        setTimeout(() =&gt; {
          svg.removeChild(svg.firstChild);
        }, 0);
      }
    }
  });
}</code></pre>
<h2 id="自动推送"><a href="#自动推送" class="headerlink" title="自动推送"></a>自动推送</h2><p>前面有提到，自动推送是后端通过无头浏览器进行页面的渲染和截屏的，是所见即所得的。如果存在导出差异，新做一个绝大部分内容一致的页面进行承载显然是不可取的。我们可以通过在原有页面增加参数来区分<strong>导出模式</strong>，然后在页面中根据是否是 <strong>导出模式</strong>，做一些差异化处理。</p>
<p>这无疑增加了页面的逻辑复杂度。开发得确保满足导出模式的差异化需求的同时，不影响页面的原有逻辑。我们能做的就是对差异化处理进行更好的抽象，做到尽量隔离。虽然我们没法在 <strong>导出模式</strong> 下，使用 <code>html2canvas</code> 的 <code>onclone</code> 钩子函数，但是可以复用前端导出时增加的 <code>pdf_hidden</code> 和 <code>pdf_show</code> 标记。导出模式是无头浏览器模式，不用考虑用户感知。我们只需要在页面加载以后，如果是<strong>导出模式</strong>就对带有 <code>pdf_hidden</code> 和 <code>pdf_show</code> 标记的元素进行相似处理即可。</p>
<p>比如在 <code>React hooks</code> 组件中，我们可以这样处理：</p>
<pre><code class="language-javascript">import React, { useEffect } from &#39;react&#39;;
// pageReady 页面渲染完成标识
const Demo = (pageReady) =&gt; {

  useEffect(() =&gt; {
    if (pageReady) {
      const needHide = html.getElementsByClassName(&#39;pdf_hidden&#39;);
      const needShow = html.getElementsByClassName(&#39;pdf_show&#39;);
      if (needHide) {
        Array.from(needHide).forEach((item) =&gt; {
          item.remove();
        });
      }
      if (needShow) {
        Array.from(needShow).forEach((item) =&gt; {
          item.setAttribute(&#39;style&#39;, &#39;display: block&#39;);
        });
      }
    }
  }, [pageReady])

  return (
    &lt;div&gt;
      &lt;div className=&quot;pdf_hidden&quot;&gt;hello&lt;div&gt;
       &lt;div className=&quot;pdf_show&quot; style={{display: 'none'}}&gt;world&lt;div&gt;
    &lt;div&gt;
  )
}</code></pre>
<h1 id="jspdf问题"><a href="#jspdf问题" class="headerlink" title="jspdf问题"></a>jspdf问题</h1><p>最后，给大家分享一个<code>jspdf</code>工具在使用中遇到的一个问题：页面报表非常多的情况下，导出的pdf文件丢失部分内容。原因是我们导出的 <code>PDF</code> 是单页的，这样效果较好。但是 <code>PDF</code> 单页有高度 <strong>14400</strong> 的限制。针对这种情况，我们对 <code>PDF</code> 的宽高进行等比压缩来处理。</p>
<pre><code class="language-javascript">while (h1 + h2 &gt; 14400) {
  w = Math.floor(w * 0.95);
  h1 = Math.floor(h1 * 0.95);
  h2 = Math.floor(h2 * 0.95);
}
const h = Math.max(w, h1 + h2);

const pdf = new jsPDF({
  orientation: &#39;p&#39;,
  unit: &#39;pt&#39;,
  format: [w, h],
});
</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<ul>
<li><a href="https://zhaoqize.github.io/puppeteer-api-zh_CN/#/" target="_blank" rel="noopener">https://zhaoqize.github.io/puppeteer-api-zh_CN/#/</a></li>
<li><a href="https://www.cnblogs.com/mingme/p/14013325.html" target="_blank" rel="noopener">https://www.cnblogs.com/mingme/p/14013325.html</a></li>
<li><a href="https://artskydj.github.io/jsPDF/docs/jsPDF.html" target="_blank" rel="noopener">https://artskydj.github.io/jsPDF/docs/jsPDF.html</a></li>
<li><a href="https://html2canvas.hertzen.com/configuration" target="_blank" rel="noopener">https://html2canvas.hertzen.com/configuration</a></li>
<li><a href="https://github.com/rrweb-io/rrweb" target="_blank" rel="noopener">https://github.com/rrweb-io/rrweb</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/09/06/koa%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/06/koa%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%8E%9F%E7%90%86/" itemprop="url">koa中间件原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-06T16:51:38+08:00">
                2021-09-06
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="中间件使用"><a href="#中间件使用" class="headerlink" title="中间件使用"></a>中间件使用</h1><p>通过 app.use 使用多个中间件：</p>
<pre><code class="language-js">const app = new Koa();

app.use(async (ctx, next) =&gt; {
 //...
 await next();
 //...
});

app.use(async (ctx, next) =&gt; {
 //...
 await next();
 //...
});

// 最后一个中间件不需要 next
app.use(async ctx =&gt; {
 ctx.body = &quot;Hello World&quot;;
});

//...
</code></pre>
<h1 id="中间件总体框架"><a href="#中间件总体框架" class="headerlink" title="中间件总体框架"></a>中间件总体框架</h1><p>中间件总体流程的核心代码如下：</p>
<pre><code class="language-js">class Application extends Emitter {
 constructor() {
  super();
  this.middleware = [];
 },

 use(fn) {
  this.middleware.push(fn);
  return this;
 },

 callback() {
  const fn = compose(this.middleware);

  return function(req, res) {
   return fn(ctx);
  };
 },

 listen(...args) {
  const server = http.createServer(this.callback());
  return server.listen(...args);
 }
}</code></pre>
<h1 id="核心-compose-方法实现"><a href="#核心-compose-方法实现" class="headerlink" title="核心 compose 方法实现"></a>核心 compose 方法实现</h1><pre><code class="language-js">function compose(middleware) {
 return function(context, next) {
  // last called middleware #
  let index = -1;
  return dispatch(0);

  function dispatch(i) {
   index = i;

   let fn = middleware[i];
   if (i === middleware.length) fn = next;
   if (!fn) return Promise.resolve();
   try {
    return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));
   } catch (err) {
    return Promise.reject(err);
   }
  }
 };
}
</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/09/01/JS%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/09/01/JS%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" itemprop="url">JS之正则表达式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-09-01T16:48:53+08:00">
                2021-09-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>在 <code>JavaScript</code> 中，正则表达式也是对象。用于匹配字符串中字符组合的模式。</p>
</blockquote>
<h1 id="如何创建"><a href="#如何创建" class="headerlink" title="如何创建"></a>如何创建</h1><hr>
<ul>
<li>字面量（常用）:  <code>Var regExp = /(^\s+)|(\s+$)/g</code></li>
<li><code>RegExp</code> 对象： <code>Var regExp = new RegExp(&quot;(^\s+)|(\s+$)&quot;, &quot;g&quot;)</code></li>
</ul>
<p>其中 <code>g</code> 表示全文匹配多次，与之相关的还有 <code>i</code> 和 <code>m</code>，<code>i</code> 表示匹配时忽略大小写，<code>m</code> 表示多行匹配，如果多个条件同时使用时，则写成：<code>gmi</code>。</p>
<h1 id="书写语法"><a href="#书写语法" class="headerlink" title="书写语法"></a>书写语法</h1><hr>
<ul>
<li><p>() : 的作用是提取匹配的字符串。表达式中有几个()就会得到几个相应的匹配字符串。比如 (\s+) 表示连续空格的字符串。 </p>
</li>
<li><p>[] : 是定义匹配的字符范围。比如 [a-zA-Z0-9] 表示字符文本要匹配英文字符和数字。 </p>
</li>
<li><p>{} : 一般用来表示匹配的长度，比如 \d{3} 表示匹配三个空格，\d[1,3]表示匹配1~3个空格。</p>
</li>
<li><p>^ :  匹配一个字符串的开头，比如 (^a) 就是匹配以字母a开头的字符串。^ 还有另个一个作用就是取反，比如[^xyz] 表示匹配的字符串不包含xyz</p>
</li>
<li><p>$ :  匹配一个字符串的结尾, 比如 (b$) 就是匹配以字母b结尾的字符串。</p>
</li>
<li><p>\d : 匹配一个非负整数， 等价于 [0-9] </p>
</li>
<li><p>\s : 匹配一个空白字符 </p>
</li>
<li><p>\w : 匹配一个英文字母或数字，等价于[0-9a-zA-Z]</p>
</li>
<li><p><code>*</code> : 表示匹配前面元素0次或多次，比如 (\s*) 就是匹配0个或多个空格 </p>
</li>
<li><p><code>+</code> : 表示匹配前面元素1次或多次，比如 (\d+) 就是匹配由至少1个整数组成的字符串 </p>
</li>
<li><p><code>?</code> : 表示匹配前面元素0次或1次，相当于{0,1} ，比如(\w?) 就是匹配最多由1个字母或数字组成的字符串</p>
</li>
</ul>
<h1 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h1><hr>
<ul>
<li>test: 用来检测字符串是否匹配某一个正则表达式，如果匹配就会返回true,反之则返回false</li>
<li>match: 获取正则匹配到的结果，以数组的形式返回</li>
</ul>
<pre><code class="language-js">/\d+/.test(&quot;123&quot;) ; //true
/\d+/.test(&quot;abc&quot;) ; //false

&quot;186a619b28&quot;.match(/\d+/g); // [&quot;186&quot;,&quot;619&quot;,&quot;28&quot;] </code></pre>
<ul>
<li><p><code>replace</code>: 字符串对象的一个方法，包含 2 个参数。</p>
<ul>
<li>第 1 个参数可以是一个普通的字符串或是一个<strong>正则表达式</strong>。</li>
<li>第 2 个参数可以是一个普通的字符串或是一个回调函数。</li>
</ul>
</li>
</ul>
<p>如果第1个参数是 RegExp, JS会先提取RegExp匹配出的结果，然后用第2个参数逐一替换匹配出的结果。</p>
<pre><code class="language-js">// 英文姓和名反转
var re = /(\w+)\s(\w+)/;
var str = &quot;John Smith&quot;;
var newstr = str.replace(re, &quot;$2, $1&quot;); // Smith, John

// 千分位
var str = &quot;1234567890&quot;;
str.replace(/\d{1,3}(?=(\d{3})+$)/g, function(match) {
    return match + &#39;,&#39;;
});</code></pre>
<blockquote>
<p>千分位详简：正则表达式/\d{1,3}(?=(\d{3})+$)/g中的\d表示匹配数字，{1,3}表示匹配1到3次，\d{1,3}表示匹配连续的1到3个数字，\d{3}匹配连续的三个数字，(?=)表示反向匹配，即为从后向前匹配，(?=(\d{3})+$)就表示从后向前三位数字一匹配，至少匹配一次，而最前面必须有1到3个数字，即第一次的\d{1,3}，最后的参数g表示全局匹配，匹配完所有。</p>
</blockquote>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://zhuanlan.zhihu.com/p/32179882" target="_blank" rel="noopener">JS正则replace</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/" itemprop="url">《ReactJS性能剖析》（译）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-07-06T19:05:30+08:00">
                2021-07-06
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/React/" itemprop="url" rel="index">
                    <span itemprop="name">React</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p><a href="https://addyosmani.com/blog/profiling-react-js/?utm_source=wechat_session&utm_medium=social&utm_oi=827853996734705664" target="_blank" rel="noopener">原文地址</a>。带<strong>补充</strong>标示的地方是翻译过程中拓展的知识点。</p>
</blockquote>
<p>今天，我们来看看如何使用 <code>React</code> 的 <code>Profiler API</code> 来测试 <code>React</code> 的渲染性能; 如何使用 <code>React</code> 实验性的 交互追踪 <code>API</code> 来追踪 <code>React</code> 的交互；如何使用 <code>Timing</code> <code>API</code> 来测量自定义指标。</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/react-movies-queue@2x.jpg" class="">

<p>为了方便演示，我们将使用一个展示电影列表的应用。</p>
<h1 id="React-Profiler-API"><a href="#React-Profiler-API" class="headerlink" title="React Profiler API"></a>React Profiler API</h1><hr>
<p><code>React</code> 提供的 <code>Profiler API</code> 用于测量 渲染和渲染成本，以帮助我们定位应用程序缓慢的瓶颈。</p>
<pre><code class="language-js">import React, { Fragment, unstable_Profiler as Profiler} from &quot;react&quot;;
</code></pre>
<p><code>Profiler</code> 使用 <code>onRender</code> 回调作为一个 <code>prop</code>，被分析的树中的组件每次提交更新时，这个回调都会被执行。</p>
<pre><code class="language-js">const Movies = ({ movies, addToQueue }) =&gt; (
  &lt;Fragment&gt;
    &lt;Profiler id=&quot;Movies&quot; onRender={callback}&gt;
</code></pre>
<p>为了测试，让我们试着使用 <code>Profiler</code> 来测量部分 <code>Movies</code> 组件的渲染时间。像这样：</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/ScreenShot1.jpg" class="">

<p><code>Profiler</code> 的 <code>onRender</code> 回调接收一些参数，用于描述渲染的内容和渲染时间。这些参数如下：</p>
<ul>
<li><code>id</code>: 提交更新的 <code>Profiler</code> 树的 “<code>id</code>“ 属性。</li>
<li><code>phase</code>: “<code>mount</code>“ (首次加载) 或 “<code>update</code>“ (重现渲染)</li>
<li><code>actualDuration</code>: 提交更新的渲染时间</li>
<li><code>baseDuration</code>: 没有记忆化（<code>memoization</code>）的情况下，渲染所有子节点的估时</li>
<li><code>startTime</code>: React 开始渲染的时间</li>
<li><code>commitTime</code>: React 完成渲染的时间</li>
<li><code>interactions</code>: 引发更新的具体交互</li>
</ul>
<blockquote>
<p>补充：<code>Memoization</code> 是一种将函数返回值缓存起来的空间换时间的方法。原理很简单，就是把函数的每次执行结果都放入一个键值对(数组也可以)中，在接下来的执行中，在键值对中如果有值，直接返回该值，没有才去执行函数体求值并缓存。现代 <code>JavaScript</code> 中经常使用这种技术。<code>React useMemo</code>就是通过 <code>memoization</code> 来提高性能的。</p>
</blockquote>
<pre><code class="language-js">
const callback = (id, phase, actualTime, baseTime, startTime, commitTime) =&gt; {
    console.log(`${id}&#39;s ${phase} phase:`);
    console.log(`Actual time: ${actualTime}`);
    console.log(`Base time: ${baseTime}`);
    console.log(`Start time: ${startTime}`);
    console.log(`Commit time: ${commitTime}`);
}
</code></pre>
<p>我们可以加载我们的页面，前往 <code>Chrome DevTools</code> 控制台，应该可以看到以下时间：</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/devtools-profiler@2x.jpg" class="">

<p>我们也可以打开 <code>React DevTools</code>，进入 <code>Profiler</code> 标签，直观地看到我们的组件的渲染时间。下面是火焰图的视图：</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/876878.jpg" class="">

<p>我也很喜欢使用 <code>Ranked</code> 视图，它是按顺序排列的，所以渲染时间最长的组件会显示在最上面。</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/ranked-view@2x.jpg" class="">

<p>你也可以使用多个 <code>Profilers</code> 来测量你的应用程序的不同部分。</p>
<pre><code class="language-js">
import React, { Fragment, unstable_Profiler as Profiler} from &quot;react&quot;;

render(
  &lt;App&gt;
    &lt;Profiler id=&quot;Header&quot; onRender={callback}&gt;
      &lt;Header {...props} /&gt;
    &lt;/Profiler&gt;
    &lt;Profiler id=&quot;Movies&quot; onRender={callback}&gt;
      &lt;Movies {...props} /&gt;
    &lt;/Profiler&gt;
  &lt;/App&gt;
);
</code></pre>
<blockquote>
<p>补充: <code>React devtools</code>  的 <code>Profiler</code> 功能 只支持 <code>React v16.5+</code> 构建的应用的追踪。因为 <code>React 16.5</code> 添加了对开发者工具的 <code>Profiler</code> 插件的支持。</p>
</blockquote>
<p>但是，如果你想进行交互追踪怎么办？</p>
<h1 id="交互追踪-API"><a href="#交互追踪-API" class="headerlink" title="交互追踪 API"></a>交互追踪 API</h1><hr>
<p>如果我们能够追踪交互（例如点击用户界面），以回答 “这个按钮的点击需要多长时间来更新DOM？”这样的问题，那将是非常强大的。感谢<code>Brian Vaughn</code>，<code>React</code> 通过新的 <a href="https://www.npmjs.com/package/scheduler" target="_blank" rel="noopener"><code>scheduler</code></a>包中的交互追踪 <code>API</code> 对交互追踪提供了实验性支持。<a href="https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16" target="_blank" rel="noopener">这里</a>有更详细的记录。</p>
<p>交互被注释为一个描述（例如 “点击添加到购物车按钮”）和一个时间戳。交互也应该提供一个回调，在那里你可以做与交互有关的工作。</p>
<p>在我们的 “<code>Movies</code>“ 应用程序中，我们有一个 “将电影添加到队列 “ 按钮（”+”）。点击这个按钮将电影添加到你的观看队列中。</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/ScreenShot2.jpg" class="">

<p>下面是一个追踪这种交互的状态更新的例子。</p>
<pre><code class="language-js">import { unstable_Profiler as Profiler } from &quot;react&quot;;
import { render } from &quot;react-dom&quot;;
import { unstable_trace as trace } from &quot;scheduler/tracing&quot;;

class MyComponent extends Component {
  addMovieButtonClick = event =&gt; {
    trace(&quot;Add To Movies Queue click&quot;, performance.now(), () =&gt; {
      this.setState({ itemAddedToQueue: true });
    });
  };
}</code></pre>
<p>我们可以记录这种交互，并在 <code>React DevTools</code> 中看到它的持续时间：</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/4324242.jpg" class="">

<p>我们也可以使用交互追踪API来追踪初始渲染，如下所示：</p>
<pre><code class="language-js">import { unstable_trace as trace } from &quot;scheduler/tracing&quot;;

trace(&quot;initial render&quot;, performance.now(), () =&gt; {
   ReactDom.render(&lt;App /&gt;, document.getElementById(&quot;app&quot;));
});</code></pre>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/interaction@2x.jpg" class="">

<p><code>Brian</code>在他的 <code>React gist</code> 中涵盖了更多的交互追踪的例子，比如如何追踪异步交互。</p>
<blockquote>
<p>补充：<code>Github</code> 提供了一个非常有用的服务 <code>Gist</code>。开发人员可以使用 <code>Gist</code> 记录他们的代码片段，但是 <code>Gist</code> 不仅仅是为极客和码农开发的，每个人都可以用到它。</p>
</blockquote>
<h1 id="Puppeteer"><a href="#Puppeteer" class="headerlink" title="Puppeteer"></a>Puppeteer</h1><p>对于更深入的 UI 交互脚本跟踪，您可能会对 <code>Puppeteer</code> 感兴趣。<code>Puppeteer</code> 是一个 <code>Node</code> 库，它提供了一系列 高级 <code>API</code>，用于通过 <code>DevTools</code> 协议控制 <strong>无头 <code>Chrome</code> 浏览器</strong>。</p>
<p>它暴露了 <code>trace.start()/stop()</code> 助手，用于捕获 <code>DevTools</code> 的性能追踪情况。下面，我们使用它来跟踪单击主按钮时发生的情况：</p>
<pre><code class="language-js">const puppeteer = require(&#39;puppeteer&#39;);

(async () =&gt; {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  const navigationPromise = page.waitForNavigation();
  await page.goto(&#39;https://react-movies-queue.glitch.me/&#39;)
  await page.setViewport({ width: 1276, height: 689 });
  await navigationPromise;

  const addMovieToQueueBtn = &#39;li:nth-child(3) &gt; .card &gt; .card__info &gt; div &gt; .button&#39;;
  await page.waitForSelector(addMovieToQueueBtn);

  // Begin profiling...
  await page.tracing.start({ path: &#39;profile.json&#39; });
  // Click the button
  await page.click(addMovieToQueueBtn);
  // Stop profliling
  await page.tracing.stop();

  await browser.close();
})()</code></pre>
<p>加载 <code>profile.json</code> 到 <code>DevTools</code> 的 <code>Performance</code> 面板中，我们可以看到点击按钮后的所有 <code>JavaScript</code> 函数调用:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/trace@3x.jpg" class="">

<p>如果你有兴趣阅读更多关于这个主题的内容，请查看 <code>Stoyan Stefanov</code> 的文章 <a href="https://calendar.perfplanet.com/2019/javascript-component-level-cpu-costs/" target="_blank" rel="noopener">JavaScript组件级CPU成本</a>。</p>
<h1 id="User-Timing-API"><a href="#User-Timing-API" class="headerlink" title="User Timing API"></a>User Timing API</h1><hr>
<p><code>User Timing</code> <code>API</code>允许使用 高精度时间戳 为应用程序度量自定义性能指标。<code>Window.performance.mark()</code> 存储具有关联名称的时间戳，而 <code>window.performance.measure()</code> 存储两个标记之间经过的时间。</p>
<pre><code class="language-js">// Record the time before running a task
performance.mark(&#39;Movies:updateStart&#39;);
// Do some work

// Record the time after running a task
performance.mark(&#39;Movies:updateEnd&#39;);

// Measure the difference between the start and end of the task
performance.measure(&#39;moviesRender&#39;, &#39;Movies:updateStart&#39;, &#39;Movies:updateEnd&#39;);</code></pre>
<p>在使用 <code>Chrome DevTools</code> 的 <code>Performance</code> 面板分析 <code>React</code> 应用程序时，你会发现一个名为 “<code>Timings</code>” 的部分，里面包含了你的 <code>React</code> 组件的处理时间。在渲染时，<code>React</code> 能够通过 <code>User Timing API</code> 发布该信息。</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/timings@2x.jpg" class="">

<p>注意: <code>React</code> 正在从他们的 <code>DEV</code> 包中移除 <code>User Timing</code>，以支持 <code>React Profiler</code>，后者提供了更准确的计时。他们可能会在未来的3级浏览器中重新添加 <code>User Timing</code>。</p>
<p>纵观整个 <code>web</code>，你会发现 <code>React</code> 应用利用 <code>User Timing</code> 来定义自己的定制指标。其中包括 <code>Reddit</code> 的“<code>Time to first post title visible</code>” 和 <code>Spotify</code> 的 “<code>Time to playback ready</code>“:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/timings@3x.jpg" class="">

<blockquote>
<p>补充：<code>Spotify</code> 是世界上最大的音乐流媒体服务。<code>Reddit</code>是个社交新闻站点。</p>
</blockquote>
<p>自定义的 <code>User Timing</code> 标记和度量也可以清晰的反映在 <code>Chrome DevTools</code> 的 <a href="https://developers.google.com/web/tools/lighthouse/" target="_blank" rel="noopener"><code>Lighthouse</code>面板</a>:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/ScreenShot3.jpg" class="">

<p>最近版本的 <code>Next.js</code> 还为一些事件添加了更多的 <code>User Timing</code> 标记和度量，包括:</p>
<ul>
<li><strong>Next.js-hydration</strong>：hydration 时间。</li>
<li><strong>Next.js-nav-to-render</strong>：导航开始,直到呈现之前。</li>
</ul>
<p>所有这些度量都将出现在 <code>Timings</code> 区域:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/nextjs@2x.jpg" class="">

<h1 id="DevTools-amp-Lighthouse"><a href="#DevTools-amp-Lighthouse" class="headerlink" title="DevTools &amp; Lighthouse"></a>DevTools &amp; Lighthouse</h1><hr>
<p>提醒一下, <a href="https://developers.google.com/web/tools/lighthouse" target="_blank" rel="noopener">Lighthouse</a>和<a href="https://developers.google.com/web/tools/chrome-devtools/evaluate-performance" target="_blank" rel="noopener">DevTools Performance panel 面板</a> 可用于深入分析 <code>React</code> 应用程序的加载和运行时性能, 突出关键以用户为中心的幸福指标:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/lighthouse-cli@2x.jpg" class="">

<p><code>React</code> 用户可能会喜欢像<a href="https://web.dev/tbt/" target="_blank" rel="noopener"><code>Total Blocking Time</code></a> (<code>TBT</code>)这样的新指标，它可以衡量一个页面从最初的不可响应变得具有可靠的响应性(<a href="https://web.dev/tti/" target="_blank" rel="noopener">Time to Interactive</a>)的过程。下面我们可以看到使用 <code>Concurrent</code> 模式前后，<code>TBT</code>的情况:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/concurrent-mode@2x.jpg" class="">

<blockquote>
<p>补充：<code>Concurrent</code> 模式是一组 <code>React</code> 的新功能，可帮助应用保持响应，并根据用户的设备性能和网速进行适当的调整。</p>
</blockquote>
<p>这些工具通常有助于获得浏览器级的瓶颈视图，如延迟响应的繁重<a href="https://web.dev/long-tasks-devtools/" target="_blank" rel="noopener">长任务</a>(如按钮单击响应)，如下所示:</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/long-tasks@2x.jpg" class="">

<p><code>Lighthouse</code> 还提供了一些 <code>React</code> 特定的的审记指引。在 <code>Lighthouse 6.0</code> 中，您将看到一个<a href="https://web.dev/remove-unused-code/" target="_blank" rel="noopener"> remove unused JavaScript audit </a>的审记，高亮提示可以使用 <code>React.lazy()</code> 动态引入这些已加载但未使用的 <code>JavaScript</code>。</p>
<img src="/2021/07/06/ReactJS%E6%80%A7%E8%83%BD%E5%89%96%E6%9E%90/ScreenShot4.jpg" class="">

<p>这总比在真实用户的硬件上对性能进行体检要好。我经常依靠<a href="https://addyosmani.com/blog/profiling-react-js/webpagetest.org/easy" target="_blank" rel="noopener">webpagetest.org/easy</a>和来自<a href="https://web.dev/user-centric-performance-metrics/#in-the-field" target="_blank" rel="noopener">RUM</a>和<a href="https://web.dev/chrome-ux-report/" target="_blank" rel="noopener">CrUX</a>的现场数据来描绘一个更完整的画面。</p>
<h1 id="Read-more"><a href="#Read-more" class="headerlink" title="Read more"></a>Read more</h1><hr>
<ul>
<li><a href="https://reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html" target="_blank" rel="noopener">Introducing the React Profiler</a></li>
<li><a href="https://gist.github.com/bvaughn/60a883af01716a03a1b3285a1029be0c" target="_blank" rel="noopener">The React Profiler on-going notes</a></li>
<li><a href="https://gist.github.com/bvaughn/25e6233aeb1b4f0cdb8d8366e54a3977" target="_blank" rel="noopener">How to use Profiler in production with react-dom</a></li>
<li><a href="https://gist.github.com/bvaughn/8de925562903afd2e7a12554adcdda16" target="_blank" rel="noopener">Interaction tracing with React</a></li>
<li><a href="https://www.debugbear.com/blog/measuring-react-app-performance" target="_blank" rel="noopener">Measuring React app performance</a></li>
<li><a href="https://houssein.me/progressive-react" target="_blank" rel="noopener">Progressive React</a></li>
<li><a href="https://web.dev/custom-metrics/" target="_blank" rel="noopener">Measuring Custom metrics</a></li>
</ul>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/04/07/HeadlessCMS%E5%92%8CJamstack/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/04/07/HeadlessCMS%E5%92%8CJamstack/" itemprop="url">Headless CMS & JAMStack</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-04-07T15:44:33+08:00">
                2021-04-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是CMS"><a href="#什么是CMS" class="headerlink" title="什么是CMS"></a>什么是CMS</h1><hr>
<p><code>CMS</code>是 <code>Content Management System</code> 的缩写，意为 <code>内容管理系统</code>。 是一个完整的信息组织和管理的体系。它对同一类型的信息进行分类，且每一类信息都可以进行增删改查操作。此外，又采用了统一的用户和权限管理对信息的使用进行控制。内容管理系统普遍用于企业信息化建设和电子政务。</p>
<p>传统的 <code>CMS</code> 是将内容存储在数据库中，并使用一组<a href="http://restful.p2hp.com/" target="_blank" rel="noopener">Restful API</a>，和对应的一组基于<code>html</code>的 <strong>模板文件</strong> 来管理内容呈现的管理信息系统，比如 <code>WordPress</code>。</p>
<blockquote>
<p><a href="https://cn.wordpress.org/" target="_blank" rel="noopener"><code>WordPress</code></a>是一个开源的 <code>CMS</code>，允许用户构建 动态网站 和 博客。<code>WordPress</code>是网络上非常流行的博客系统，可以通过其后台管理系统，进行内容更新，自定义和管理网站。</p>
</blockquote>
<h1 id="什么是-Headless-CMS"><a href="#什么是-Headless-CMS" class="headerlink" title="什么是 Headless CMS"></a>什么是 Headless CMS</h1><hr>
<p>简单地说，<code>Headless CMS</code>(后面简称<code>HCMS</code>)是一种内容与表现形式分离的<code>CMS</code>。</p>
<p><code>HCMS</code> 通过 <code>API</code>提供结构化数据（如 <code>JSON</code>，无样式的<code>XML</code>）给开发者，开发者负责通过其他技术将内容展示在网站或者客户端等独立系统中。内容创建者仍然可以使用一个编辑接口(<code>editing interface</code>) 修改 <code>HCMS</code> 内容。</p>
<p>传统的 <code>CMS</code> 前端(您在浏览器中看到的)和后端(数据库和软件层)是紧密耦合的。内容和它的呈现方式在同一套代码体系中。而 <code>HCMS</code> 负责内容管理，与显示内容的前端是分离的。即 <code>HCMS</code> 只输出 <code>API</code> ，不输出页面，这样可以让开发者能够用最好的技术来建立优越的用户体验。</p>
<p>当你的内容是可用的结构化数据，任何客户端或应用程序(无论是<code>JAMStack</code>应用程序还是移动设备)都可以使用它。比如，你可以使用 <code>HCMS</code> 为 <code>Gatsby</code> 站点和其他内容通道提供<code>JSON</code>内容源。</p>
<blockquote>
<p><code>GatsbyJs</code> 是一个现代化的网站构建系统，拥有完整、丰富且开源的生态圈。它利用 <code>react</code> + <code>GraphQL</code> 产出多页面应用。通过插件，<code>Gatsby</code>可支持多种 <code>HCMS</code>服务，比如<code>Contentful</code>、<code>Ghost</code>和<code>Prismic</code>。<br>如果你使用<code>WordPress</code>，也没有必要切换。你可以使用 <code>WordPress</code> 的 <code>REST API</code> 作为 <code>HCMS</code> 服务，这样你就可以继续使用已经熟悉的 <code>WordPress</code> 编辑工具进行内容编辑。</p>
</blockquote>
<h1 id="什么是-JAMStack"><a href="#什么是-JAMStack" class="headerlink" title="什么是 JAMStack"></a>什么是 JAMStack</h1><hr>
<p>既然 <code>HCMS</code> 只负责内容管理，那么前端便需要一套与之契合的 架构体系 来完成显示之责，这便是 <code>JAMStack</code> 。</p>
<p><code>JAMStack</code> 是指使用<code>JavaScript</code>、<code>API</code>和<code>Markup</code>构建的技术堆栈，<code>JAM</code>是<code>JavaScript</code>、<code>API</code>和<code>Markup</code>的简称，<code>JAMstack</code>一种基于客户端<code>JavaScript</code>，可重用<code>API</code>和预构建<code>Markup</code>的现代<code>Web</code>开发架构，需要符合下面三个标准：</p>
<ul>
<li><code>JavaScript</code>：请求/响应周期中的任何动态编程都由<code>JavaScript</code>处理，完全在客户端上运行。这可以是任何前端框架/库，甚至是轻量<code>JavaScript</code>。</li>
<li><code>API</code>：所有服务器端进程或数据库操作都被抽象为可重用的<code>API</code>，使用<code>JavaScript</code>通过<code>HTTPS</code>访问。这些可以是定制的或利用第三方服务。</li>
<li><code>Markup</code>：模板化标记应该在部署时预先构建，通常使用内容站点的站点生成器或<code>Web</code>应用程序的构建工具。</li>
</ul>
<p><code>JAMStack</code> <strong>核心原则</strong>是 <strong>预渲染</strong> 和 <strong>解耦</strong>。</p>
<ul>
<li><p>预渲染(<code>pre-rendering</code>)： 通过 <code>JAMStack</code>，整个前端在构建过程中被预构建成高度优化的静态页面和资源。</p>
<ul>
<li>这意味着，你甚至可以跳过<code>web</code>服务器，选择 对象存储服务(<code>OSS</code>) 和 内容分发网络 (<code>CDN</code>) 托管你的站点。</li>
<li>目前已经有很多流行的 静态站点生成器（<code>Static Site Generation</code> 简称 <code>SSG</code>），比如<code>NextJS</code>、<code>Gatsby</code>、<code>Hugo</code>、<code>Jekyll</code>、<code>Eleventy</code>等。</li>
</ul>
</li>
<li><p>解耦(<code>decoupling</code>)：与服务端分离。不需要使用 数据库 或 服务器端编程语言。</p>
<ul>
<li>与之对应的后端服务是一系列返回<code>JSON</code>或<code>XML</code>内容的 <code>API</code>。这个 <code>API</code>可以是托管的 数据存储、<code>HCMS</code> 或 自定义应用程序。</li>
<li><code>JAMStack</code> 站点可以在构建时使用这些服务，也可以在运行时通过 <code>JavaScript</code> 直接从浏览器使用这些服务。</li>
<li><a href="https://github.com/stackbit/sourcebit" target="_blank" rel="noopener"><code>Sourcebit</code></a> 通过从任何第三方资源中提取数据来帮助开发人员构建数据驱动的<code>JAMstack</code>站点。</li>
</ul>
</li>
</ul>
<p>很明显，<code>JAMStack</code> 和 <code>HCMS</code> 是高度契合的。</p>
<blockquote>
<p>对象存储服务（<code>Object Storage Service，OSS</code>）是一种海量、安全、低成本、高可靠的云存储服务，适合存放任意类型的文件。</p>
</blockquote>
<h1 id="JAMStack-优势"><a href="#JAMStack-优势" class="headerlink" title="JAMStack 优势"></a>JAMStack 优势</h1><hr>
<ul>
<li><p>速度: 没有数据库层 和 软件服务层导致的开销。因此，它们的渲染和加载速度比传统的一体化架构的站点更快。</p>
</li>
<li><p>托管灵活性: 由于是 静态文件，<code>JAMStack</code>站点可以托管在任何地方。您可以使用传统的 <code>web</code>服务器软件，如<code>Apache</code>或<code>Nginx</code>。为了获得最佳的性能和安全性，您可以使用 <code>OSS</code> 和 <code>CDN</code>，如<code>Netlify</code>、<code>Render</code>或<code>AWS</code>的 <code>S3</code>和 <code>Cloudfront</code>。</p>
</li>
<li><p>更好的开发体验: 前端开发人员无需了解 服务器端语言 就可以构建站点。后端开发人员可以专注于<code>Api</code>构建。解耦的开发团队可以并行工作，允许每个团队专注于他们最擅长的工作。使用第三方<code>CMS</code>服务还意味着你的开发-运营团队不必管理单独的内容栈。</p>
</li>
<li><p>更好的安全性: 没有数据库和软件层意味着 <code>JAMStack</code> 站点不容易受到 <code>SQL</code> 注入或 服务器端代码注入攻击。页面是预构建(<code>pre-build</code>)的，因此不会面临服务器端包含注入攻击的风险。在<code>CDN</code>上托管站点可以免受服务攻击。</p>
</li>
</ul>
<h1 id="JAMStack-最佳实践"><a href="#JAMStack-最佳实践" class="headerlink" title="JAMStack 最佳实践"></a>JAMStack 最佳实践</h1><hr>
<ul>
<li><p>整个项目放<code>CDN</code>上</p>
<ul>
<li>因为<code>JAMStack</code>项目不依赖服务器端代码，所以它们可以分布式而不是生活在单一服务器上。直接放<code>CDN</code>上提供服务，可以释放出无可匹敌的速度和性能。带来更好的用户体验。</li>
</ul>
</li>
<li><p>使用现代构建工具</p>
<ul>
<li>利用现代构建工具的生态圈。这是一个快速发展的空间，你会希望今天能够使用明天的<code>Web</code>标准，而不是等待明天的浏览器。比如目前用到的 <code>Babel</code>、<code>PostCSS</code>、<code>Webpack</code>。</li>
</ul>
</li>
<li><p>自动构建</p>
<ul>
<li>因为<code>JAMStack</code> 的 <code>markup</code> 是预构建的，所以在你运行另一个构建之前，内容更改不会上线。将这个过程自动化会减少挫败感。你可以使用<code>webhooks</code>自己来完成，或者使用包含 自动服务 的发布平台。</li>
</ul>
</li>
<li><p>原子部署</p>
<ul>
<li>当 <code>JAMStack</code> 项目发展到足够大大，新的改变可能需要重新部署数百个文件。一次性上传这些文件这一进程完成前，会造成信息不一致的状态。你可以使用一个允许你进行 “原子部署(<code>Atomic Deploys</code>) “ 的系统来避免这种情况，在这个系统中，在所有更改的文件被上传之前，任何更改都不会上线。</li>
</ul>
</li>
<li><p>即时缓存失效</p>
<ul>
<li>当从构建到部署的周期成为一种常态时，你需要明白，当部署上线时，就真的在线上了。需要确保你的 <code>CDN</code> 做好 即时缓存失效 处理。</li>
</ul>
</li>
<li><p>一切尽在 <code>Git</code>中</p>
<ul>
<li>有了<code>JAMStack</code>项目，任何人都应该能够进行<code>git</code>克隆，用标准的程序（比如<code>npm install</code>）安装所需的依赖项，然后就可以在本地运行整个项目。无需克隆数据库，无需复杂的安装。这减少了贡献者的摩擦，也简化了测试工作流程。</li>
</ul>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><code>Jamstack</code> 本质是一种增强的静态网站，它的出现很大程度上得益于各大云厂商提供的云上能力，包括更容易管控的 <code>CDN/DNS</code>、<code>Serverless Function</code>、<code>DevOps</code> 工具等等。</p>
<p><code>Jamstack</code> 适合一些内容更新不太频繁的网站（比如新闻、电商、文档）。它不适合论坛，聊天室，金融信息……等高度动态化的网站。目前最大用用武之地还是在 <code>HCMS</code>， <code>Headless Commerce</code>（无头电商）这类领域。</p>
<h1 id="参考-amp-拓展资料"><a href="#参考-amp-拓展资料" class="headerlink" title="参考&amp;拓展资料"></a>参考&amp;拓展资料</h1><hr>
<p><a href="https://www.gatsbyjs.cn/docs/glossary/headless-cms/" target="_blank" rel="noopener">gatsbyJs文档</a><br><a href="https://www.gatsbyjs.cn/" target="_blank" rel="noopener">gatsbyJs官网</a><br><a href="https://www.gatsbyjs.com/plugins" target="_blank" rel="noopener">gatsbyJs plugins Library</a><br><a href="https://jamstack.com/" target="_blank" rel="noopener">JAMStack</a><br><a href="https://graphql.cn/" target="_blank" rel="noopener">GraphQL官网</a><br><a href="https://blog.csdn.net/Chad97/article/details/104030298" target="_blank" rel="noopener">Gatsby精粹，面向未来的blog</a><br><a href="https://vercel.com/blog/nextjs-server-side-rendering-vs-static-generation" target="_blank" rel="noopener">Next.js: Server-side Rendering vs. Static Generation</a><br><a href="https://www.stackbit.com/blog/jamstack-nextjs-sourcebit/" target="_blank" rel="noopener">Bringing Next.js to the JAMstack</a><a href="https://cloud.tencent.com/developer/article/1439913" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1439913</a>)<br><a href="https://zhuanlan.zhihu.com/p/281085404" target="_blank" rel="noopener">Jamstack，下一代Web建站技术栈？</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/03/30/JS%E4%B9%8B%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/30/JS%E4%B9%8B%E9%98%B2%E6%8A%96%E8%8A%82%E6%B5%81/" itemprop="url">JS之防抖节流</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-30T18:11:45+08:00">
                2021-03-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是防抖"><a href="#什么是防抖" class="headerlink" title="什么是防抖"></a>什么是防抖</h1><hr>
<p><strong>防抖</strong> (<code>debounce</code>)，顾名思义就是防止抖动。一些高频触发的事件（ 如：<code>resize</code>、<code>scroll</code>、<code>mousemove</code>…… ）会导致事件处理函数高频执行。如果事件处理函数还操作<code>DOM</code>，那就意味着会引发高频的渲染重绘或回流。极端情况下，就会看到明显的页面/元素抖动。</p>
<p>所以，防抖就是防止高频的 <code>DOM</code> 操作导致页面频繁的渲染。</p>
<p>现代浏览器内核针对这种情况，内部进行了优化：会设置一个时间阀值，把这个时间内的 <code>DOM</code> 改变合并渲染。即便如此，我们在实际的项目中也要做好防抖，尽量为内核减负。</p>
<h1 id="什么是节流"><a href="#什么是节流" class="headerlink" title="什么是节流"></a>什么是节流</h1><hr>
<p><strong>节流</strong> (<code>throttle</code>)，顾名思义就是节约流量（流量是网络世界宝贵的资源，<code>web</code> 又是流量的主要入口之一）。广义上也可以衍生为节约资源，这里的资源主要包括我们宝贵的浏览器内核资源。</p>
<p>所以，节流就是要避免不必要的网络请求，避免不必要的 <code>js</code>执行和页面渲染。</p>
<p>明显，广义上的节流是包含防抖的，只是，防抖和节流在具体实现上是有差异的。</p>
<h1 id="防抖和节流的区别"><a href="#防抖和节流的区别" class="headerlink" title="防抖和节流的区别"></a>防抖和节流的区别</h1><hr>
<p>防抖和节流都需要设置一个<code>时长</code>。</p>
<ul>
<li><p>防抖：延时执行，并且<code>时长</code>内没有重复触发才会执行，否则重新计时。所以，最后（最新）一次事件必定响应。典型场景有：</p>
<ul>
<li>页面缩放（ <code>resize</code> ）: 页面缩放的时候，动态调整某些元素的大小。典型的防抖场景。</li>
<li>搜索框联想（ <code>change</code> ）: 连续输入，触发多次搜索。一方面浪费资源，另一方面，如果先联想的结果后返回，那么显示就不是最新匹配的。</li>
<li>文本编辑器（ <code>change</code> ）: 实时保存的文本编辑器。问题同上。</li>
</ul>
</li>
<li><p>节流：高频事件在 <code>时长</code> 内处理一次即可，一般是这段时间的第一次。典型场景有：</p>
<ul>
<li>元素拖拽/缩放（ <code>mousedown/mousemove</code> ）: 需要实时显示元素的位置/大小，但是频率也无需和事件触发频率一致。</li>
<li>提交按钮（ <code>click</code> ）: 会发起网络请求的点击按钮。遇到暴力点击，不光有重复提交的问题，还会导致流量和浏览器内部资源大大浪费。</li>
</ul>
</li>
</ul>
<blockquote>
<p>根据实际场景的需求来选择 防抖 还是 节流 。比如 <strong>元素拖拽/缩放</strong>，如果需求不要求过程只追求结果，就应该选择 防抖。</p>
</blockquote>
<p>明显，我们可以通过<strong>时间戳</strong>，<strong>定时器</strong>来控制。下面，我们来看看防抖节流如何具体实现。</p>
<h1 id="防抖函数"><a href="#防抖函数" class="headerlink" title="防抖函数"></a>防抖函数</h1><hr>
<p>防抖的关键在于<strong>延迟执行</strong>，所以推荐使用<strong>定时器</strong>。</p>
<ul>
<li><strong>基础版</strong>: 延迟 <code>ms</code> 毫秒执行，在这期间的其他重复请求不执行。</li>
</ul>
<pre><code class="language-js">function debounce(func, ms) {
  let timeout;
  return function () {
      const context = this;
      const args = arguments;
      clearTimeout(timeout)
      timeout = setTimeout(function(){
        func.apply(context, args)
      }, ms);
  }
}
window.onmousemove = debouce(()=&gt; console.log(1), 1000);</code></pre>
<ul>
<li><strong>进阶版</strong>：+ 首次请求立即执行。</li>
</ul>
<pre><code class="language-js">function debounce(func, ms, immediate) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (timeout) clearTimeout(timeout);
    if (immediate) {
      const callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, ms)
      if (callNow) func.apply(context, args)
    } else {
      timeout = setTimeout(function () {
        func.apply(context, args)
      }, ms);
    }
  }
}</code></pre>
<h1 id="节流函数"><a href="#节流函数" class="headerlink" title="节流函数"></a>节流函数</h1><hr>
<p>节流的关键在于控制一段时间内只执行一次，所以时间戳和定时器都可以。区别是时间戳版触发是在时间段内开始的时候，而定时器版触发是在时间段内结束的时候。</p>
<ul>
<li><strong>定时器版</strong>：每<code>ms</code> 毫秒只执行一次。</li>
</ul>
<pre><code class="language-js">
function throttle(func, wait) {
  let timeout;
  return function () {
    const context = this;
    const args = arguments;
    if (!timeout) {
      timeout = setTimeout(function () {
        timeout = null;
        func.apply(context, args)
      }, wait)
    }

  }
}
</code></pre>
<ul>
<li><strong>时间戳版</strong>：每<code>ms</code> 毫秒只执行一次。</li>
</ul>
<pre><code class="language-js">
function throttle(func, wait) {
    var previous = 0;
    return function () {
      var now = Date.now();
      var context = this;
      var args = arguments;
      if (now - previous &gt; wait) {
        func.apply(context, args);
        previous = now;
      }
    }
}
</code></pre>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<p><a href="https://www.jianshu.com/p/566c66aafa22" target="_blank" rel="noopener">节流（throttle）与防抖（debounce）</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/03/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/19/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86/" itemprop="url">浏览器渲染原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-19T17:24:34+08:00">
                2021-03-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><hr>
<ul>
<li><p>我们知道，<code>应用程序</code>能够运行，是需要占用<code>计算机资源</code>的。</p>
</li>
<li><p>为了稳定的<code>并行</code>多个应用程序，计算机必须得做好资源的合理分配和管理，这是<code>操作系统</code>的基本职责。</p>
</li>
<li><p><code>进程</code> 便是操作系统进行 <code>资源分配</code> 的 <code>基本单位</code>，是 应用程序 的载体。 </p>
</li>
<li><p>一个应用程序，又可以是 <code>多进程</code> 设计， 比如 <code>现代浏览器</code>。</p>
</li>
</ul>
<h1 id="现代浏览器是多进程的"><a href="#现代浏览器是多进程的" class="headerlink" title="现代浏览器是多进程的"></a>现代浏览器是多进程的</h1><hr>
<p>在应用程序中，为了满足功能的需要，主进程会创新新的辅助进程来处理其他任务。这些辅助进程拥有全新的独立的内存空间。如果一个应用程序的这些进程需要通信，可以通过<code>IPC (Inter process Communication )</code>机制来进行。</p>
<p>我们都知道，<code>现代浏览器</code> 都支持多 <code>tab</code> ，一个 <code>tab</code> 对应一个 网页，其实也对应一个网页进程。进程之间互相独立的这种<strong>互不影响性</strong> 就保证了一个网页的奔溃，不会影响其他网页。当然，如果主进程奔溃，就会影响所有网页了。</p>
<p>不同的浏览器使用不同的架构，下面主要以<code>Chrome</code>为例，主要有 4 个进程：</p>
<p><strong>浏览器主进程(<code>Browser Process</code>)</strong>： 负责协调、主控，有且只有一个。</p>
<ul>
<li>负责 浏览器界面与用户交互。如前进，后退等;</li>
<li>负责各个<code>tab</code>页面的管理，创建和销毁;</li>
<li>网络资源下载，文件访问等。</li>
</ul>
<p><strong>渲染进程(<code>Render Process</code>)</strong>：也称 <strong>渲染引擎</strong>，也是我们常说的 <strong>浏览器内核</strong>。</p>
<ul>
<li>负责 页面渲染，脚本执行，事件处理等</li>
<li>它是 <code>多线程</code>的。</li>
</ul>
<p><strong>插件进程(<code>Plugin Process</code>)</strong>：负责控制网页使用到的插件。</p>
<ul>
<li>每种插件对应一个进程，仅当使用该插件时才创建。</li>
</ul>
<p><strong>GPU进程(<code>GPU process</code>)</strong>：负责所有显示任务。</p>
<ul>
<li>最多一个，用于 <code>3D</code> 绘制和硬件加速。</li>
</ul>
<h1 id="多进程架构的好处"><a href="#多进程架构的好处" class="headerlink" title="多进程架构的好处"></a>多进程架构的好处</h1><hr>
<p>更高的容错性</p>
<ul>
<li>现代 <code>Web</code>(<code>Html</code> <code>Js</code> <code>Css</code>) 的复杂性已经越来越高，代码出现 <code>Bug</code> 可能直接导致 渲染引擎 奔溃。</li>
<li>多个 <code>tab</code> 页面会开多个 渲染进程，一个页面的崩溃不会影响其他页面的正常运行。</li>
</ul>
<p>更高的安全性和沙盒性(<code>sanboxing</code>)</p>
<ul>
<li>网络上一直以来，都充斥着各种恶意代码攻击，甚至会利用一些漏洞安装恶意软件和插件。</li>
<li>浏览器多进程的设计，通过对不同进程设置不同的权限，创造 沙盒式 运行环境，使其更安全可靠。</li>
</ul>
<p>更高的相应速度</p>
<ul>
<li>进程是操作系统进行资源分配的基本单位。</li>
<li>单进程设计就意味着，进程中的各个任务会相互竞争，抢夺<code>CPU</code>资源。而多进程架构正好改善了这一点，提升了响应速度。</li>
</ul>
<p>多进程虽然有诸多好处，但是缺点也很明显，那就是 <strong>费内存</strong>。</p>
<p>为了节约内存，<code>Chorme</code>浏览器设计和提供了四种 <strong>进程模式</strong>（<code>Process Models</code>）</p>
<ul>
<li><code>Process-per-site-instance</code> : 默认；同一个<code>site-instance</code>使用一个进程。</li>
<li><code>Process-per-site</code>: 同一个 <code>site</code> 使用一个进程。</li>
<li><code>Process-per-tab</code>: 每个<code>tab</code>使用一个进程。</li>
<li><code>Single process</code>: 所有<code>tab</code>公用一个进程。</li>
</ul>
<p>那么，<code>site</code> 和 <code>site-instance</code> 的区别是什么呢？</p>
<ul>
<li><code>site</code>: 协议和主域名一致则为 同<code>site</code> (和 <strong>同源策略</strong> 不同，不需要 <strong>子域名</strong> 和 <strong>端口号</strong> 一致)。</li>
<li><code>site-instance</code>: connected pages from the same site。包括 同 <code>site</code> 页面，还包括由这些页面打开的新页面。即通过<code>&lt;a target=&#39;_blank&#39;&gt;&lt;/a&gt;</code> 和 <code>window.open</code> 打开的页面。</li>
</ul>
<p><code>Chorme</code>浏览器默认选择<code>Process-per-site-instance</code>模式，兼容了性能和易用性，是一种中庸的选择之道。</p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><hr>
<p>前面提到，渲染进程又是 多线程 设计，那 线程 又是什么由来呢？ </p>
<ul>
<li><p>应用程序越来越多，功能迭代使得应用程序对 资源的消耗 也越来越大。</p>
</li>
<li><p>为了提升进程的效率，避免计算机资源的浪费，一个进程又可以有多个 <code>线程</code>。 </p>
</li>
<li><p><code>线程</code> 是CPU进行任务调度的基本单位。可以理解为进程的一个控制单元。</p>
</li>
<li><p>一个进程至少有一个线程。所有线程可共享进程所拥有的全部资源。</p>
</li>
</ul>
<h1 id="浏览器内核是多线程的"><a href="#浏览器内核是多线程的" class="headerlink" title="浏览器内核是多线程的"></a>浏览器内核是多线程的</h1><hr>
<p><code>浏览器内核</code> 主要有以下几个 线程：</p>
<p><code>GUI线程</code></p>
<ul>
<li><code>DOM</code>解析， <code>CSS</code>解析，生成 <code>渲染树</code>。</li>
<li>当<code>RenderObject</code>树需要 <code>更新样式</code> 属性时，即发生<code>重绘（Repaint）</code>。</li>
<li>当<code>RenderObject</code>树中元素 <code>尺寸</code>，<code>布局</code>，<code>显示隐藏</code>等发生变化，即发生<code>回流（reflow）</code>。</li>
<li>在发生 <code>重绘</code> 和 <code>回流</code>时，会形成 <code>GUI更新队列</code>。</li>
<li><code>GUI线程</code>和<code>JS引擎线程</code>互斥。当<code>JS引擎</code>执行时，<code>GUI线程</code>会被<code>挂起</code>。<code>GUI更新队列</code> 只能等到 <code>JS引擎</code> 空闲时被执行。</li>
</ul>
<p><code>JS引擎线程</code>（比如 <code>V8</code>）</p>
<ul>
<li>也称<code>JS内核</code>，负责解析<code>Javascript</code>脚本，运行代码。</li>
<li><code>GUI渲染线程</code>与<code>JS引擎线程</code>是<code>互斥</code>的。所以如果<code>JS</code>执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。</li>
</ul>
<p><code>事件触发线程</code></p>
<ul>
<li>用来控制事件循环（<code>Event Loop</code>）。</li>
<li>配合<code>JS引擎</code>处理 <code>异步代码</code>。<code>JS</code> 异步代码的 <code>回调函数</code> 会形成一个 <code>任务队列</code> ，等待 <code>JS引擎</code> 空闲时被调用。</li>
</ul>
<p><code>定时触发器线程</code></p>
<ul>
<li><code>setInterval</code>与<code>setTimeout</code>所在线程（因为<code>JS引擎</code>是 <code>单线程</code> 的, 如果处于 <code>阻塞线程</code> 状态就会影响记计时的准确）。</li>
<li><code>定时器事件</code> 会在计时完毕后，添加到 <code>事件队列</code> 中，等待 <code>JS引擎</code> 空闲后执行。</li>
</ul>
<p><code>异步http请求线程</code></p>
<ul>
<li>在<code>XMLHttpRequest</code> 在 <code>连接</code> 后是通过浏览器新开一个 <code>异步http请求线程</code> 来请求。</li>
<li>将检测到状态变更时，如果设置有回调函数，异步线程就产生 <code>状态变更事件</code>，将这个回调再放入<code>事件队列</code>中。等待 <code>JS引擎</code> 空闲后执行。</li>
</ul>
<h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h1><hr>
<h2 id="主要任务"><a href="#主要任务" class="headerlink" title="主要任务"></a>主要任务</h2><p>浏览器渲染流程的主要任务如下（不一定按顺序）：</p>
<p><code>html</code>文档解析</p>
<ul>
<li>遇到<code>JS</code>脚本，会加载并执行。</li>
<li>遇到<code>CSS</code>代码，同步进行解析。</li>
<li>过程中可能会被<code>CSS</code>和<code>JS</code>的加载而执行阻塞</li>
<li>解析完成，生成<code>Dom</code>树。</li>
<li>在控制台<code>console</code>里面输入<code>document</code>可查看<code>Dom</code>树.</li>
</ul>
<p><code>CSS</code>解析</p>
<ul>
<li><p><code>html</code>解析过程中，会对遇到的<code>CSS</code>同步进行解析：</p>
<ul>
<li><code>CSS</code>包括： 标签自带样式；通过<code>link/@import</code>引用的样式文件；<code>style</code>标签内的样式；元素内嵌的样式。</li>
<li>转换样式表中的属性值，使其标准化，比如<code>em</code>转<code>px</code>，<code>bold</code>转换成一个具体的数值，<code>red</code>转换城<code>rgb(255,0,0)</code>等。</li>
<li>计算每个<code>DOM</code>的具体样式。</li>
<li><code>CSS</code>继承。</li>
</ul>
</li>
<li><p>不会阻塞<code>html</code>解析流程。</p>
</li>
<li><p>解析完成，生成 <code>CSSOM（CSS Object Model）</code>。</p>
</li>
<li><p>在控制台<code>console</code>里面输入<code>document.styleSheets</code>可查看 <code>CSSOM</code>。</p>
</li>
</ul>
<p><code>JS</code>脚本执行</p>
<ul>
<li><code>html</code>解析过程中，会对遇到的<code>JS</code>脚本进行加载并执行。</li>
<li><code>CSS</code>解析与<code>JS</code>脚本的执行互斥（<code>JS</code>可能会等待<code>CSSOM</code>生成以后执行）。</li>
<li><code>Webkit</code>内核中进行了<code>JS</code>执行优化，只有在<code>JS</code>访问<code>CSS</code>时才会发生互斥。</li>
</ul>
<p><code>Dom树</code> 和 <code>CSSOM</code> 结合生成 渲染树（<code>Rendering Tree</code>）</p>
<ul>
<li>和<code>Dom树</code>节点不是完全对应的。</li>
<li>比如<code>head</code>标签下的所有内容，<code>display:one</code> 的元素就不会被添加到渲染树中。</li>
<li><code>visibility: hidden</code>的元素在渲染树中。</li>
<li>渲染树是一系列将被渲染的对象。</li>
</ul>
<p>布局（<code>layout</code>）: </p>
<ul>
<li><p>计算渲染树各节点元素的尺寸、位置等。</p>
</li>
<li><p>这里的计算实际上是“三维”的计算，分层布局（这里涉及<code>复合图层</code>和<code>硬件加速</code>的概念）。</p>
</li>
<li><p>布局阶段的输出就是我们常说的盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p>
</li>
<li><p>打开<code>Chrome</code>控制台，输入<code>command+shift+p</code>，选择 <code>show Rendering</code>， 选择<code>Layer borders</code>中看到，黄色的就是复合图层。</p>
</li>
</ul>
<p>绘制（<code>paint</code>）：绘制页面像素信息。</p>
<ul>
<li>浏览器会遍历渲染树，调用渲染器的<code>paint()</code>方法在屏幕上显示其内容。</li>
<li>渲染树的绘制工作是浏览器通过将各层的信息发送给<code>GPU</code>，<code>GPU</code>会进行合成（<code>composite</code>），显示在屏幕上。</li>
<li>打开<code>chrome</code>控制台，输入<code>command+shift+p</code>，选择<code>show Layers</code>，可以查看图层。</li>
</ul>
<h2 id="回流-和-重绘"><a href="#回流-和-重绘" class="headerlink" title="回流 和 重绘"></a>回流 和 重绘</h2><p><code>回流(Reflow)</code>: 基于渲染树的页面布局，是一种流式布局。当页面元素修改，引起布局的变化，浏览器就会从<code>html</code> 这个 <code>root</code> 根结点 自上而下遍历，进行重新计算渲染。引发布局变化的操作主要有：</p>
<ul>
<li>页面第一次渲染（初始化）</li>
<li><code>DOM</code>树变化（如：增删节点）</li>
<li><code>Render</code>树变化（如：显示隐藏，位置，大小等修改）</li>
<li>浏览器窗口<code>resize</code></li>
</ul>
<p><code>重绘(Repaint)</code>: 页面元素改变的时候，浏览器会对涉及内容进行重画。</p>
<ul>
<li>回流必定引起重绘。</li>
<li>仅元素样式改变，不影响布局的情况下，重绘可单独触发。</li>
</ul>
<h2 id="相关事件"><a href="#相关事件" class="headerlink" title="相关事件"></a>相关事件</h2><p><code>domContentLoaded</code>：当<code>html</code>解析完成，生成<code>Dom树</code>后触发。</p>
<ul>
<li>此时 <code>Dom</code> 元素可以被访问。</li>
<li>此时 <code>document.readystate</code> 从 <code>loading</code> 变成 <code>interactive</code></li>
</ul>
<p><code>onload</code>事件触发: 页面资源全部已加载完成后触发。</p>
<ul>
<li>此时 页面上所有的<code>DOM</code>，样式表，脚本，图片都已经加载完成。</li>
<li>此时 <code>document.readystate</code> 从 <code>interactive</code> 变成 <code>completed</code></li>
</ul>
<h2 id="异步脚本-和-延迟脚本"><a href="#异步脚本-和-延迟脚本" class="headerlink" title="异步脚本 和 延迟脚本"></a>异步脚本 和 延迟脚本</h2><p>异步脚本: 带<code>async</code>的脚本</p>
<ul>
<li><code>HTML</code> 还没有被解析完的时候，<code>async</code>脚本已经加载完了，那么 <code>HTML</code> 停止解析，去执行脚本，脚本执行完毕后触发<code>DOMContentLoaded</code>事件。</li>
<li><code>HTML</code> 解析完了之后，<code>async</code>脚本才加载完，然后再执行脚本，那么在<code>HTML</code>解析完毕、<code>async</code>脚本还没加载完的时候就触发<code>DOMContentLoaded</code>事件。</li>
<li>一定会在 <code>load</code> 事件之前执行。</li>
</ul>
<p>延迟脚本: 带 <code>defer</code>的脚本</p>
<ul>
<li>不会影响 <code>HTML</code> 文档的解析，而是等到 <code>HTML</code> 解析完成后才会执行。</li>
<li>肯定在 <code>defer</code> 脚本执行结束后，<code>DOMContentLoaded</code> 才会被触发。</li>
</ul>
<h2 id="渲染阻塞"><a href="#渲染阻塞" class="headerlink" title="渲染阻塞"></a>渲染阻塞</h2><p><code>JS阻塞页面</code>: <code>JS</code>可能操作和修改<code>DOM</code>，也可能操作<code>CSSOM</code>来修改节点样式，所以浏览器在遇到<code>&lt;script&gt;</code>标签时，<code>DOM</code>构建将暂停，直至脚本完成执行(外部脚本还要先下载完成再执行)，然后继续构建<code>DOM</code>。浏览器甚至会延迟脚本执行和构建<code>DOM</code>，直至完成其<code>CSSOM</code>的下载和构建。这就是所谓的<code>JS</code>阻塞页面。</p>
<ul>
<li>现在可以在<code>script</code>标签上增加属性<code>defer</code>或者<code>async</code>来改善。</li>
<li>浏览器会将脚本中改变<code>DOM</code>和<code>CSS</code>的地方分别解析出来，追加到<code>DOM</code>树和<code>CSSOM</code>规则树上。</li>
<li>所以，<code>script</code>标签的位置很重要。</li>
</ul>
<p><code>CSS阻塞渲染</code>: 页面是通过渲染树绘制的，渲染树的生成又必须等所有的<code>CSS</code>（内联、内部和外部）都已经下载完，并解析完生成<code>CSSDOM</code>。这就是<code>CSS</code>阻塞渲染。</p>
<ul>
<li><code>CSS</code>阻塞渲染意味着，在<code>CSSOM</code>完备前，页面将一直处理白屏状态，这就是为什么样式放在<code>head</code>中，仅仅是为了更早的解析<code>CSS</code>，保证更快的首次渲染。</li>
<li>需要注意的是，即便你没有给页面任何的样式声明，<code>CSSOM</code>依然会生成，默认生成的<code>CSSOM</code>自带浏览器默认样式。</li>
</ul>
<h1 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h1><hr>
<p>关键是要深入理解浏览器渲染流程，合法的书写 <code>HTML</code> ，<code>CSS</code>，<code>JS</code>。</p>
<p>减少<code>JS</code>阻塞</p>
<ul>
<li>合理运用<code>defer</code>或者<code>async</code>。</li>
<li>在<code>domContentLoaded</code>或者<code>onload</code>事件触发时，通过动态创建<code>script</code>标签的方式引入<code>js</code>文件。</li>
<li>合理运用缓存策略。</li>
<li>要避免过多<code>JS</code>请求，也要避免单个<code>JS</code>过大。</li>
</ul>
<p>减少<code>CSS</code>阻塞</p>
<ul>
<li>样式尽量前置（放 <code>head</code>标签），尽早解析生成 <code>CSSDOM</code>。</li>
<li>样式精简，嵌套层级最小化。</li>
</ul>
<p>减少重绘</p>
<ul>
<li>合法，合理书写<code>Html</code>布局是基础，避免无用的深层嵌套。</li>
<li>减少 或者 合并 <code>Dom</code> 操作，读/写操作尽量放一起。</li>
<li>通过<code>document</code>对象的 <code>createDocumentFragment()``cloneNode()</code>方法创建离线<code>Dom</code>，完成操作后再用于真实 <code>Dom</code>。</li>
<li><code>window.requestAnimationFrame()</code>进行动画优化。</li>
</ul>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><hr>
<p><a href="https://segmentfault.com/a/1190000012925872#item-1" target="_blank" rel="noopener">从浏览器多进程到JS单线程</a><br><a href="https://cloud.tencent.com/developer/article/1663347" target="_blank" rel="noopener">setTimeout和requestAnimationFrame</a><br><a href="https://www.imooc.com/article/40004" target="_blank" rel="noopener">浏览器渲染原理与过程</a><br><a href="https://blog.csdn.net/liubangbo/article/details/86298859" target="_blank" rel="noopener">DOMContentLoaded 与 load事件</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/03/16/JS%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/16/JS%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/" itemprop="url">浅谈 JS Event Loop 机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-16T12:06:23+08:00">
                2021-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="JS引擎（V8为例）"><a href="#JS引擎（V8为例）" class="headerlink" title="JS引擎（V8为例）"></a>JS引擎（V8为例）</h1><hr>
<p>`JavaScirpt 引擎主要用来将 JS 代码编译为不同 CPU(Intel, ARM 以及 MIPS 等)能识别的对应的汇编代码。同时，JavaScript 引擎的工作也不只是编译代码，它还要负责执行代码、分配内存以及垃圾回收。</p>
<p>最出名的JS引擎当属 Google V8。</p>
<p>V8 引擎是用 C ++ 编写的开源高性能 JavaScript 和 WebAssembly 引擎，它已被用于 Chrome 和 Node.js 等。 V8 是一个可以独立运行的模块，完全可以嵌入到任何 C ++应用程序中，比如 Node。</p>
<p>V8 是一个非常复杂的项目，有超过 100 万行 C++代码。它由许多子模块构成，其中最重要的 4 个模块是：</p>
<ul>
<li>Parser：负责将 JavaScript 源码转换为 Abstract Syntax Tree (AST)</li>
<li>Ignition：interpreter，解释器，负责将 AST 转换为 Bytecode，解释执行 Bytecode；同时收集 TurboFan 优化编译所需的信息，比如函数参数的类型。</li>
<li>TurboFan：compiler，即编译器，利用 Ignitio 所收集的类型信息，将 Bytecode 转换为优化的汇编代码；</li>
<li>Orinoco：garbage collector，垃圾回收模块，负责将程序不再需要的内存空间回收。</li>
</ul>
<img src="/2021/03/16/JS%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/v8Img.jpeg" class="" title="V8执行JS代码过程">

<p>总结下来就是：Parser 将 JS 源码转换为 AST，然后 Ignition 将 AST 转换为 Bytecode，最后 TurboFan 将 Bytecode 转换为经过优化的 Machine Code(实际上是汇编代码)。</p>
<p>在 V8 出现之前，所有的 JavaScript 虚拟机所采用的都是解释执行的方式，这是 JavaScript 执行速度过慢的一个主要原因。而 V8 率先引入了即时编译（JIT）的双轮驱动的设计（混合使用编译器和解释器的技术），这是一种权衡策略，混合编译执行和解释执行这两种手段，给 JavaScript 的执行速度带来了极大的提升。</p>
<blockquote>
<p>即时编译(Just-in-time compilation),简称为 JIT。指可以直接执行源码(比如：node test.js)，但是在运行的时候先编译再执行，这种方式被称为JIT。V8 也属于 JIT 编译器。</p>
</blockquote>
<p>解释执行和编译执行都有各自的优缺点，解释执行启动速度快，但是执行时速度慢，而编译执行启动速度慢，但是执行速度快。为了充分地利用解释执行和编译执行的优点，规避其缺点，V8 采用了一种权衡策略，在启动过程中采用了解释执行的策略，但是如果某段代码的执行频率超过一个值，那么 V8 就会采用优化编译器将其编译成执行效率更加高效的机器代码。</p>
<p>V8 执行一段 JavaScript 代码所经历的主要流程可总结为：</p>
<ul>
<li>初始化基础环境；</li>
<li>解析源码生成 AST 和作用域；</li>
<li>依据 AST 和作用域生成字节码；</li>
<li>解释执行字节码；</li>
<li>监听热点代码；</li>
<li>优化热点代码为二进制的机器代码；</li>
<li>反优化生成的二进制机器代码。</li>
</ul>
<blockquote>
<p>V8 有对应的 D8工具。它是一个非常有用的调试工具，你可以把它看成是 debug for V8 的缩写。我们可以使用 d8 来查看 V8 在执行 JavaScript 过程中的各种中间数据，比如作用域、AST、字节码、优化的二进制代码、垃圾回收的状态，还可以使用 d8 提供的私有 API 查看一些内部信息。</p>
</blockquote>
<p>此外，V8引擎内部还做了一系列优化措施：</p>
<ul>
<li>惰性解析基础上，增加预解析器来解决了闭包所带来的外部变量无法释放的问题。</li>
<li>引入快属性，慢属性机制，提升对象属性的访问速度。</li>
<li>通过内联缓存来提升函数执行效率。</li>
<li>引入字节码，相对二进制码，降低了时间和空间成本。</li>
</ul>
<blockquote>
<p>具体优化细节可参考下面文献：<a href="https://zhuanlan.zhihu.com/p/265001795" target="_blank" rel="noopener">浏览器是如何工作的：Chrome V8让你更懂JavaScript</a></p>
</blockquote>
<p>下面，我们主要探究一下JS的异步代码处理机制。</p>
<h1 id="JS异步"><a href="#JS异步" class="headerlink" title="JS异步"></a>JS异步</h1><hr>
<ul>
<li>我们都知道，<code>JS</code>引擎 是单线程设计。它的创造者就是单纯为了 <code>keep it simple</code>。</li>
<li>我们也知道，<code>JS</code> 代码可以分为 <code>同步代码</code> 和 <code>异步代码</code>。</li>
</ul>
<p>常见的 <code>异步代码</code> 生产者有：</p>
<ul>
<li><p><code>seTimeout</code></p>
</li>
<li><p><code>setInterval</code></p>
</li>
<li><p><code>Dom</code>事件</p>
</li>
<li><p><code>ajax</code>/<code>fetch</code>请求</p>
</li>
<li><p><code>process.nextTick</code>（<code>Nodejs</code>特有）等</p>
</li>
</ul>
<p>处理 <code>异步代码</code> 的方式有：</p>
<ul>
<li><code>callBack</code></li>
<li><code>promise</code></li>
<li><code>async/wait</code></li>
<li>发布/订阅 (观察者模式)</li>
</ul>
<p>为了异步处理一些耗时的操作，<code>JS引擎</code>又是基于 <code>事件循环（Event Loop）</code>机制（单独的<code>事件触发线程</code>处理），实现 <code>非阻塞I/O</code>的。那么，<code>Event Loop</code> 机制如何工作呢：</p>
<ul>
<li><p><code>JS</code> 将执行环境分为 <code>执行栈</code> 和 <code>任务队列</code> 。</p>
</li>
<li><p>首先，当前代码块所有代码被放到 <code>执行栈</code> 中 自上而下 执行；</p>
</li>
<li><p>当遇到异步操作，将异步<code>API</code>中定义的 <strong>回调函数</strong> 作为 <code>任务</code>，添加到 <code>任务队列</code> 中；</p>
</li>
<li><p>当 <code>执行栈</code> 中的 <code>同步代码</code> 全部执行完，处于空闲态后，会去循环处理 <code>任务队列</code> 里的任务;</p>
</li>
<li><p>将 <code>任务队列</code> 里的 <code>任务</code> 按先来后到的顺序依次放到 <code>执行栈</code> 中执行。</p>
</li>
<li><p>当 <code>任务</code> 代码中遇到异步代码，再次放入 <code>任务队列</code>;</p>
</li>
<li><p>如此往复，称为 <code>事件循环(Event Loop)</code>;</p>
</li>
</ul>
<p>注意：</p>
<ul>
<li><p>熟悉 <code>Promise</code> 原理就会很清楚：<code>Promise</code> 构造函数代码是<code>同步代码</code>。异步是体现在 <code>then</code> 和 <code>catch</code> 块中。</p>
</li>
<li><p>在 <code>async/await</code> 中，<code>await</code>出现之前的代码也是立即执行的 <code>同步代码</code>。之后的代码是放入 <code>任务队列</code> 的<code>异步代码</code>。</p>
</li>
</ul>
<pre><code class="language-js">// async/await 本身就是promise+generator的语法糖。
async function async1() {
  console.log(&#39;async1 start&#39;);
  await async2();
  console.log(&#39;async1 end&#39;);
}
//等价于
function async1() {
  console.log(&#39;async1 start&#39;);
  Promise.resolve(async2()).then(() =&gt; {
    console.log(&#39;async1 end&#39;);
  })
}</code></pre>
<p>另外，<code>任务队列</code> 中的 <code>异步任务</code> 又分为 <code>宏任务</code> 和<code>微任务</code></p>
<h2 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h2><p>宏任务(<code>macrotask</code>)，也叫<code>tasks</code>。以下 异步任务产生的回调会被放入 <code>宏任务</code> 队列：</p>
<ul>
<li><code>setTimeout</code></li>
<li><code>setInterval</code></li>
<li><code>I/O</code> 操作</li>
<li><code>UI rendering</code> (浏览器独有)</li>
<li><code>requestAnimationFrame</code> (浏览器独有)</li>
<li><code>setImmediate</code> (<code>Node</code>独有)</li>
</ul>
<h2 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h2><p>微任务(<code>microtask</code>)，也叫<code>jobs</code>。以下 <code>异步任务</code> 会被放入 <code>微任务</code>队列：</p>
<ul>
<li><code>Promise</code></li>
<li><code>async/await</code></li>
<li><code>MutationObserver</code></li>
<li><code>window.queueMicrotask()</code></li>
<li><code>process.nextTick</code> (<code>Node</code>独有)</li>
</ul>
<blockquote>
<p><code>MutationObserver</code>: 一个用来监视 <code>DOM</code> 变动的 <code>API</code>。<code>DOM</code> 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 <code>API</code> 都可以得到通知。<a href="https://javascript.ruanyifeng.com/dom/mutationobserver.html" target="_blank" rel="noopener">了解更多</a>）</p>
</blockquote>
<blockquote>
<p><code>queueMicrotask()</code>: 为了允许第三方库、框架、polyfills 能使用微任务，Window 暴露了 queueMicrotask() 方法。</p>
</blockquote>
<p>下面，我们来看看 分 <code>宏任务队列</code> 和 <code>微任务队列</code> 的<code>Event Loop</code> 执行顺序:</p>
<ul>
<li><p>所有代码被放到 <code>执行栈</code> 中 自上而下 执行；</p>
</li>
<li><p>遇到 异步操作 <code>API</code>，根据 <code>API</code> 的类型， 将 回调函数 添加到 <code>任务队列</code> 中 <code>宏任务队列</code> 或者 <code>微任务队列</code> ；</p>
</li>
<li><p>当 <code>执行栈</code> 中的 同步代码 全部执行完，处于空闲态后，先去循环 <code>微任务队列</code> 里的函数;</p>
</li>
<li><p>依次将 <code>微任务队列</code> 里的函数 放到 <code>执行栈</code> 中执行，如果过程中产生新的微任务，也会放入微任务队列的末尾，并且在此次循环中执行完成。</p>
</li>
<li><p>当 <code>微任务队列</code> 里的函数全部执行完成，才会将 <code>宏任务队列</code> 里的函数按顺序放到 <code>执行栈</code> 中执行。</p>
</li>
<li><p>当执行完当前的 <code>宏任务</code> 时，只有当 <code>微任务队列</code> 为空的时候，才会继续执行下一个 <code>宏任务</code>。也就是说，在执行 <code>宏任务</code> 的时候产生了新的 <code>微任务</code>，那么在这个 <code>宏任务</code> 执行完成以后，依然优先处理 <code>微任务</code>。</p>
</li>
<li><p>如此往复。直到所有 <code>任务队列</code> 为空。</p>
</li>
</ul>
<blockquote>
<p>重要：每一个宏任务执行完毕，会检查渲染任务列表，如果有渲染任务，<code>GUI</code>线程会接管渲染，渲染完成后，<code>JS</code>线程继续接管。</p>
</blockquote>
<h1 id="Nodejs-有所不同"><a href="#Nodejs-有所不同" class="headerlink" title="Nodejs 有所不同"></a>Nodejs 有所不同</h1><hr>
<ul>
<li><code>NodeJS</code> 的 异步操作 也分 <code>宏任务</code> 和 <code>微任务</code>。</li>
<li><code>宏任务</code>分为 6 个阶段，4个队列。</li>
<li><code>微任务</code> 分为 2 个队列。</li>
</ul>
<h2 id="宏任务-1"><a href="#宏任务-1" class="headerlink" title="宏任务"></a>宏任务</h2><p>6个阶段：</p>
<ul>
<li><code>timers</code>阶段：这个阶段执行 <code>setTimeout</code>和 <code>setInterval</code> 设置的 <code>callback</code>。</li>
<li><code>I/O callback</code>阶段：执行[close事件、timers、setImmediate()] 设定的callbacks之外的其他<code>callbacks</code>。</li>
<li><code>idle, prepare</code>阶段：仅<code>node</code>内部使用。</li>
<li><code>poll</code>阶段：获取新的<code>I/O</code>事件，适当的条件下<code>node</code>将阻塞在这里。</li>
<li><code>check</code>阶段：执行 <code>setImmediate()</code> 设定的<code>callbacks</code>。</li>
<li><code>close</code>阶段：执行 <code>socket.on(&#39;close&#39;, ....)</code> 这些<code>callbacks</code>。</li>
</ul>
<p>4个队列：</p>
<ul>
<li><code>iTimers</code> ： <code>setTimeout</code>， <code>setInterval</code></li>
<li><code>iIO Callbacks</code>:  <code>other……</code></li>
<li><code>iCheck</code> : <code>setImmediate()</code></li>
<li><code>iClose</code>:  <code>socket.on(&#39;close&#39;, ....)</code></li>
</ul>
<h2 id="微任务-1"><a href="#微任务-1" class="headerlink" title="微任务"></a>微任务</h2><p>2个队列</p>
<ul>
<li><code>Next Tick</code>：是放置<code>process.nextTick(callback)</code>的回调任务.</li>
<li><code>Other Micro</code>：放置其他 <code>微任务</code>，比如<code>Promise</code>等。</li>
</ul>
<h2 id="Node-js-中的-EventLoop-过程"><a href="#Node-js-中的-EventLoop-过程" class="headerlink" title="Node.js 中的 EventLoop 过程"></a>Node.js 中的 EventLoop 过程</h2><p><code>NodeJS 11</code> 之前：</p>
<ul>
<li>执行全局 <code>Script</code>的同步代码。</li>
<li>执行 <code>微任务</code>，先执行所有<code>Next Tick Queue</code>中的所有任务，再执行<code>Other Microtask Queue</code>中的所有任务。</li>
<li>开始执行 <code>宏任务</code>，共 <code>6</code> 个阶段，从第 <code>1</code> 个阶段开始执行。每一个阶段的 <code>宏任务</code> <strong>全部</strong> 执行完成后，回去执行所有 <code>微任务</code>（同上），再执行 下个阶段 的全部 <code>宏任务</code>。</li>
<li>这就是 <code>NodeJs</code> 的 <code>Event Loop</code>。</li>
</ul>
<p><code>Node 11 +</code>的变化:</p>
<ul>
<li><p>宏任务还是分阶段依次执行，但是每一个阶段的每一个 <code>宏任务</code>执行完，都回去执行所有 <code>微任务</code>，再继续执行下一个 <code>宏任务</code>。而不是等每个阶段 <code>宏任务</code> 全部执行完才回去执行微任务。</p>
</li>
<li><p>和浏览器更加趋同.</p>
</li>
</ul>
<h1 id="执行顺序自测"><a href="#执行顺序自测" class="headerlink" title="执行顺序自测"></a>执行顺序自测</h1><hr>
<p>浏览器端输出顺序：</p>
<pre><code class="language-js">async function async1() {
  console.log(&#39;async1 start&#39;);
  await async2();
  console.log(&#39;async1 end&#39;);
}
async function async2() {
  console.log(&#39;async2&#39;);
}

console.log(&#39;script start&#39;);

setTimeout(function() {
  console.log(&#39;setTimeout&#39;);
}, 0)

async1();

new Promise(function(resolve) {
  console.log(&#39;promise1&#39;);
  resolve();
}).then(function() {
  console.log(&#39;promise2&#39;);
});
console.log(&#39;script end&#39;);

/*
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
*/</code></pre>
<p>NodeJS中输出顺序：</p>
<pre><code class="language-js">console.log(1);
setTimeout(() =&gt; {
  console.log(2);
  process.nextTick(() =&gt; {
    console.log(3);
  });
  new Promise((resolve) =&gt; {
    console.log(4);
    resolve();
  }).then(() =&gt; {
    console.log(5);
  });
});
new Promise((resolve) =&gt; {
  console.log(7);
  resolve();
}).then(() =&gt; {
  console.log(8);
});
process.nextTick(() =&gt; {
  console.log(6);
});
setTimeout(() =&gt; {
  console.log(9);
  process.nextTick(() =&gt; {
    console.log(10);
  });
  new Promise((resolve) =&gt; {
    console.log(11);
    resolve();
  }).then(() =&gt; {
    console.log(12);
  });
});

//node &lt;11: 1 7 6 8 2 4 9 11 3 10 5 12
// node&gt;=11: 1 7 6 8 2 4 3 5 9 11 10 12</code></pre>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><hr>
<p><a href="https://www.jianshu.com/p/62c7d633a879" target="_blank" rel="noopener">前端干货 JS执行顺序</a><br><a href="https://zhuanlan.zhihu.com/p/265001795" target="_blank" rel="noopener">浏览器是如何工作的：Chrome V8让你更懂JavaScript</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/03/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/16/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" itemprop="url">排序算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-16T12:04:38+08:00">
                2021-03-16
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="几个概念"><a href="#几个概念" class="headerlink" title="几个概念"></a>几个概念</h1><ul>
<li>时间复杂度：执行算法所需要的计算工作量。</li>
<li>空间复杂度：算法在运行过程中临时占用存储空间大小的度量。</li>
<li>稳定性：如果存在多个具有相同的记录，若经过排序，这些记录的相对次序保持不变，则称这种排序算法是稳定的；否则称为不稳定的。</li>
<li><code>in-place</code>算法，指的是不需要额外空间的算法。</li>
</ul>
<blockquote>
<p>算法的时间复杂度和空间复杂度是可以相互转化的。比如谷歌浏览器相比于其他的浏览器，运行速度要快。是因为它占用了更多的内存空间，以空间换取了时间。</p>
</blockquote>
<h1 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h1><ul>
<li>若n较小(如 n≤ 50)，可采用 <strong>直接插入</strong>或<strong>直接选择</strong>排序。</li>
<li>若n较大，则应采用时间复杂度为O(nlgn)的排序方法：<strong>快速排序</strong>、或<strong>归并排序</strong>。 </li>
<li><strong>快速排序</strong>是目前内部排序中被认为是最好的方法，当待排序的关键字是随机分布时，快速排序的平均时间最短； </li>
<li>若要求排序稳定，则可选用<strong>归并排序</strong>。先利用直接插入排序获的有序子序列，然后再两两归并。因为直接插入排序是稳定的，所以改进后的归并排序仍是稳定的。</li>
</ul>
<blockquote>
<p><code>Array.sort()</code> 使用的是<code>直接插入排序</code>和<code>快速排序</code>结合的排序算法。数组长度不超过<code>10</code>时，使用<code>直接插入排序</code>。长度超过<code>10</code>使用<code>快速排序</code>。</p>
</blockquote>
<h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><ul>
<li>思想：相邻两个数比较大小，较大的数下沉，较小的数冒起来。</li>
<li>时间复杂度 <code>O(n2)</code>，一般不推荐使用。</li>
</ul>
<pre><code class="language-js">function BubbleSort(arr){
  let temp; //临时变量
  for(var i = 0; i &lt; arr.length-1; i++){
    let flag = false
    for(var j = arr.length-1; j &gt; i; j--){
      if(arr[j] &lt; arr[j-1]){
        temp = arr[j];
        arr[j] = arr[j-1];
        arr[j-1] = temp;
        flag = true
      }
    }
    if(!flag) break; // 如果第N次遍历没有发生交换，说明已经排序完成，无需后续的遍历，提升了排序稳定性。
  }
  return arr
}</code></pre>
<h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><ul>
<li>思想：初始时在序列中找到最小（大）元素，放到序列的起始位置作为已排序序列；然后，再从剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</li>
<li>时间复杂度 <code>O(n2)</code>,数据量较小时推荐。</li>
<li>不稳定排序。比如序列：<code>{ 5, 8, 5, 2, 9 }</code>，首次选择以后，最小元素 <code>2</code> 和第一个 <code>5</code> 进行交换，从而改变了两个元素 <code>5</code> 的相对次序。</li>
</ul>
<pre><code class="language-js">
function SelectionSort(arr)
{
  for (let i = 0; i &lt; arr.length - 1; i++){
    let min = i, temp;
    for (let j = i + 1; j &lt; arr.length; j++){
      if (arr[j] &lt; arr[min])
      {
        min = j;
      }
    }
    if (min != i)
    {
      temp = arr[min];
      arr[min] = arr[i];
      arr[i] = temp;
    }
  }
  return arr;
}
</code></pre>
<h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><ul>
<li>思想：和抓扑克牌类似，首个元素为初始已排序队列，第二个元素从后往前扫描已排序队列，找到合适的位置插入，后面的元素依此类推。</li>
<li>特点：时间复杂度 <code>O(n2)</code>, 通常在数据量级较小时使用。<code>Array.sort()</code>内部，在数组长度不超过<code>10</code>时，就使用<code>插入排序</code>。是稳定排序算法。</li>
</ul>
<pre><code class="language-js">function insertSort(arr){
  let temp, lenth = arr.length;
  for(let i =0 ; i &lt; lenth-1 ; i++){
    for(let j = i + 1 ; j &gt; 0 ; j--){
      if(arr[j] &lt; arr[j-1]){
        temp = arr[j-1];
        arr[j-1] = arr[j];
        arr[j] = temp;
      }else{         //不需要交换
        break;
      }
    }
  }
  return arr;
}</code></pre>
<h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><ul>
<li>思想：分而治之。先从数列中取出一个数作为基数（一般是第一个或者最后一个）；将比这个数小的全部放在它的左边，大于或等于它的全部放在它的右边；对左右两个小数列重复第二步，直至各区间只有1个数。</li>
<li>特点：平均时间复杂度：<code>O(N*logN)O(N*logN)</code>, 通常明显比其他<code>O(nlogn)</code>算法更快。快速排序是不稳定的排序算法。</li>
</ul>
<pre><code class="language-js">function quickSort(arr) {
  if (arr.length &lt;= 1)  
    return arr;
  // 首个元素作为基数
  const pivot = arr[0];
  //左右区间，用于存放排序后的数
  let left = [], right = [];

  for (let i = 1; i &lt; arr.length; i++) {
      if (arr[i] &lt; pivot) {
        left.push(arr[i]);
      } else {
        right.push(arr[i]);
      }
  }
  //递归left/right; 使用concat操作符，将左区间，基准，右区间拼接为一个新数组
  return quickSort(left).concat([pivot], quickSort(right));
}</code></pre>
<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><ul>
<li>思想：归并排序主要依赖归并(Merge)操作。指的是将两个已经排序的序列合并成一个序列的操作。</li>
<li>特点：平均时间复杂度 O(NlogN)。是稳定排序算法。</li>
</ul>
<p>下面，我们应用归并排序思想，合并一个二维有序数组成一维有序数组：</p>
<pre><code class="language-js">/**
 * 基本思路：双指针 从头到尾比较两个数组的第一个值，根据值的大小依次插入到新的数组中
 * @param {Array} arr1
 * @param {Array} arr2
 */
function　merge(arr1, arr2){
  let　result=[];
  while(arr1.length&gt;0 &amp;&amp; arr2.length&gt;0){
    if(arr1[0]&lt;arr2[0]){
        /*shift()方法用于把数组的第一个元素从其中删除，并返回第一个元素的值。*/
      result.push(arr1.shift());
    }else{
      result.push(arr2.shift());
    }
  }
  return　result.concat(arr1).concat(arr2);
}

function mergeSort(arr){
  let lengthArr = arr.length;
  if(lengthArr === 0){
   return [];
  }
  while(arr.length &gt; 1){
   let arrayItem1 = arr.shift();
   let arrayItem2 = arr.shift();
   let mergeArr = merge(arrayItem1, arrayItem2);
   arr.push(mergeArr);
  }
  return arr[0];
}
let arr = [[1,2,3],[4,5,6],[7,8,9],[1,2,3],[4,5,6]];
mergeSort(arr);</code></pre>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.cnblogs.com/onepixel/articles/7674659.html" target="_blank" rel="noopener">常见排序算法图解</a><br><a href="https://www.runoob.com/w3cnote/sort-algorithm-summary.html" target="_blank" rel="noopener">排序算法总结</a><br><a href="https://www.cnblogs.com/chengxiao/p/6129630.html" target="_blank" rel="noopener">堆排序</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/03/10/%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/10/%E6%95%B0%E6%8D%AE%E5%88%86%E7%BB%84%E7%AE%97%E6%B3%95%E7%9A%84%E4%B8%80%E7%82%B9%E6%80%9D%E8%80%83/" itemprop="url">数据平均分组算法的一点思考</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-10T19:37:15+08:00">
                2021-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>比如，有一堆整数要分为 <code>N</code> 组，确保每一组尽量相等。这是我看到的一个面试题，觉得这种算法在某些公司的实际项目中应该是有应用场景的。所以就研究一下。</p>
<h1 id="一点思路"><a href="#一点思路" class="headerlink" title="一点思路"></a>一点思路</h1><ul>
<li>等分如何衡量：<code>标准差</code>。</li>
<li>常识性做法，从大到小开始分。</li>
<li>分配标准：根据平均值判断。我们知道，基本上没有每组刚好都等于平均值的情况，普遍的情况是均衡分布在平均值上下。所以平均值也需要浮动。</li>
</ul>
<pre><code class="language-js">/**
* @intArr 整数数组
* @count 分组数目
* @float 平均值浮动阈值（核心）
*/
function groupIntArr( intArr = [], count = 1, float = 1) {
  // 容错略 。。。
  // 数组从大到小排序
  intArr.sort((a,b) =&gt; b - a);
  //计算平均值
  let avg = intArr.reduce((a,b) =&gt; a + b) / count;
  let sum = 0; // 临时总和 用于和平均值判断
  let resArr = new Array(count) //  初始化
  for(var i = 0; i &lt; count -1; i ++) { // 为啥是 count-1 ：最后一个分组直接赋予剩余list
    resArr[i] = [intArr[0]];
    sum = intArr[0];
    intArr.shift(); // 记得从原数组删除
    // 这里一定要加 “=” ；float 是关键
    for (var j = 0; j &lt; intArr.length ; j++) {
      if (sum + intArr[j] &lt;= avg + float) {  
        resArr[i].push(intArr[j]);
        sum += intArr[j];
        intArr.splice(j,1); //放入结果数组，就从原数组删除
      }
    }
  }
  resArr[count -1] = intArr;
  // 打点日志
  const sumArr = []
  resArr.forEach( (item) =&gt; {
    sumArr.push(item.reduce((a,b) =&gt; {return a + b}));
  })
  console.log(&#39;平均数：&#39;, avg)
  console.log(&#39;分组总和：&#39;, sumArr.join(&#39;,&#39;));
  return resArr
}
/*** 执行   **/
groupIntArr([11,42,23,4,5,6,4,5,6,11,23,42,56,78,90],3,1)
//[90, 42, 4] [78, 42, 11, 4]  [56, 23, 23, 11, 6, 6, 5, 5]
// [90, 42, 4] 
// [78, 56] 
// [42, 23, 23, 11, 11, 6, 6, 5, 5, 4]
// 平均数：  135.33333333333334
// 分组总和： 136,134,136 （标准差：1.1547）
groupIntArr([11,42,23,4,5,6,4,5,6,11,23,42,56,78,90],3,0)
// 平均数：  135.33333333333334
// 分组总和： 132,134,140 （标准差：4.16333）
groupIntArr([11,42,23,4,5,6,4,5,6,11,23,42,56,78,90],3,2)
// 平均数：  135.33333333333334
// 分组总和： 137,134,135 （标准差：1.52753）


groupIntArr([1100,4200,2300,400,500,600,400,500,600,1100,2300,4200,5600,7800,9000],3)
// 平均数：  13533.333333333334
// 分组总和： 13200,13400,14000 （标准差：416.3332）

groupIntArr([1100,4200,2300,400,500,600,400,500,600,1100,2300,4200,5600,7800,9000],3, 100)
// 平均数：  13533.333333333334
// 分组总和： 13600,13400,13600 （标准差：115.47005）</code></pre>
<ul>
<li>主逻辑：先从大到小排序，从最大的开始分组，然后在不超过数据平均值的情况下逐个分组，最后一个分组直接使用剩余数据。</li>
<li>核心：通过 <code>float</code> 控制平均值的浮动可以得到更完美的结果，所以关键就是根据实际数据的情况，选择合适的<code>float</code>（比如上述代码中，小数据数组<code>float = 1</code>更适配，大数据数组<code>float = 100</code>更适配 ）。</li>
</ul>
<blockquote>
<p>如果要追求极致，可以通过设置多个<code>float</code>值甚至一个区间，然后通过判断所有结果的<code>标准差</code>来获取到最优分组。但是这样<code>时间复杂度</code>和<code>空间复杂度</code>就很高了。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/03/05/2020%E5%89%8D%E7%AB%AF%E7%8E%B0%E7%8A%B6%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/03/05/2020%E5%89%8D%E7%AB%AF%E7%8E%B0%E7%8A%B6%E8%B0%83%E6%9F%A5%E6%8A%A5%E5%91%8A/" itemprop="url">《2020前端现状调查报告》学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-03-05T17:56:03+08:00">
                2021-03-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <img src="../2020前端现状调查报告/head.jpeg" width="100%" style="border: none"/>

<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><hr>
<p>作者对来源于世界各地的 <code>4500</code> 位前端开发进行了问卷调查。根据采集到的数据进行了一系列有趣的图表统计。</p>
<p>报告分 <code>11</code> 个章节，分别邀请了相关权威的技术人士根据调查结果进行分析，并运用他们令人钦佩的专业知识和大局观进行了总结。</p>
<img src="../2020前端现状调查报告/dev_from.jpg" width="100%"/>

<blockquote>
<p>本想完整翻译这份报告，但是发现 <a href="https://github.com/xitu/Annual-Survey/pull/5" target="_blank" rel="noopener">github</a> 上已经有团队在讨论翻译中。这里，我主要就报告核心内容进行一些精炼和总结，外加那些有趣的图表。</p>
</blockquote>
<h1 id="开发者（developers）"><a href="#开发者（developers）" class="headerlink" title="开发者（developers）"></a>开发者（developers）</h1><hr>
<p>大多数参与调查的开发者都是从事前端开发 <code>3</code> 年以上的 <code>高级+</code> 前端。</p>
<img src="../2020前端现状调查报告/1-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/1-2.jpg" width="100%"/>
<img src="../2020前端现状调查报告/1-3.jpg" width="100%"/>

<h1 id="框架（Frameworks）"><a href="#框架（Frameworks）" class="headerlink" title="框架（Frameworks）"></a>框架（Frameworks）</h1><hr>
<p><strong>现状</strong>：</p>
<p><code>React</code> 绝对王者。有 <code>74.2%</code> 的调查对象在使用 <code>React</code> ，超过 <code>Angular</code> 和 <code>Vue</code> 用户的总和。</p>
<p>大家对 <code>Angular</code> 的相对兴趣有所下降，对 <code>Vue</code> 的兴趣增长也有些停滞。更新较慢是部分原因。</p>
<p>有趣的一点是：<code>jQuery</code> 虽然很少被提及，但它仍然是网络上部署最广泛的 <code>JavaScript</code> 库。</p>
<p>在状态管理方面，使用 <code>React Context API</code> 和 <code>hooks</code>（<code>49.6%</code>）的人比使用 <code>Redux</code> （<code>48.2%</code>）的人更多。</p>
<p><strong>趋势</strong>：</p>
<p>新一代响应式框架（<code>Reactive Frameworks</code>）快速崛起, 或将成为 <code>React</code> 生态的可替代品。这和 <code>TypeScript</code> 的流行也有很大关系。</p>
<p>大家对新一代响应式框架也产生了浓厚的兴趣，比如 <code>Svelte</code> ，它致力于在普通 <code>DOM</code> 结构之上提供响应式。</p>
<p>另一个竞争者是 <code>Stencil.js</code>, 一个专注于网络组件（<code>web component</code>）的框架，和 <code>Svelte</code> 一样，专注于高效的编译。</p>
<p>多数人更喜欢 <code>TypeScript</code>，<code>77.2%</code> 的受访者已经在使用 <code>TypeScript</code> 。因此，很多现有框架正在改善对 <code>TypeScript</code> 的支持，而且许多框架开始在内部使用 <code>TypeScript</code>。</p>
<blockquote>
<p>一点争议：目前，新一代框架可能非常适合小型应用，但在构建大型应用时需要更多的工作。的确，因为它们没有像框架那样需要支持过去几年的功能的遗留问题，所以默认的包很小。但是，它们也非常符合现代标准和语言特性。</p>
</blockquote>
<img src="../2020前端现状调查报告/2-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/2-2.jpg" width="100%"/>
<img src="../2020前端现状调查报告/2-3.jpg" width="100%"/>
<img src="../2020前端现状调查报告/2-4.jpg" width="100%"/>
<img src="../2020前端现状调查报告/2-5.jpg" width="100%"/>
<img src="../2020前端现状调查报告/2-6.jpg" width="100%"/>

<h1 id="托管（Hosting）"><a href="#托管（Hosting）" class="headerlink" title="托管（Hosting）"></a>托管（Hosting）</h1><hr>
<p><code>44.3%</code> 的受访者仍在将他们的应用部署到自己的 <code>Web</code> 服务器上。这提醒我们，传统DC仍有巨大的市场，公有云仍有很多发展机会。</p>
<p>在云服务提供商中，亚马逊云计算服务 <code>AWS（Amazon Web Services）</code>最受欢迎（<code>38.7%</code>）。</p>
<p><code>Netlify</code> 拥有很高的渗透率 (<code>23.3%</code>)，高于 <code>GCP（Google Cloud Platform）</code> 和 <code>Microsoft Azure</code>。这是其自身优质能力的体现。</p>
<p>前端开发的未来需要 <code>Netlify</code> 和 <code>Vercel</code> 这样的平台，它们专注于为前端团队提供易于使用且功能强大的后端基础设施的抽象。自成一派，并不断成长。</p>
<img src="../2020前端现状调查报告/3-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/3-2.jpg" width="100%"/>
<img src="../2020前端现状调查报告/3-3.jpg" width="100%"/>
<img src="../2020前端现状调查报告/3-4.jpg" width="100%"/>
<img src="../2020前端现状调查报告/3-5.jpg" width="100%"/>


<h1 id="JAMstack"><a href="#JAMstack" class="headerlink" title="JAMstack"></a>JAMstack</h1><hr>
<p>近<code>1/3</code>的受访者最近建立了一个 <code>Jamstack</code>（<code>JavaScript、API、Markup</code>）网站。另外，让我个人感到高兴的是，其中超过一半的人使用了 <code>Next.js</code> –我们在 <code>Vercel</code> 为 <code>Jamstack</code> 创建的 <code>React</code> 框架。预计在接下来的几个月里，建设 <code>Jamstack</code> 网站的前端开发者的比例会更大。</p>
<p>对我来说，<code>Jamstack</code> 的魅力在于它让我们做得更少，完成得更多。有了 <code>Jamstack</code> ，你不需要在每次请求时渲染一个页面（<code>SSR</code>服务器端渲染），而是在请求时间之前预渲染一个页面（静态生成）。这可以被 <code>CDN</code> 上的所有边缘节点共享，以获得最佳性能、更高的可用性、更低的成本和零维护开销。</p>
<p>此外，<code>Jamstack</code> 框架也在不断发展，超越静态，采用动态的灵活性。例如，<code>Next.js</code> 允许你在生产构建后静态生成额外的页面或重新生成现有的页面（增量静态生成）。即使你的应用程序有数百万个页面，初始构建也会立即完成，因为这些页面可以增量生成。</p>
<p>可重用的 <code>API（Jamstack中的 &quot;A&quot;）</code>也在崛起。现在市场上有很多无头内容管理系统 <code>（Handless CMS）</code>、无头电商(<code>headless e-commerce</code>)、无头身份(<code>headless identity</code>) 等供应商。难怪框架也在随着这些趋势发展。经验之谈: <code>Next.js</code> 有预览模式功能，当你在 <code>Handless CMS</code> 上预览页面时，可以有条件地绕过静态生成。</p>
<p>受访者正在使用各种各样的 <code>Jamstack</code> 解决方案，正在尝试不同的想法。这也推动了<code>Jamstack</code>社区的发展，使其成为一个更简单、更高性能的网络。</p>
<blockquote>
<p><code>Edge CDN</code> 的 <code>Anycast</code> 网络可以缓存边缘的静态内容，通过尽可能接近访问者的资源来减少延迟，从而提高用户访问速度。</p>
</blockquote>
<blockquote>
<p><code>Handless CMS</code>: <code>Handless content management system</code>,是一种没有前端组件的系统，内容可以通过<code>API</code>发布到任何地放的方式展示给最终用户。</p>
</blockquote>
<img src="../2020前端现状调查报告/4-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/4-2.jpg" width="100%"/>

<h1 id="微前端（Micro-frontends）"><a href="#微前端（Micro-frontends）" class="headerlink" title="微前端（Micro frontends）"></a>微前端（Micro frontends）</h1><hr>
<p>已经有 <code>1/4</code> 的前端开发开始构建自己的微前端项目。</p>
<p>网络组件（<code>Web component</code>）是很好的，入门级的 微前端 解决方案。</p>
<p>有不少新的微前端框架，既支持后端渲染又具备前端构造（比如<code>Holocron</code>, <code>Podium</code>,<a href="https://ara-framework.github.io/website/" target="_blank" rel="noopener">Ara Framework</a>。这些框架是对微前端社区的巨大补充，但切记谨慎挑选–始终要契合你的应用环境。</p>
<p>只有<code>20%</code>的调查者认为微前端可能会在未来三年内消失。<code>Luca Mezzalira</code>认为，微前端现在还处于早期，有很多经验教训需要学习，但他相信微前端会不断发展并达到成熟–就像微服务一样。</p>
<p><code>TC39/Realms</code>提案已经进入<code>stage 2</code>阶段, <code>Luca Mezzalira</code>认为这将为微前端打开新的局面。</p>
<p>微前端并不是万能的，但绝对是对其他架构（比如 <code>SSR</code>、<code>JamStack</code> 和 <code>SPA</code> ）的一个很好的补充。 只要在合适的场景应用，将事半功倍。</p>
<blockquote>
<p><code>Luca Mezzalira</code>: <code>DAZN</code>架构副总裁, <code>&quot;Building Micro-Frontends&quot;</code>作者。</p>
</blockquote>
<blockquote>
<p><code>TC39</code> 是 <code>Ecma International</code> 标准化组织旗下的技术委员会的一员，它负责管理 <code>ECMAScript</code> 语言和标准化 <code>API</code>。</p>
</blockquote>
<blockquote>
<p><code>Realms</code>提案提供了一种新的机制，用于在一个新的全局对象和一组<code>JavaScript</code>内置的上下文中执行<code>JavaScript</code>代码。</p>
</blockquote>
<img src="../2020前端现状调查报告/5-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/5-2.jpg" width="100%"/>

<h1 id="SEO"><a href="#SEO" class="headerlink" title="SEO"></a>SEO</h1><hr>
<p>搜索引擎优化（<code>Search Engine Optimization</code>）- <code>SEO</code> 对任何在线业务都至关重要。</p>
<p>高达 <code>52%</code> 的调查者并不关心 <code>SEO</code> ，可能许多调查者开发的是受密码权限控制的应用。</p>
<p>做好 <code>SEO</code> ，首先应该确保搜索引擎能够正确地在你的网站上渲染 <code>JavaScript</code>。不小心在 <code>robots.txt</code> 中屏蔽了一些脚本，或者使用了搜索引擎抓取工具（比如 <code>Googlebot</code> 百度蜘蛛）不支持的 <code>JavaScript</code> 功能，都会影响 <code>SEO</code>。</p>
<p>渲染只是 <code>SEO</code> 众多方面中的一个。你必须把注意力放在使用正确的 <code>HTML</code> 标签和设计一个合理的网站结构上。就像你在服务器端渲染、客户端渲染和动态渲染之间选择一样。关键是要理解搜索引擎的工作原理。</p>
<blockquote>
<p><code>robots.txt</code> 是一个协议，而不是一个命令。<code>robots.txt</code> 是搜索引擎中访问网站的时候要查看的第一个文件。<code>robots.txt</code> 文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。建议当您的网站包含不希望被搜索引擎收录的内容时，才需要使用 <code>robots.txt</code> 文件。如果希望搜索引擎收录网站上所有内容，请勿建立 <code>robots.txt</code> 文件。</p>
</blockquote>
<img src="../2020前端现状调查报告/6-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/6-2.jpg" width="100%"/>

<h1 id="应用程序可访问性（Application-accessibility）"><a href="#应用程序可访问性（Application-accessibility）" class="headerlink" title="应用程序可访问性（Application accessibility）"></a>应用程序可访问性（Application accessibility）</h1><hr>
<p>这是一个关乎用户体验的话题，对于非常接近用户的前端开发来说，是非常重要的。</p>
<p>作为前端开发人员，我们经常是这项工作流中最后一个提升可访问性的人。要摆脱这种模式，我们需要转变思维。我们必须努力成为同行的好老师，做好规范，榜样，保证可访问性不会取决于我们开发者的时候，网站才能为每个人服务。</p>
<p>关心无障碍的开发人员似乎大多数都熟悉《web内容无障碍指南》（<code>WCAG</code>）的基础。在未来，我们也应该尝试了解有多少人测试无障碍性。现在自动测试无障碍性的工具越来越多。</p>
<img src="../2020前端现状调查报告/7-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/7-2.jpg" width="100%"/>

<h1 id="开发团队"><a href="#开发团队" class="headerlink" title="开发团队"></a>开发团队</h1><hr>
<p><code>92%</code> 的受访者表示他们在过去一年中曾作为开发团队的一员工作过。</p>
<p>前端架构和部署基础设施的最新趋势已经影响了前端开发人员与团队成员协作的方式。</p>
<p>随着新的前端架构(如 <code>Jamstack</code> )的兴起，前端开发人员可以独立于后端部署前端。他们不再需要等待完整的后端测试套件的运行，从而导致更快的迭代。</p>
<p>现成的后端 <code>API</code> ( 如 <code>headless CMS</code>、<code>IDP</code> 等) 越来越多，可以很容易地插入到你的前端。这使得后端开发人员能够更加专注于开发业务特有的 <code>API</code>。</p>
<p>我们开始与设计师和产品负责人更多的打交道。因为 <code>Jamstack</code> 应用程序可以快速、廉价地部署到 <code>CDN edge</code> 上，所以可以为每个分支和每个提交分配一个唯一的“预览” <code>URL</code>。我们已经在 <code>Vercel</code> 做到了这一点——现在，设计人员和产品所有者只需点击预览 <code>URL</code>，就可以立即查看前端开发人员所做的更改是否符合预期。这比分享截图和 <code>gif</code> 更有效。</p>
<p>最后看软件测试。随着 <code>puppeteer</code> 的引入，<code>Chrome</code> 的无头 <code>web</code> 浏览器，结合无服务器计算，端到端测试变的快速和廉价。例如，您可以让运行 <code>Checkly</code> + <code>puppeteer</code> 测试案例(由QA专家编写) 这样的服务和预览 <code>URL</code> 对应起来。此外，随着 <code>Vercel</code> 和其他前端部署平台的崛起，<code>DevOps</code> 工程师可以花更少的时间来支持前端开发人员。</p>
<blockquote>
<p><code>IDP</code> : (<code>identity provider</code>）身份提供者，是一个系统组件，它能够向终端用户或连接到互联网的设备提供一组登录凭据，以确保实体是谁或它所说的是什么，跨越多个平台、应用程序和网络。例如，当第三方网站提示终端用户使用微信帐户登录时，微信登录就是身份提供者。</p>
</blockquote>
<blockquote>
<p><code>Puppeteer</code>: 一个控制 <code>headless Chrome</code> 的 <code>Node.js API</code> 。它是一个 <code>Node.js</code> 库，通过 <code>DevTools</code> 协议提供了一个高级的 <code>API</code> 来控制 <code>headless Chrome</code>。</p>
</blockquote>
<blockquote>
<p><code>Checkly</code> 是一款验证 <code>API</code> 端点正确性和浏览器点击流的监控工具。<code>Checkly</code> 可以使用 <code>Puppeteer</code> 框架进行自动化浏览器操作。</p>
</blockquote>
<img src="../2020前端现状调查报告/8-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/8-2.jpg" width="100%"/>

<h1 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h1><hr>
<p>让设计师与开发者紧密合作不再是一种时尚，而是一种标准。我们已经有了非常好的工具让这种合作变得更好。</p>
<p>软件开发公司有两种设计人员——以用户为中心的<code>UX/UI</code>设计人员和以业务为中心的产品设计人员——已经成为一种标准。</p>
<blockquote>
<p>随着产品设计师的加入，软件公司越来越多地关注于创建与客户业务目标相匹配的战略和产品。</p>
</blockquote>
<p>产品设计师的出现这意味着，作为软件公司，我们越来越多地关注客户的真实需求，致力于创建与他们的业务目标相匹配的战略和产品。</p>
<p>为了使这种合作富有成效，我们需要更好的工具，比如 <code>Figma</code>, <code>InVision</code>, <code>Sketch</code>和<code>Zeplin</code>。<code>71.7%</code>的开发团队已经使用了这类工具。</p>
<img src="../2020前端现状调查报告/9-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/9-2.jpg" width="100%"/>

<h1 id="质量保证"><a href="#质量保证" class="headerlink" title="质量保证"></a>质量保证</h1><hr>
<p>如今，越来越多的数字产品的功能是在客户端实现的。这使得软件工程师和QA专家必须将测试作为开发、维护和扩展<code>JavaScript</code>应用程序的工作流程的一部分。可喜的是，<code>80%</code>的前端开发者已经开始进行软件测试，而且这一数字在过去几年里还在不断增长。</p>
<blockquote>
<p>软件测试与现代前端开发是密不可分的。</p>
</blockquote>
<p>软件测试是对数字产品稳定性的必要投资，最终提高了我们整个工作流程的生产力。我们相信<code>Capybara</code>、<code>RSpec</code>、<code>Ember CLI</code>和<code>QUnit</code>等工具可以进行单元测试、集成测试和端到端测试。当然，还有更多的解决方案供你选择。</p>
<p>在<code>.cult</code>，我们相信测试工具生态系统的持续增长将很快允许我们通过自动化覆盖产品开发工作流的更大一部分。</p>
<img src="../2020前端现状调查报告/10-1.jpg" width="100%"/>
<img src="../2020前端现状调查报告/10-2.jpg" width="100%"/>
<img src="../2020前端现状调查报告/10-3.jpg" width="100%"/>

<h1 id="前端未来趋势"><a href="#前端未来趋势" class="headerlink" title="前端未来趋势"></a>前端未来趋势</h1><hr>
<p>我们对调查结果和最近前端<code>web</code>开发的变化无不惊讶。所以预测前端的未来不是一件容易的事。</p>
<p>然而，在前端开发社区，爱与恨之间的界限很窄。一两年前，<code>Redux</code>是配合<code>React</code>进行状态管理的普遍选择。但前端开发人员现在厌倦了<code>Redux</code> 所带来的问题，并迅速加入 <code>React hooks</code> 的行列。现在使用 <code>hooks</code> 的用户已经超过了 <code>Redux</code> ，有 <code>34%</code> 的前端开发者认为 <code>Redux</code> 将在 <code>3</code> 年后消失。</p>
<p>同时，前端开发的世界也变得越来越复杂。同样，一两年前，像<strong>持续集成</strong>和<strong>容器化</strong>这样的解决方案更多地被认为是后端事物。前端开发人员现在意识到，他们也可以从这些解决方案中受益。现在，<code>77%</code> 的前端开发者使用 <code>CI</code> , <code>62%</code> 使用容器。它们已经成为前端开发的新标准。</p>
<p>那么，在接下来的 <code>12</code> 个月里，前端会发生怎样的变化呢? <code>Svelte</code> 会成为3个最流行的框架之一吗? 微前端会成熟吗? 没有人能确定，但在我看来，有一件事是确定的: 我们会对一些变化的发生速度感到惊讶。让我们期待《2021年前沿状态》报告。</p>
<img src="../2020前端现状调查报告/11-1.jpg" width="100%"/>

<h1 id="原文-amp-拓展文档"><a href="#原文-amp-拓展文档" class="headerlink" title="原文&amp;拓展文档"></a>原文&amp;拓展文档</h1><hr>
<p><a href="https://tsh.io/state-of-frontend/" target="_blank" rel="noopener">报告原文</a><br><a href="https://www.netlify.com/" target="_blank" rel="noopener">Netlity官网</a><br><a href="https://jamstack.com/" target="_blank" rel="noopener">Jamstack网</a><br>[GatsbyJs中文网] (<a href="https://www.gatsbyjs.cn/" target="_blank" rel="noopener">https://www.gatsbyjs.cn/</a>)<br><a href="https://www.w3.org/TR/WCAG21/" target="_blank" rel="noopener">WCAG</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2021/02/08/MongoDb%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/02/08/MongoDb%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/" itemprop="url">MongoDb安装配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-02-08T11:59:54+08:00">
                2021-02-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>可以直接到<a href="">mongoDB官网</a>下载安装包。<br>我们公司对软件安装有限制，没有管理员权限。所以我下载的免安装的，解压即用的<a href="https://www.mongodb.com/download-center/community/releases/archive">mongo</a></p>
<pre><code class="language-shell">
$ sudo curl -O https://fastdl.mongodb.org/osx/mongodb-macos-x86_64-4.4.2.tgz  #下载

$ sudo tar -zxvf mongodb-osx-ssl-x86_64-4.4.2.tgz   # 解压
</code></pre>
<h1 id="安装-amp-配置"><a href="#安装-amp-配置" class="headerlink" title="安装&amp;配置"></a>安装&amp;配置</h1><ul>
<li>对于<code>tgz</code>文件，直接拷贝到全局目录 <code>/usr/local/</code>，然后配置环境变量即可。建议将文件夹命名为 <code>mongodb</code>。</li>
<li><code>/usr/local</code>为隐藏目录，正常在<code>finder</code>中是看不到的，需要在<code>finder</code>中按<code>shift + command +G</code> 输入<code>/usr/local</code>并点击前往。</li>
</ul>
<p>命令行操作如下：</p>
<pre><code class="language-shell"># 安装（copy）
$ sudo cp -r mongodb-osx-x86_64-4.4.2/  /usr/local/   
$ sudo mv mongodb-osx-x86_64-4.4.2/ mongodb
# 配置环境变量
$ vi ~/.bash_profile  # 增加: export PATH=$PATH:/usr/local/mongodb/bin
$ source .bash_profile
</code></pre>
<p>不幸的是，我们公司系统有管理员权限控制，是无法使用全局目录<code>/usr/local/</code> 的。所以，我使用的自己的工作目录：</p>
<pre><code class="language-shell"># 安装（copy）
$ sudo cp -r mongodb-osx-x86_64-4.4.2/  /Users/myself   
$ sudo mv mongodb-osx-x86_64-4.4.2/ mongodb
# 配置环境变量
$ vi ~/.bash_profile  # 增加: export PATH=$PATH:/Users/myself /mongodb/bin
$ source .bash_profile</code></pre>
<p>验证安装是否ok：</p>
<pre><code class="language-shell">$ mongod -version  # 正常打印出mongo版本信息，即安装生效。</code></pre>
<h1 id="启动mongodb"><a href="#启动mongodb" class="headerlink" title="启动mongodb"></a>启动mongodb</h1><p>启动之前，我们需要创建<code>db</code>（数据存储）和<code>logs</code>（日志文件）的文件夹。可以直接创建在安装的<code>mongodb</code>目录，也可以放到单独的目录。</p>
<pre><code class="language-shell">$ cd /Users/myself
$ mkdir mongoData  # 创建单独目录
$ cd mongoData
$ mkdir db
$ mkdir logs</code></pre>
<p>启动mongodb</p>
<pre><code class="language-shell"># 常用命令
$ mongod --dbpath data --logpath logs/m.log --logappend
# --dbpath 指定数据文件夹
# --logpath 指定日志存储文件
# --logappend 后台运行</code></pre>
<p>明显的，启动<code>mongodb</code>是有一系列配置的。所以，通常我们会设置一个单独的配置文件，根据配置文件来启动<code>mongodb</code>。</p>
<pre><code class="language-shell">$ cd /User/myself/mongoData
$ vi m.conf # 增加配置文件

# 常用配置如下：

bind_ip_all = true # 任何机器可以连接
#bind_ip = 127.0.0.1,192.168.0.3 # 本机和192.168.0.3可以访问
port = 27017 # 实例运行在27017端口（默认）
dbpath = /Users/myself/mongoData/db # 数据文件夹存放地址（db要预先创建）
logpath = /Users/myself/mongoData/logs/m.log # 日志文件地址
logappend = false # 启动时 添加还是重写日志文件
fork = true # 是否后台运行
#auth = true # 开启校验用户

# 启动mongodb
$ mongod -f m.conf</code></pre>
<p>如果没有什么报错信息，基本上mongodb已经启动</p>
<h1 id="连接mongodb"><a href="#连接mongodb" class="headerlink" title="连接mongodb"></a>连接mongodb</h1><p>在新的终端中输入”mongo” 连接数据库，如果出现数据库操作符<code>&gt;</code>, 那么恭喜你，可以使用<code>mongodb</code>了。</p>
<pre><code class="language-shell">$ mongo
MongoDB shell version v4.4.2
connecting to: mongodb://127.0.0.1:27017/?compressors=disabled&amp;gssapiServiceName=mongodb
Implicit session: session { &quot;id&quot; : UUID(&quot;92e4a9f7-b622-4a1a-9de1-df4cc8e1b581&quot;) }
MongoDB server version: 4.4.2
# ...略
&gt; 1+1
2
&gt; </code></pre>
<h1 id="Nodejs-mongodb"><a href="#Nodejs-mongodb" class="headerlink" title="Nodejs + mongodb"></a>Nodejs + mongodb</h1><p>在<code>Node</code>项目中，我们可以使用<code>Mongoose</code>库来连接和使用<code>mongodb</code>。<br><code>Mongoose</code>是在<code>node.js</code>异步环境下对<code>mongodb</code>进行便捷操作的对象模型工具。</p>
<pre><code class="language-js">const mongoose = require(&#39;mongoose&#39;),

/**
 * 连接
 */
mongoose.connect(&#39;mongodb://127.0.0.1:27017/test&#39;, { useNewUrlParser: true });

/**
  * 连接成功
  */
mongoose.connection.on(&#39;connected&#39;, function () {    
    console.log(&#39;Mongoose connection open to &#39; + DB_URL);  
});    

/**
 * 连接异常
 */
mongoose.connection.on(&#39;error&#39;,function (err) {    
    console.log(&#39;Mongoose connection error: &#39; + err);  
});    

/**
 * 连接断开
 */
mongoose.connection.on(&#39;disconnected&#39;, function () {    
    console.log(&#39;Mongoose connection disconnected&#39;);  
}); </code></pre>
<p>具体数据库操作，可参考<a href="https://mongoosejs.com/docs/guide.html" target="_blank" rel="noopener">mongoose官方文档</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE%E5%8C%96%E6%80%9D%E6%83%B3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE%E5%8C%96%E6%80%9D%E6%83%B3/" itemprop="url">浅谈前端配置化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:29:22+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="源自共享"><a href="#源自共享" class="headerlink" title="源自共享"></a>源自共享</h1><hr>
<p>我觉得配置化来源于共享，是为了更好的实现共享化。</p>
<p>为了提升开发效率，我们通过对代码的封装，抽象出一系列可共享的单元。合理的封装大大的降低了代码冗余，从而提升了系统的性能和可维护性。</p>
<p>不过，不能追求共享的极致，如果封装过多，拆分过细反而会降低可维护性。</p>
<p>同时，共享离不开配置。小到一个组件，大到一个页面/项目，我们都是通过支持配置不同的参数来实现共享的目的。</p>
<h1 id="配置化细分"><a href="#配置化细分" class="headerlink" title="配置化细分"></a>配置化细分</h1><hr>
<ul>
<li>组件级别的配置：主要是合理的设计参数，使之覆盖多个场景，并具有可拓展性。</li>
<li>页面级别的配置：<code>Url</code>参数算一种，但是对于较复杂的配置，可以使用单独的 <code>js/json</code> 配置文件。</li>
<li>项目级别的配置：比如云平台，初始化项目的脚手架。</li>
</ul>
<h2 id="组件级别"><a href="#组件级别" class="headerlink" title="组件级别"></a>组件级别</h2><p>对于组件级别配置，不能过于臃肿。对于差异较大，对组件改造较大的场景，根据实际情况，可考虑通过以下方式实现：</p>
<ul>
<li>直接私有定制。</li>
<li>抽象新的可共享组件。</li>
<li>基于原有共享组件二次封装。</li>
</ul>
<h2 id="项目级别"><a href="#项目级别" class="headerlink" title="项目级别"></a>项目级别</h2><p><strong>SaaS云平台</strong> 可能是当前最完美的项目/系统级别复用的技术场景了。<br><strong>脚手架</strong> 算项目级别复用的一种配置化场景，通过 模版项目 + 配置文件 + 生成脚本，初始化一个项目。</p>
<h3 id="云平台"><a href="#云平台" class="headerlink" title="云平台"></a>云平台</h3><p>云计算平台也称为云平台，是指基于硬件资源和软件资源的服务，提供计算、网络和存储能力。其根本其实也是为了<strong>共享</strong>。云平台服务主要分为以下三种：</p>
<ul>
<li><strong>基础架构即服务 (<code>IaaS</code>)</strong> 是一种云计算产品，供应商为用户提供对服务器、存储和网络等计算资源的访问。组织可以在服务提供商的基础架构中使用自己的平台和应用。</li>
<li><strong>平台即服务 (<code>PaaS</code>)</strong> 是一种云计算产品，为用户提供云环境，用于开发、管理和交付应用。除存储器和其他计算资源以外，用户能够使用预构建工具套件，开发、定制和测试自己的应用。</li>
<li><strong>软件即服务 (<code>SaaS</code>)</strong> 是一种云计算产品，为用户提供对供应商云端软件的访问。用户无需在其本地设备上安装应用。相反，应用驻留在远程云网络中，通过 Web 或 API 进行访问。通过应用，用户可以存储和分析数据，并可进行项目协作。</li>
</ul>
<h2 id="页面级别"><a href="#页面级别" class="headerlink" title="页面级别"></a>页面级别</h2><p>页面级别的配置化，当然也是为了实现页面级别的共享。根据配置化的程度或者方式，可以大致分为以下两种：</p>
<ul>
<li><code>url</code>参数：我们大部分<code>url</code>参数是为了在页面之间进行参数传递，但也有许多用于页面共享的场景。比如 <code>status</code>，<code>disabled</code> 这类参数，常用于编辑、查看、新增数据共享同一个页面。</li>
<li>配置文件：<code>url</code>参数只适用于一些简单的配置，如果一个页面需要配置的信息较多，最好创建单独的配置文件。</li>
</ul>
<p>如果要使用配置文件，为了可维护性和可读性，还是需要制定一定的标准和规范，合理的设计配置文件。</p>
<p>配置文件一些建议:</p>
<ul>
<li>使用 <a href="https://json-schema.org/understanding-json-schema/" target="_blank" rel="noopener">JSON schema</a>这个国际公认标准。</li>
<li>配置场景分类，不同场景约定不同配置格式：比如 独立的功能模块 可以通过 switch（开关）；<code>form</code>表单：开源框架 <a href="https://alibaba.github.io/form-render/guide/design" target="_blank" rel="noopener">formRender</a>。</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://www.ibm.com/cn-zh/cloud/learn/iaas-paas-saas" target="_blank" rel="noopener">云服务类型介绍</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E5%89%8D%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%89%8D%E7%AB%AF%E5%A4%9A%E8%AF%AD%E8%A8%80%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url">前端多语言设计模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:26:18+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><hr>
<ul>
<li>国际化背景下，前端系统需要支持多语言的场景越来越多。</li>
<li>当下已经存在开源的前端多语言解决方案(比如 <code>i18n</code>)。以<code>React</code> 为例，多语言解决方案有 <code>i18n-react</code>  <code>react-intl</code>等。</li>
<li>不管是为了 合理运用 现有解决方案，还是针对自己公司的 特殊性 需要 二次封装，甚至完全 造轮子，了解 多语言设计模式 都很有必要。</li>
</ul>
<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><hr>
<ul>
<li>一套系统，支持多种语言，我们自然的会想到<strong>配置化</strong>。</li>
<li><code>N</code> 种语言 <code>N</code>套配置；在页面加载的时候，根据当前语言环境，注入对应的语言配置文件。在业务组件中通过对应的 <code>API</code> 读取配置展示文案。</li>
</ul>
<h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><hr>
<ul>
<li>创建和管理多语言资源文件</li>
<li>根据语言（<code>key</code>）获取资源文件</li>
<li>注入多语言资源文件并暴露调用的 <code>API</code></li>
<li>使用多语言</li>
</ul>
<h2 id="创建和管理多语言资源文件"><a href="#创建和管理多语言资源文件" class="headerlink" title="创建和管理多语言资源文件"></a>创建和管理多语言资源文件</h2><hr>
<ul>
<li>创建：支持 <code>N</code> 种语言，就配置 <code>N</code> 套对应的语言文件；通过<code>{ key: value }</code> 的方式组织起来； </li>
<li>粒度：为了扩展性和可维护性考虑，建议一个大的模块对应一套配置文件。对应特别通用的一些文案，可以配置一套公用配置文件。</li>
<li>管理：建议公用配置文件放顶层目录管理，模块配置文件放在模块目录一起管理。这样方便尽量只注入模块需要的配置文件。</li>
</ul>
<pre><code class="language-javascript">//目录结构
.
|-- common
  |-- locale
    |-- en_US.json
    |-- zh_CN.json
|-- pages
  |-- moduleA
    |-- public
      |-- locale
        |-- en_US.json
        |-- zh_CN.json
  |-- moduleB
    |-- public
      |-- locale
        |-- en_US.json
        |-- zh_CN.json

// 文件格式
{
  &quot;app.moduleA.hello_word&quot;: &quot;Hello word&quot;,
  &quot;app.moduleA.hello_tom&quot;: &quot;Hello tom&quot;
  ...
}</code></pre>
<h2 id="注入多语言资源文件并暴露调用的API"><a href="#注入多语言资源文件并暴露调用的API" class="headerlink" title="注入多语言资源文件并暴露调用的API"></a>注入多语言资源文件并暴露调用的API</h2><ul>
<li>获取多语言<code>key</code>：根据实际情况，一般来源有：<code>navigator.userAgent</code> <code>navigator.language</code> <code>URL参数</code>等。</li>
<li>顶层注入：封装多语言组件 (<code>LocalProvider</code>) 包裹业务组件。</li>
</ul>
<pre><code class="language-javascript">
// 顶层注入的核心代码...
const lang = comFun.getLang(); // 获取当前环境语言的封装方法
ReactDom.render((
  &lt;LocalProvider lang={lang} files={
    [
      import(&#39;@common/locale/&#39;+lang+&#39;.json&#39;), // 公共配置
      import(&#39;./public/locale/&#39;+lang+&#39;.json&#39;) // 模块配置
    ]
  }&gt;
    {/*  AppContainer: 其他公共封装   */}
    &lt;Route path=&quot;/&quot; component={AppContainer}&gt;  
      &lt;IndexRoute component ={Index}/&gt;
      &lt;Route path=&quot;index&quot; component={Index}/&gt;
      {/*  ...   */}
    &lt;/Route&gt;
  &lt;/LocalProvider&gt;
), document.getElementById(&#39;app&#39;));
</code></pre>
<pre><code class="language-javascript">
// LocalProvider 核心 &amp; 简易实现...
import React, { Component } from &#39;react&#39;

/**
 * 多语言组件封装
 */
class LocaleProvider extends Component {
  constructor(props) {
    super(props)
    const { files, lang } = this.props
    this.Lang = lang
    this.transObj = {};  //配置存储
    this.state = {
      localeReady: files &amp;&amp; files.length ? false : true
    }
    this.translateFile(files, this.Lang)
  }

  /**
   * 加载多语言文件
   * @param {Array} imports 异步加载语言文件
   * @param {String} lang 当前选择语言
   */
  translateFile = (imports, lang) =&gt; {
    if (imports &amp;&amp; imports.length) {
      Promise.all(imports)
        .then(
          modules =&gt; {
            this.transObj = Object.assign({}, ...modules)
            React.Component.prototype.T = this.$T  // 方法注入
            this.setState({ localeReady: true })
          },
          _ =&gt; {
            console.log(&#39;require translate file fail&#39;)
          }
        )
        .catch(e =&gt; {
          console.error(e)
        })
    }
  }
  /**
   * 读取多语言配置
   * @param {String} key 具体配置的key
   */
  $T = (key) =&gt; {
    if (typeof key === &#39;string&#39;) {
      return this.transObj[key] || key // 找不到key的配置 便返回key
    } else {
      throw new TypeError(&#39;Translate item should be string, but got &#39; +
        typeof key)
    }
  }

  render() {
    return &lt;div&gt;{this.state.localeReady &amp;&amp; this.props.children}&lt;/div&gt;
  }
}
export default LocaleProvider
</code></pre>
<blockquote>
<p>以上只是粗糙的简易实现，实际项目中还需要进行扩展，润色，封装。比如增加文案的 <code>format</code> 功能，可以插入变量。</p>
</blockquote>
<h2 id="使用多语言"><a href="#使用多语言" class="headerlink" title="使用多语言"></a>使用多语言</h2><pre><code class="language-javascript">// 略...
render() {

    return (
      &lt;div&gt;
        {/* 直接调用 LocaleProvider 中注入 react.Component 中的方法 T 使用*/}
        { this.T(&#39;app.moduleA.hello_word&#39;)}
      &lt;/div&gt;
    )
}</code></pre>
<blockquote>
<p>注意：如果要在方法组件中使用，需要把 <code>T</code> 作为 <code>props</code> 从 <code>Component</code> 父组件传递下去。也可以直接把文案作为 <code>props</code> 传递下去。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E5%89%8D%E7%AB%AF%E6%B4%BB%E5%8A%A8%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%89%8D%E7%AB%AF%E6%B4%BB%E5%8A%A8%E5%BC%95%E6%93%8E%E8%AE%BE%E8%AE%A1%E5%8F%8A%E5%AE%9E%E7%8E%B0/" itemprop="url">前端活动引擎设计及实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:23:53+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者太懒，还没写……</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%89%8D%E7%AB%AF%E5%8F%AF%E8%A7%86%E5%8C%96/" itemprop="url">前端可视化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:20:57+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <blockquote>
<p>作者太懒，还没写……</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E7%BC%96%E7%A8%8B%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0/" itemprop="url">一些编程/算法题练习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:19:15+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="温馨提示"><a href="#温馨提示" class="headerlink" title="温馨提示"></a>温馨提示</h1><p><strong>以下纯属自我练习，可能不是最优解，甚至可能存在一些问题</strong></p>
<h1 id="写一个-mySetInterVal-fn-a-b-每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal"><a href="#写一个-mySetInterVal-fn-a-b-每次间隔-a-a-b-a-2b-的时间，然后写一个-myClear，停止上面的-mySetInterVal" class="headerlink" title="写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal"></a>写一个 mySetInterVal(fn, a, b),每次间隔 a,a+b,a+2b 的时间，然后写一个 myClear，停止上面的 mySetInterVal</h1><pre><code class="language-js">function mySetInterVal(fn, a, b) {
  let index = 0;
  let timmer;
  const loop = () =&gt; {
    timmer = setTimeout( ()=&gt; {
      fn();
      index++;
      loop();
    }, a + index*b );
  };
  loop();
  return () =&gt; {
    clearTimeout(timmer);
  }
}
let testMyInt = mySetInterVal( () =&gt; { console.log(&#39;acc&#39;)}, 1000, 2000);</code></pre>
<h1 id="斐波那契额数列"><a href="#斐波那契额数列" class="headerlink" title="斐波那契额数列"></a>斐波那契额数列</h1><pre><code class="language-js">// 斐波那契额数列的公式表示
F(0) = 0;
F(1) = 1;
F(n) = F(n - 1) + F(n - 2);

// 递归实现
function fib(n) {
  if(n &lt; 0) throw new Error(&#39;输入的数字不能小于0&#39;);
  if (n &lt; 2) {
    return n;
  }
  return fib(n - 1) + fib(n - 2);
}</code></pre>
<h1 id="字符串出现的不重复最长长度"><a href="#字符串出现的不重复最长长度" class="headerlink" title="字符串出现的不重复最长长度"></a>字符串出现的不重复最长长度</h1><pre><code class="language-js">function lengthOfLongestSubstring(str) {
  let result = &#39;&#39;;
  const strArr = str.split(&#39;&#39;);
  for(let index = 0; index &lt; str.length -1 ; index ++) {
    let temp = strArr [index];
    for(let cursor = index + 1 ; cursor &lt; str.length; cursor++ ) {
      if (temp.indexOf(strArr[cursor]) &gt; -1 ) {
        break;
      } else {
        temp += strArr[cursor]
      }
    }
    if (temp.length &gt; result.length ) {
      result = temp;
    }
  }
  return result;
}
lengthOfLongestSubstring(&quot;adfafwefffdasdcx&quot;);</code></pre>
<h1 id="lodash-get-实现"><a href="#lodash-get-实现" class="headerlink" title="lodash._get 实现"></a>lodash._get 实现</h1><pre><code class="language-js">function get(source, path, defaultValue = undefined) {
  // a[3].b -&gt; a.3.b -&gt; [a,3,b]
 // path 中也可能是数组的路径，全部转化成 . 运算符并组成数组
  const paths = path.replace(/\[(\d+)\]/g, &quot;.$1&quot;).split(&quot;.&quot;);
  let result = source;
  for (const p of paths) {
    // 注意 null 与 undefined 取属性会报错，所以使用 Object 包装一下。
    result = Object(result)[p];
    if (result == undefined) {
      return defaultValue;
    }
  }
  return result;
}
// 测试用例
console.log(get({ a: null }, &quot;a.b.c&quot;, 3)); // output: 3
console.log(get({ a: undefined }, &quot;a&quot;, 3)); // output: 3
console.log(get({ a: null }, &quot;a&quot;, 3)); // output: 3
console.log(get({ a: [{ b: 1 }] }, &quot;a[0].b&quot;, 3)); // output: 1

// 不考虑数组的情况

const _get = (object, keys, val) =&gt; {
  return keys.split(/\./).reduce(
   (o, j)=&gt;( (o || {})[j] ), 
   object
  ) || val
 }
 console.log(get({ a: null }, &quot;a.b.c&quot;, 3)); // output: 3
 console.log(get({ a: undefined }, &quot;a&quot;, 3)); // output: 3
 console.log(get({ a: null }, &quot;a&quot;, 3)); // output: 3
 console.log(get({ a: { b: 1 } }, &quot;a.b&quot;, 3)); // output: 1</code></pre>
<h1 id="实现-add-1-2-3"><a href="#实现-add-1-2-3" class="headerlink" title="实现 add(1)(2)(3)"></a>实现 add(1)(2)(3)</h1><pre><code class="language-js"> function add (a) {
   return (b) =&gt; {
     return (c) =&gt; {
       return a + b + c
     }
   }
 }
 add(1)(2)(3)

 // 扩展 ：多参数
 function addMore (...a) {
  let arr = a
  return (...b) =&gt; {
    arr = arr.concat(b)
    return (...c) =&gt; {
      arr = arr.concat(c)
      return arr.reduce((i,j) =&gt; i+j)
    }
  }
}
addMore(1)(2,3)(4,5)</code></pre>
<h1 id="Promiss实现"><a href="#Promiss实现" class="headerlink" title="Promiss实现"></a>Promiss实现</h1><pre><code class="language-js">// 参数：一个含有异步操作的功能函数。
// 状态管理： Promiss是有三个状态的
// 三要素： resolve，reject，then，
// 链式调用： return this
// 串行
const PENDING = &#39;pending&#39;
const FULFILLED = &#39;fulfilled&#39;
const REJECTED = &#39;rejected&#39;

function MyPromise(execute){

  let state = PENDING,
      resHandlers = [],
      rejHandlers = [],
      value = null,
      reason = &#39;&#39;

  function resolve(val) {
    value = val;
    state = FULFILLED;
    setTimeout(() =&gt; {
      resHandlers.forEach((headler) =&gt; {
        headler(val);
      })
    }, 0);
  }

  function reject( err ) {
    reason = err || &#39;&#39;;
    state = REJECTED;
    setTimeout(() =&gt; {
      rejHandlers.forEach((headler) =&gt; {
        headler(reason);
      })
    }, 0);
  }

  this.then = ( onFulfilled, onRejected ) =&gt; {
    if (state === FULFILLED) {
      typeof onFulfilled === &#39;function&#39; &amp;&amp; onFulfilled(value)
    } else if (this.state === REJECTED) {
      typeof onRejected === &#39;function&#39; &amp;&amp; onRejected(reason)
    } else {
      typeof onFulfilled === &#39;function&#39; &amp;&amp; resHandlers.push(onFulfilled)
      typeof onRejected === &#39;function&#39; &amp;&amp; rejHandlers.push(onRejected)
    } 
    return this;
  }

  execute ( resolve, reject );
}

new MyPromise((resolve) =&gt; {
  setTimeout(()=&gt;  {
    resolve(&#39;1&#39;)
  },3000)
}).then((res)=&gt; {
  console.log(&quot;1&quot;,res);
}).then((res)=&gt; {
  console.log(&quot;2&quot;,res);
})

MyPromise.prototype.all = (promisess) =&gt; {
  return new MyPromise(( resolve, reject ) =&gt; {
    let resultErr = [],
        count = 0;

    promisess.forEach((promise,i) =&gt; {
      promise.then((res) =&gt; {
        resultErr[i] = res;
        if ( ++count === promisess.length ) {
          resolve(resultErr)
        }
      }, (reason) =&gt; {
        reject(reason)
      })
    })
  })
}</code></pre>
<h1 id="手写-发布订阅-（观察者模式）"><a href="#手写-发布订阅-（观察者模式）" class="headerlink" title="手写 发布订阅 （观察者模式）"></a>手写 发布订阅 （观察者模式）</h1><pre><code class="language-js">function MyEventEmiter () {
  let eList = [],
      index = 0

  this.on = (eName, headler) =&gt; {
    eName &amp;&amp; typeof headler === &#39;function&#39; &amp;&amp; eList.push({ index, eName, headler })
    index ++;
    return this;
  }

  this.off = (_index) =&gt; {
    for(var i = 0; i &lt; eList.length ; i++) {
      if (eList[i].index === _index) {
        eList.splice(i,1);
        break;
      }
    }
  }

  this.once = (eName, headler) =&gt; {
    const _index = index;
    const _this = this;
    eName &amp;&amp; typeof headler === &#39;function&#39; &amp;&amp; 
    eList.push({
      index, 
      eName, 
      headler: (data) =&gt; { 
        headler(data);
        _this.off(_index);
      }
    })
    index ++;
    return this;
  }

  this.emit = (eName, data) =&gt; {
    eList.forEach((event) =&gt; {
      event.eName === eName &amp;&amp; event.headler(data);
    })
  }
}

var myEvent = new MyEventEmiter();
myEvent.once(&#39;click&#39;, (data) =&gt; {
  console.log(&#39;do click only once&#39;, data)
}).on(&#39;click&#39;, (data) =&gt; {
  console.log(&#39;do click&#39;, data)
})
setTimeout(() =&gt; { myEvent.emit(&#39;click&#39;,&#39;first&#39;); },100 )
setTimeout(() =&gt; { myEvent.emit(&#39;click&#39;,&#39;second&#39;); },100 )
setTimeout(() =&gt; { myEvent.emit(&#39;click&#39;,&#39;third&#39;); },100 )</code></pre>
<h1 id="数组转树"><a href="#数组转树" class="headerlink" title="数组转树"></a>数组转树</h1><pre><code class="language-js">function arrToTree (arrDate) {
  arrDate.forEach((item1) =&gt; {
    item1.children = arrDate.filter((item2)=&gt;{ return item2.parentId === item1.id})
  })
  const result = arrDate.filter((a) =&gt; { return !a.parentId })
  console.log(arrDate)
  return result
}
// 网友++转对象，只需遍历一次。
function convert(list) {
  const map = list.reduce((acc, item) =&gt; {
    acc[item.id] = item
    return acc
  }, {})
  const result = []
  for (const key in map) {
    const item = map[key]
    if (item.parentId === 0) {
      result.push(item)
    } else {
      const parent = map[item.parentId]
      if (parent) {
        parent.children = parent.children || []
        parent.children.push(item)
      }
    }
  }
  return result
}

arrToTree([
  {id:1, parentId: null, name: &#39;a&#39;},
  {id:2, parentId: null, name: &#39;b&#39;},
  {id:3, parentId: 1, name: &#39;c&#39;},
  {id:4, parentId: 2, name: &#39;d&#39;},
  {id:5, parentId: 1, name: &#39;e&#39;},
  {id:6, parentId: 3, name: &#39;f&#39;},
  {id:7, parentId: 4, name: &#39;g&#39;},
  {id:8, parentId: 7, name: &#39;h&#39;},
]);</code></pre>
<pre><code class="language-js">/*有10个篮子，分别装有1，2，4，8，16，32，64，128，256，512 个苹果，篮子编号为 0 ~ 9，请问如果正好想取 825 个苹果， 需要的篮子编号为多少？例如取 5 个苹果，需要 0，2 号篮子（1 + 4 个）。*/

function getAppleBoxIndex(arr,num) {
  const len = arr.length
  let res = [];
  let cur = 0;
  for(let i = len -1; i &gt; -1 ; i--) {
    if (cur + arr[i] === num) {
      res.push(i);
      break;
    } else if (cur + arr[i] &lt; num) {
      cur += arr[i];
      res.push(i);
    }
  }
  return res;
}

getAppleBoxIndex([1,2,4,8,16,32,64,128,256,512],825)
</code></pre>
<h1 id="Promise-串行"><a href="#Promise-串行" class="headerlink" title="Promise 串行"></a>Promise 串行</h1><pre><code class="language-js">/**
 * 多个Promise 链式依次执行  
 * 后面promise依赖前面返回的数据
*/

function myCompose(...args){
  let prmLink = Promise.resolve();
  args.forEach((prm) =&gt; {
    prmLink = prmLink.then(prm);
  })
  return prmLink
}

let promA = function() { console.log(&#39;promA:acc&#39;); return Promise.resolve(1) };
let promB = function(val) { console.log(&#39;promB:acc&#39;, val); return Promise.resolve(++val) };
let promC = function(val) { console.log(&#39;promC:acc&#39;, val); return Promise.resolve(++val) };
let promD = function(val) { console.log(&#39;promD:acc&#39;, val); return Promise.resolve(++val)  };

myCompose(promA,promB,promC,promD).then((val) =&gt; {console.log(&#39;finally result:&#39;, val);});

// promA:acc
// promB:acc 1
// promC:acc 2
// promD:acc 3
// inally result: 4
// Promise {&lt;fulfilled&gt;: undefined}</code></pre>
<h1 id="控制promise并行数量"><a href="#控制promise并行数量" class="headerlink" title="控制promise并行数量"></a>控制promise并行数量</h1><pre><code class="language-js">/**
 * 控制多个 Promise 异步fetch 同时只能并行执行 limit 个任务
*/
function doFetchList(list, limit) {
  const len = list.length;
  let result = [];
  let count = 0;
  return new Promise((resolve, reject)=&gt;{
    while(current &lt; limit) {
      next();
    }
    function next() {
      let current = count++;
      if (current &gt; len) {
        resolve(result);
      }
      fetch(list[current]).then((res) =&gt; {
        result[current] = res;
        if (current &lt; len) next();
      },(err) =&gt; {
        result[current] = err;
        if (current &lt; len) next();
      })
    }
  }) 
}</code></pre>
<h1 id="异步请求失败重试"><a href="#异步请求失败重试" class="headerlink" title="异步请求失败重试"></a>异步请求失败重试</h1><pre><code class="language-js">function promiseRetry(asyncFn, maxCount) {
    let currentCount = maxCount;
    return new Promise((resolve,reject) =&gt; {
      function run () {
        asyncFn().then((res) =&gt; {
          resolve(res);
        },(reason) =&gt; {
          if (--currentCount) {
            run();
          } else {
            reject(reason)
          }
        })
      }
      run();
    })
}

//测试用例:
function fn() {
  return new Promise((resolve,reject) =&gt; {
    console.log(&#39;running:&#39;, new Date());
    setTimeout(()=&gt; {
      reject(&#39;err&#39;)
    },1000)
  })
}

promiseRetry(fn,3).then(() =&gt; {
  console.log(&#39;success&#39;);
},(reason) =&gt; {
  console.log(&#39;err:&#39; + reason);
})</code></pre>
<h1 id="使用闭包实现每隔-1-秒打印-1-500"><a href="#使用闭包实现每隔-1-秒打印-1-500" class="headerlink" title="使用闭包实现每隔 1 秒打印 1-500"></a>使用闭包实现每隔 1 秒打印 1-500</h1><pre><code class="language-js">// 不用promise
function printNum(maxNum) {
  let i = 1
  while(i &lt;= maxNum) {
    ((num) =&gt; {
      setTimeout(() =&gt; {
        console.log(num);
      }, 1000 * num)
    })(i++)
  }
}
printNum(500);

// v2：
function printNum(maxNum) {
  for(let i = 1; i &lt;= maxNum; ++i) {
    ((i) =&gt; {
      setTimeout(() =&gt; {
        console.log(i);
      }, 1000 * i)
    })(i)
  }
}
printNum(500);


//使用promise

var sleep = function (time, i) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      resolve(i);
    }, time);
  })
};


var start = async function () {
  for (let i = 0; i &lt; 6; i++) {
    let result = await sleep(1000, i);
    console.log(result);
  }
};
start();
</code></pre>
<h1 id="返回一个字符串中出现次数最多的字符。"><a href="#返回一个字符串中出现次数最多的字符。" class="headerlink" title="返回一个字符串中出现次数最多的字符。"></a>返回一个字符串中出现次数最多的字符。</h1><pre><code class="language-js">function getMaxlen(str) {
  if (!str) return &#39;&#39;;
  const len = str.length;
  if (len &lt;= 1) return str;
  let strMap = new Map();
  let maxSize = 0;
  let result = [];
  for (let i = 0; i &lt; len; i++) {
    if (strMap.has(str[i])) {
      strMap.set(str[i], strMap.get(str[i]) + 1);
      maxSize = Math.max(maxSize, strMap.get(str[i]) )
    } else {
      strMap.set(str[i],1);
    }
  }
  strMap.forEach((value,key) =&gt; {
    if (value === maxSize) {
      result.push(key)
    }
  })
  return result;

}

getMaxlen(&#39;abcdccbdb58575&#39;) // [&quot;b&quot;, &quot;c&quot;, &quot;5&quot;]</code></pre>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://www.mala520.life/2020/08/21/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="祁连">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/sgj.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Live and learn">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/08/21/%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%8C%96/" itemprop="url">前端工程化</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-08-21T17:12:53+08:00">
                2020-08-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是前端工程化"><a href="#什么是前端工程化" class="headerlink" title="什么是前端工程化"></a>什么是前端工程化</h1><hr>
<p>我们都知道，当代前端工程已经从 <code>Page</code> 级别 上升到 <code>App</code> 级别了。并且<code>Web</code> 业务的 复杂化 和 多元化 还在日益提升当中。</p>
<p>这个时候，前端便会面临以下问题：</p>
<ul>
<li>大体量：多功能、多页面、多状态、多系统；</li>
<li>大规模：多人甚至多团队合作开发；</li>
<li>高性能：<code>CDN</code>部署、缓存控制、请求合并、按需加载、同步/异步加载、移动端首屏<code>CSS</code>内嵌、<code>HTTP2</code>服务端资源推送。</li>
</ul>
<p>如果没有 科学 的 管理方法 和 技术手段 的约束。时间，成本会不断上升，代码质量 会不断下降。最后变得难以维护，引发 软件危机 。而 软件工程 便是为了应对 软件危机。</p>
<p>因此，我们也必须以 <strong>软件工程</strong> 的角度来对待前端开发。来思考以下几个问题：</p>
<ul>
<li><p>如何高效的多人协作？</p>
</li>
<li><p>如何提供开发效率？</p>
</li>
<li><p>如何提升开发质量？</p>
</li>
<li><p>如何提升项目可维护性？</p>
</li>
<li><p>如何降低项目生产问题？</p>
</li>
</ul>
<p>软件工程(<code>Software Engineering</code>)，简称<code>SE</code>。旨在将系统化的、严格约束的、可量化的方法应用于软件的开发、运行和维护，即将工程化应用于软件。</p>
<p>那么，前端工程化便是运用 软件工程 的 技术 和 方法，让前端开发流程、技术、工具、经验等更加 规范化、标准化。主要目的是为了提高开发效率，提升代码质量，并在项目不断迭代过程中保证 良好的可维护性 和稳定性。</p>
<h1 id="软件工程核心思想"><a href="#软件工程核心思想" class="headerlink" title="软件工程核心思想"></a>软件工程核心思想</h1><hr>
<p>有这样一个公式：<code>SE = 过程 + 方法 + 工具</code></p>
<ul>
<li><p>过程: 解决 <strong>软件开发周期</strong> 中的 <strong>混乱</strong> 问题，构建高质量软件。</p>
<ul>
<li>软件开发周期：设计，需求分析，开发，联调，测试，部署，维护，不断迭代。</li>
<li>形成 和 规范 开发流程。因地制宜，制定和不断修正，形成适合自己团队的开发流程规范。</li>
</ul>
</li>
<li><p>方法 : 是指在整个过程中，如何构建系统的方法学。主要手段：</p>
<ul>
<li><p>复用：在一个新系统中，大部分的内容是成熟的，只有小部分内容是全新的；复用已有的功能模块，既可以提高开发效率，也可以改善新开发过程中带来的质量问题。</p>
</li>
<li><p>分治：将复杂问题分解为若干可独立解决的简单子问题，并分别独立求解，以降低复杂性；然后再将各子问题的解综合起来，形成最初复杂问题的解。</p>
<ul>
<li>核心问题：怎样的分解策略可以使得软件更容易理解、开发和维护？</li>
</ul>
</li>
<li><p>折中：不同的需求之间往往存在矛盾与冲突，需要通过折中来作出的合理的取舍，找到使双方均满意的点。</p>
<ul>
<li>核心问题：如何调和矛盾(需求之间、人与人之间、供需双方之间，等等)</li>
</ul>
</li>
<li><p>演化：软件系统在其生命周期中面临各种变化。要游刃有余的应对这种变化。</p>
<ul>
<li>核心问题：在设计软件的初期，就要充分考虑到未来可能的变化，并采用恰当的设计决策，使软件具有适应变化的能力。</li>
</ul>
</li>
</ul>
</li>
<li><p>工具: 我们需要工具来辅助方法的执行，提高效率。</p>
<ul>
<li>通过工具，可以把一些手动的工作自动化，比如自动化测试工具，自动构建部署工具；</li>
<li>通过工具，可以帮助把一些流程规范起来，比如 <code>Bug</code> 跟踪、源代码管理；</li>
<li>通过工具，帮助提高编码效率，比如各种编辑器<code>IDE</code>、插件等。</li>
</ul>
</li>
</ul>
<blockquote>
<p>任何简单机械的重复劳动都应该让机器去完成。</p>
</blockquote>
<h1 id="前端工程化实践"><a href="#前端工程化实践" class="headerlink" title="前端工程化实践"></a>前端工程化实践</h1><hr>
<p>假设一个前端工程要从 <code>0</code> 开始，我们可以把前端工程化实践分为3个阶段：</p>
<ul>
<li>准备阶段：技术选型；架构设计；业务分治。</li>
<li>开发&amp;迭代阶段：如何高效，高质量的进行需求开发，功能迭代。并保证良好的可维护性。</li>
<li>部署&amp;维护阶段：自动化打包部署；<code>CI/CD</code>；生产问题定位；性能优化；</li>
</ul>
<blockquote>
<p>前端是一种技术问题较少、工程问题较多的软件开发领域。</p>
</blockquote>
<h2 id="准备阶段"><a href="#准备阶段" class="headerlink" title="准备阶段"></a>准备阶段</h2><p>该阶段有三个主要任务：</p>
<ul>
<li><p>技术选型：业务场景，公司情况，团队情况三者相结合，选择合适的主框架（比如，<code>React</code>，<code>Vue</code>），衍生库（如 <code>NextJS</code>，<code>AntDesign</code>）以及各类管理工具选择。</p>
<ul>
<li>比如，该业务是定制化较强的，面向 <code>C</code> 端用户的 <code>H5</code> 页面；团队成员技术栈以 <code>React</code> 为主。那么可以选择 <code>React</code> 主框架，然后规划自己的 <code>UI</code> 库，工具库，业务组件库等。</li>
<li>比如，该业务是 <code>BE</code> 后台管理系统，面向内部运营人员。那么可以直接选择阿里开源的 <code>AntDesign</code> 或者 <code>IceWork</code>。自带成熟物料，<code>UI</code> 组件库等，可以大大降低开发和维护成本。</li>
<li>比如，你的BE后台存在大量的<code>Form</code>表单操作，可以使用开源的 <code>form-render</code> 配置化方案来提升开发效率。</li>
<li>工具选择：比如代码管理工具，一般是 <code>Git</code>，要制定和严格执行 分支管理策略；包管理器，你可以直接使用 <code>npm</code>，推荐 <code>yarn</code>。开发工具，主流是<code>VScode</code>，可以选装一系列辅助插件，也可以diy插件。</li>
</ul>
</li>
<li><p>架构设计：结合自身业务场景和环境，全面考虑，进行合理的架构设计，即使你使用 <code>IceWork</code> 这种自身生态全面的框架。</p>
<ul>
<li>比如，对架构进行分层管理，比如设置共享层（ 底层UI组件库，公共业务组件库，util工具库等 ），定制层（ 功能页面等 ）。</li>
</ul>
</li>
<li><p>业务分治：业务分类，划分子系统；通过单独的 <code>Git</code> 仓库进行子系统管理。</p>
<ul>
<li>最好建立自己的脚手架工具，子系统通过脚手架统一初始化。</li>
<li>权限管理，责任到人。</li>
</ul>
</li>
</ul>
<h2 id="开发-amp-迭代阶段"><a href="#开发-amp-迭代阶段" class="headerlink" title="开发&amp;迭代阶段"></a>开发&amp;迭代阶段</h2><p>前面有提到，这个阶段的主要任务是如何高效，高质量的进行需求开发，功能迭代。并保证良好的可维护性。</p>
<p>目前，我们主要通过以下几个几个方面来进行约束：</p>
<ul>
<li>模块化</li>
<li>组件化</li>
<li>规范化</li>
</ul>
<h3 id="模块化："><a href="#模块化：" class="headerlink" title="模块化："></a>模块化：</h3><p>前端的模块化已经由来已久，已经形成了成熟的进行技术体系。</p>
<p><code>JS</code> 模块化: 从之前的 <code>RequireJS</code>（<code>AMD</code>）、<code>SeaJS</code> (<code>CMD</code>) 到现在的 <code>CommonJS</code>、<code>ES6 Module</code>。</p>
<p><code>CSS</code>模块化: 我们还可以使用  <code>Less</code>、<code>Sass</code>、<code>Stylus</code> 等预处理器，对 <code>CSS</code> 进行模块化管理。</p>
<p>资源模块化: <code>Webpack</code> 更是把模块化推向极致，其核心思想是：一切皆模块，除了 <code>JS</code> 和 <code>CSS</code>，还包括  <code>imgage</code>，<code>iconFont</code> 等静态资源。</p>
<h3 id="组件化："><a href="#组件化：" class="headerlink" title="组件化："></a>组件化：</h3><p>组件化应用了 分治 和 复用 的思想。通过组件化，我们的所有页面都像是通过积木（组件）组合而成。</p>
<p>组件不只包括 <code>UI</code> 组件，还可以是不含 <code>UI</code> 的功能性组件。</p>
<p>组件化追求 小而美。问题是我们在抽象组件的时候，如何达到 小 和 美 的平衡，并不是拆分的越细越好。还有考虑 组件 的 复用性 和 可拓展性。</p>
<h3 id="规范化："><a href="#规范化：" class="headerlink" title="规范化："></a>规范化：</h3><p>形成一系列规范，并不断完善。严格执行，做好过程管理。</p>
<ul>
<li><p>编码规范</p>
</li>
<li><p>组件规范</p>
</li>
<li><p>接口规范</p>
</li>
<li><p>文档规范</p>
</li>
</ul>
<p>规范重要，更重要的规范的执行力度。自觉可能是最重要的，但又是最不可靠的。还是需要一些干预措施：</p>
<ul>
<li><p>实行 <code>codeReview</code>。</p>
</li>
<li><p>使用 <code>ESlint</code>，<code>Husky</code>，<code>Git hooks</code> 等工具约束。</p>
</li>
</ul>
<h2 id="部署-amp-维护阶段"><a href="#部署-amp-维护阶段" class="headerlink" title="部署&amp;维护阶段"></a>部署&amp;维护阶段</h2><p>该阶段的核心是 <strong>自动化</strong>。</p>
<p>首先，前端需要本地 <code>Dev</code> 调试 和 生产打包构建。可以使用 <code>Gulp</code>, <code>Webpack</code>, <code>Babel</code> 等工具库，添加配置文件，编写打包脚本来实现。</p>
<ul>
<li><p><code>Gulp</code> 是基于 <code>Nodejs</code> 的自动任务运行器，它能自动化地完成 <code>javascript/sass/less/html/image/css</code> 等文件的的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。优势是利用流的方式进行文件的处理，使用管道（<code>pipe</code>）思想，前一级的输出，直接变成后一级的输入，通过管道将多个任务和操作连接起来，因此只有一次<code>I/O</code>的过程，流程更清晰，更纯粹。<code>Gulp</code>去除了中间文件，只将最后的输出写入磁盘，整个过程因此变得更快。</p>
</li>
<li><p><code>Webpack</code> 是一个模块打包工具，它的作用是把 互相依赖 的 模块 处理成 静态资源。其核心思想是一切皆模块。</p>
</li>
<li><p><code>Babel</code> 是一个 <code>JavaScript</code> 编译器。负责把浏览器不认识的语法，编译成浏览器认识的语法。<code>Webpack</code> 中可以通过 <code>babel-loader</code> 使用 <code>babel</code>。</p>
</li>
</ul>
<p>可以通过一些 平台 实现 自动化部署 以及 <code>CI/CD</code>。比如 <code>Jenkins</code>，广泛使用的开源<code>CI / CD</code>工具之一。它基于<code>Java</code>，可以自动执行与软件的构建，测试，部署和交付相关的任务。可在<code>Windows</code>，<code>macOS</code>和其他<code>Unix</code>版本上使用。</p>
<p>这些 <code>CI/CD</code> 平台都会用到 <strong>容器技术</strong>，我们也可以了解一下：</p>
<ul>
<li><code>Docker</code>：<code>Docker</code>是一个开源的应用容器引擎，开发者可以打包他们的应用及依赖到一个可移植的容器中，发布到流行的<code>Linux</code>机器上，也可实现虚拟化。</li>
<li><code>kubernetes</code>： 简称 <code>k8s</code> , 是一个开源的容器集群管理系统，可以实现容器集群的自动化部署、自动扩缩容、维护等功能。</li>
</ul>
<blockquote>
<p>我们可以用 <code>k8s</code> 去管理 <code>Docker</code> 集群，即可以将 <code>Docker</code> 看成 <code>k8s</code> 内部使用的低级别组件。另外，<code>k8s</code> 不仅仅支持 <code>Docker</code>，还支持 <code>Rocket</code>，这是另一种容器技术。</p>
</blockquote>
<h1 id="参考-amp-拓展文档"><a href="#参考-amp-拓展文档" class="headerlink" title="参考&amp;拓展文档"></a>参考&amp;拓展文档</h1><hr>
<p><a href="https://www.jianshu.com/p/88ed70476adb" target="_blank" rel="noopener">前端工程化的理解</a><br><a href="https://www.cnblogs.com/onebox/p/9570518.html" target="_blank" rel="noopener">浅谈前端工程化</a><br><a href="https://www.cnblogs.com/qcloud1001/p/9273549.html" target="_blank" rel="noopener">什么是容器技术</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/sgj.jpeg"
                alt="祁连" />
            
              <p class="site-author-name" itemprop="name">祁连</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">59</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                大牛👇
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="http://www.ruanyifeng.com/blog/" title="阮一峰" target="_blank">阮一峰</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://overreacted.io/zh-hans/" title="Dan Abramov" target="_blank">Dan Abramov</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://qianduan.group/" title="寸志" target="_blank">寸志</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://www.robinwieruch.de/blog" title="Robin Wieruch" target="_blank">Robin Wieruch</a>
                  </li>
                
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">祁连</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




<script src="/js/prism/prism.js" async></script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/hijiki.model.json"},"display":{"position":"left","width":150,"height":300},"mobile":{"show":false},"react":{"opacity":0.9},"log":false});</script></body>
</html>
